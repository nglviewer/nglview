// File:js/ngl/shims.js

/**
 * @file Shims
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


//////////////
// Polyfills

( function( global ) {

    'use strict';

    // Console-polyfill. MIT license.
    // https://github.com/paulmillr/console-polyfill
    // Make it safe to do console.log() always.

    global.console = global.console || {};
    var con = global.console;
    var prop, method;
    var empty = {};
    var dummy = function(){};
    var properties = 'memory'.split( ',' );
    var methods = (
        'assert,clear,count,debug,dir,dirxml,error,exception,group,' +
        'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
        'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn'
    ).split(',');

    while( prop = properties.pop() ) if( !con[ prop] ) con[ prop ] = empty;
    while( method = methods.pop() ) if( !con[ method] ) con[ method ] = dummy;

    // Using `this` for web workers while maintaining compatibility with browser
    // targeted script loaders such as Browserify or Webpack where the only way to
    // get to the global object is via `window`.

} )( typeof window === 'undefined' ? this : window );


if( typeof importScripts !== 'function' && !HTMLCanvasElement.prototype.toBlob ){

    // http://code.google.com/p/chromium/issues/detail?id=67587#57

    Object.defineProperty( HTMLCanvasElement.prototype, 'toBlob', {

        value: function( callback, type, quality ){

            var bin = window.atob( this.toDataURL( type, quality ).split( ',' )[ 1 ] ),
                len = bin.length,
                len32 = len >> 2,
                a8 = new Uint8Array( len ),
                a32 = new Uint32Array( a8.buffer, 0, len32 );

            for( var i=0, j=0; i < len32; i++ ) {

                a32[i] = bin.charCodeAt( j++ ) |
                    bin.charCodeAt( j++ ) << 8 |
                    bin.charCodeAt( j++ ) << 16 |
                    bin.charCodeAt( j++ ) << 24;

            }

            var tailLength = len & 3;

            while( tailLength-- ){

                a8[ j ] = bin.charCodeAt( j++ );

            }

            callback( new Blob( [ a8 ], { 'type': type || 'image/png' } ) );

        }

    } );

}


if( !Number.isInteger ){

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

    Number.isInteger = function isInteger( nVal ){
        return typeof nVal === "number" && isFinite( nVal ) && nVal > -9007199254740992 && nVal < 9007199254740992 && Math.floor( nVal ) === nVal;
    };

}


if( !Number.isNaN ){

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN

    Number.isNaN = function isNaN( value ){
        return value !== value;
    };

}


if( !Object.assign ){

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

    Object.defineProperty( Object, "assign", {

        enumerable: false,
        configurable: true,
        writable: true,

        value: function(target, firstSource) {

            "use strict";
            if (target === undefined || target === null)
            throw new TypeError("Cannot convert first argument to object");

            var to = Object(target);

            var hasPendingException = false;
            var pendingException;

            for (var i = 1; i < arguments.length; i++) {

                var nextSource = arguments[i];
                if (nextSource === undefined || nextSource === null)
                    continue;

                var keysArray = Object.keys(Object(nextSource));
                for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {

                    var nextKey = keysArray[nextIndex];
                    try {
                        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable)
                            to[nextKey] = nextSource[nextKey];
                    } catch (e) {
                        if (!hasPendingException) {
                            hasPendingException = true;
                            pendingException = e;
                        }
                    }

                }

                if (hasPendingException)
                    throw pendingException;

            }

            return to;

        }

    } );

}


if (!String.prototype.startsWith) {

    /*! https://mths.be/startswith v0.2.0 by @mathias */

    (function() {
        'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
        var defineProperty = (function() {
            // IE 8 only supports `Object.defineProperty` on DOM elements
            try {
                var object = {};
                var $defineProperty = Object.defineProperty;
                var result = $defineProperty(object, object, object) && $defineProperty;
            } catch(error) {}
            return result;
        }());
        var toString = {}.toString;
        var startsWith = function(search) {
            if (this == null) {
                throw TypeError();
            }
            var string = String(this);
            if (search && toString.call(search) == '[object RegExp]') {
                throw TypeError();
            }
            var stringLength = string.length;
            var searchString = String(search);
            var searchLength = searchString.length;
            var position = arguments.length > 1 ? arguments[1] : undefined;
            // `ToInteger`
            var pos = position ? Number(position) : 0;
            if (pos != pos) { // better `isNaN`
                pos = 0;
            }
            var start = Math.min(Math.max(pos, 0), stringLength);
            // Avoid the `indexOf` call if no match is possible
            if (searchLength + start > stringLength) {
                return false;
            }
            var index = -1;
            while (++index < searchLength) {
                if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
                    return false;
                }
            }
            return true;
        };
        if (defineProperty) {
            defineProperty(String.prototype, 'startsWith', {
                'value': startsWith,
                'configurable': true,
                'writable': true
            });
        } else {
            String.prototype.startsWith = startsWith;
        }
    }());

}


if( typeof importScripts !== 'function' ){

    ( function() {

        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

        // requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel

        // MIT license

        var lastTime = 0;
        var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

        for( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ){

            window.requestAnimationFrame = (
                window[ vendors[ x ] + 'RequestAnimationFrame' ]
            );

            window.cancelAnimationFrame = (
                window[ vendors[ x ] + 'CancelAnimationFrame' ] ||
                window[ vendors[ x ] + 'CancelRequestAnimationFrame' ]
            );

        }

        if( !window.requestAnimationFrame ){

            window.requestAnimationFrame = function( callback, element ){

                var currTime = new Date().getTime();
                var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );

                var id = window.setTimeout( function(){

                    callback( currTime + timeToCall );

                }, timeToCall );

                lastTime = currTime + timeToCall;

                return id;

            };

        }

        if( !window.cancelAnimationFrame ){

            window.cancelAnimationFrame = function( id ){
                clearTimeout( id );
            };

        }

    }() );

}


if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

    // Missing in IE9-11.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    Object.defineProperty( Function.prototype, 'name', {

        get: function () {

            return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

        }

    } );

}


////////////////
// Workarounds

if( typeof importScripts !== 'function' ){

    HTMLElement.prototype.getBoundingClientRect = function(){

        // workaround for ie11 behavior with disconnected dom nodes

        var _getBoundingClientRect = HTMLElement.prototype.getBoundingClientRect;

        return function(){
            try{
                return _getBoundingClientRect.apply( this, arguments );
            }catch( e ){
                return {
                    top: 0,
                    left: 0,
                    width: this.width,
                    height: this.height
                };
            }
        };

    }();

}


if( typeof importScripts !== 'function' && WebGLRenderingContext ){

    // wrap WebGL debug function used by three.js and
    // ignore calls to them when the debug flag is not set

    WebGLRenderingContext.prototype.getShaderParameter = function(){

        var _getShaderParameter = WebGLRenderingContext.prototype.getShaderParameter;

        return function(){

            if( NGL.debug ){

                return _getShaderParameter.apply( this, arguments );

            }else{

                return true;

            }

        }

    }();

    WebGLRenderingContext.prototype.getShaderInfoLog = function(){

        var _getShaderInfoLog = WebGLRenderingContext.prototype.getShaderInfoLog;

        return function(){

            if( NGL.debug ){

                return _getShaderInfoLog.apply( this, arguments );

            }else{

                return '';

            }

        }

    }();

    WebGLRenderingContext.prototype.getProgramParameter = function(){

        var _getProgramParameter = WebGLRenderingContext.prototype.getProgramParameter;

        return function( program, pname ){

            if( NGL.debug || pname !== WebGLRenderingContext.prototype.LINK_STATUS ){

                return _getProgramParameter.apply( this, arguments );

            }else{

                return true;

            }

        }

    }();

    WebGLRenderingContext.prototype.getProgramInfoLog = function(){

        var _getProgramInfoLog = WebGLRenderingContext.prototype.getProgramInfoLog;

        return function(){

            if( NGL.debug ){

                return _getProgramInfoLog.apply( this, arguments );

            }else{

                return '';

            }

        }

    }();

}

// File:js/ngl/core.js

/**
 * @file Core
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


////////
// NGL

var NGL = {

    REVISION: '0.7dev',
    EPS: 0.0000001,
    disableImpostor: false,
    useWorker: true,
    indexUint16: false,
    debug: false,
    develop: (
        self.location.pathname.indexOf( "core.js" ) !== -1 ||
        self.location.pathname.indexOf( "dev.html" ) !== -1
    ),
    mainScriptFilePath: "../js/build/ngl.full.min.js",
    cssDirectory: "../css/",
    assetsDirectory: "../"

};


// set default log handlers
NGL.log = Function.prototype.bind.call( console.log, console );
NGL.info = Function.prototype.bind.call( console.info, console );
NGL.warn = Function.prototype.bind.call( console.warn, console );
NGL.error = Function.prototype.bind.call( console.error, console );
NGL.time = Function.prototype.bind.call( console.time, console );
NGL.timeEnd = Function.prototype.bind.call( console.timeEnd, console );


NGL.LeftMouseButton = 1;
NGL.MiddleMouseButton = 2;
NGL.RightMouseButton = 3;


if( typeof importScripts === 'function' ){

    if( NGL.develop ){

        importScripts(

            "../three/three.js",
            "../three/Detector.js",
            "../three/TypedArrayUtils.js",
            "../three/controls/TrackballControls.js",
            "../three/loaders/OBJLoader.js",
            "../three/loaders/PLYLoader.js",

            "../lib/async.js",
            "../lib/promise.min.js",
            "../lib/sprintf.min.js",
            "../lib/jszip.min.js",
            "../lib/pako.min.js",
            "../lib/lzma.min.js",
            "../lib/bzip2.min.js",
            "../lib/chroma.min.js",
            "../lib/svd.js",
            "../lib/signals.min.js",

            "../ngl/shims.js",
            // "../ngl/core.js",
            "../ngl/worker.js",
            "../ngl/utils.js",
            "../ngl/symmetry.js",
            "../ngl/alignment.js",
            "../ngl/geometry.js",
            "../ngl/selection.js",
            "../ngl/superposition.js",
            "../ngl/structure.js",
            "../ngl/trajectory.js",
            "../ngl/surface.js",
            "../ngl/script.js",
            "../ngl/streamer.js",
            "../ngl/parser.js",
            "../ngl/writer.js",
            "../ngl/loader.js",
            "../ngl/viewer.js",
            "../ngl/buffer.js",
            "../ngl/representation.js",
            "../ngl/stage.js"

        );

    }

}


// Registry

NGL.PluginRegistry = {

    dict: {},

    add: function( name, path ){
        this.dict[ name ] = path;
    },

    get: function( name ){
        if( name in this.dict ){
            return this.dict[ name ];
        }else{
            throw "NGL.PluginRegistry '" + name + "' not defined";
        }
    },

    get names(){
        return Object.keys( this.dict );
    },

    get count(){
        return this.names.length;
    },

    load: function( name, stage ){
        var path = this.get( name );
        stage.loadFile( path, { name: name + " plugin" } );
    }

};


NGL.ExampleRegistry = {

    dict: {},

    add: function( name, fn ){
        this.dict[ name ] = fn;
    },

    addDict: function( dict ){
        Object.keys( dict ).forEach( function( name ){
            this.add( name, dict[ name ] );
        }.bind( this ) );
    },

    get: function( name ){
        return this.dict[ name ];
    },

    get names(){
        return Object.keys( this.dict );
    },

    get count(){
        return this.names.length;
    },

    load: function( name, stage ){
        var fn = this.get( name );
        if( typeof fn === "function" ){
            fn( stage );
        }else{
            NGL.warn( "NGL.ExampleRegistry.load not available:", name );
        }
    }

};

// File:js/ngl/worker.js

/**
 * @file Worker
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


// Worker

NGL.WorkerRegistry = {

    activeWorkerCount: 0,

    funcDict: {},

    add: function( name, func ){

        NGL.WorkerRegistry.funcDict[ name ] = func;

    },

};


NGL.Worker = function( name ){

    var pending = 0;
    var postCount = 0;
    var onmessageDict = {};
    var onerrorDict = {};

    var worker = new Worker( NGL.mainScriptFilePath );

    NGL.WorkerRegistry.activeWorkerCount += 1;

    worker.onmessage = function( event ){

        pending -= 1;
        var postId = event.data.__postId;

        NGL.timeEnd( "NGL.Worker.postMessage " + name + " #" + postId );

        if( onmessageDict[ postId ] ){
            onmessageDict[ postId ].call( worker, event );
        }else{
            // NGL.debug( "No onmessage", postId, name );
        }

        delete onmessageDict[ postId ];
        delete onerrorDict[ postId ];

    };

    worker.onerror = function( event ){

        pending -= 1;
        var postId = event.data.__postId;

        if( onerrorDict[ postId ] ){
            onerrorDict[ postId ].call( worker, event );
        }else{
            NGL.error( "NGL.Worker.onerror", postId, name, event );
        }

        delete onmessageDict[ postId ];
        delete onerrorDict[ postId ];

    };

    // API

    this.name = name;

    this.post = function( aMessage, transferList, onmessage, onerror ){

        onmessageDict[ postCount ] = onmessage;
        onerrorDict[ postCount ] = onerror;

        aMessage = aMessage || {};
        aMessage.__name = name;
        aMessage.__postId = postCount;

        NGL.time( "NGL.Worker.postMessage " + name + " #" + postCount );

        try{
            worker.postMessage.call( worker, aMessage, transferList );
        }catch( error ){
            NGL.error( "NGL.worker.post:", error );
            worker.postMessage.call( worker, aMessage );
        }

        pending += 1;
        postCount += 1;

        return this;

    };

    this.terminate = function(){

        if( worker ){
            worker.terminate();
            NGL.WorkerRegistry.activeWorkerCount -= 1;
        }else{
            console.log( "no worker to terminate" );
        }

    };

    Object.defineProperties( this, {
        postCount: {
            get: function(){ return postCount; }
        },
        pending: {
            get: function(){ return pending; }
        }
    } );

};

NGL.Worker.prototype.constructor = NGL.Worker;


NGL.WorkerPool = function( name, maxCount ){

    maxCount = Math.min( 8, maxCount || 2 );

    var pool = [];
    var count = 0;

    // API

    this.name = name;

    this.maxCount = maxCount;

    this.post = function( aMessage, transferList, onmessage, onerror ){

        var worker = this.getNextWorker();
        worker.post( aMessage, transferList, onmessage, onerror );

        return this;

    };

    this.terminate = function(){

        pool.forEach( function( worker ){
            worker.terminate();
        } );

    };

    this.getNextWorker = function(){

        var nextWorker;
        var minPending = Infinity;

        for( var i = 0; i < maxCount; ++i ){

            if( i >= count ){

                nextWorker = new NGL.Worker( name );
                pool.push( nextWorker );
                count += 1;
                break;

            }

            var worker = pool[ i ];

            if( worker.pending === 0 ){

                minPending = worker.pending;
                nextWorker = worker;
                break;

            }else if( worker.pending < minPending ){

                minPending = worker.pending;
                nextWorker = worker;

            }

        }

        return nextWorker;

    };

    Object.defineProperties( this, {
        count: {
            get: function(){ return count; }
        }
    } );

};

NGL.WorkerPool.prototype.constructor = NGL.WorkerPool;


if( typeof importScripts === 'function' ){

    self.onmessage = function( e ){

        var name = e.data.__name;
        var postId = e.data.__postId;

        if( name === undefined ){

            NGL.error( "message __name undefined" );

        }else if( NGL.WorkerRegistry.funcDict[ name ] === undefined ){

            NGL.error( "funcDict[ __name ] undefined", name );

        }else{

            var callback = function( aMessage, transferList ){

                aMessage = aMessage || {};
                if( postId !== undefined ) aMessage.__postId = postId;

                try{
                    self.postMessage( aMessage, transferList );
                }catch( error ){
                    NGL.error( "self.postMessage:", error );
                    self.postMessage( aMessage );
                }

            };

            NGL.WorkerRegistry.funcDict[ name ]( e, callback );

        }

    }

}

// File:js/ngl/utils.js

/**
 * @file Utils
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


NGL.browser = function(){

    var ua = navigator.userAgent;

    if ( /Arora/i.test( ua ) ) {

        return 'Arora';

    } else if ( /Opera|OPR/.test( ua ) ) {

        return 'Opera';

    } else if ( /Chrome/i.test( ua ) ) {

        return 'Chrome';

    } else if ( /Epiphany/i.test( ua ) ) {

        return 'Epiphany';

    } else if ( /Firefox/i.test( ua ) ) {

        return 'Firefox';

    } else if ( /Mobile(\/.*)? Safari/i.test( ua ) ) {

        return 'Mobile Safari';

    } else if ( /MSIE/i.test( ua ) ) {

        return 'Internet Explorer';

    } else if ( /Midori/i.test( ua ) ) {

        return 'Midori';

    } else if ( /Safari/i.test( ua ) ) {

        return 'Safari';

    }

    return false;

}();


NGL.GET = function( id ){

    var a = new RegExp( id + "=([^&#=]*)" );
    var m = a.exec( window.location.search );

    if( m ){
        return decodeURIComponent( m[1] );
    }else{
        return undefined;
    }

};


NGL.getAbsolutePath = function( relativePath ){

    var loc = window.location;
    var pn = loc.pathname;
    var basePath = pn.substring( 0, pn.lastIndexOf("/") + 1 );

    return loc.origin + basePath + relativePath;

};


NGL.createObject = function( prototype, properties ){

    var object = Object.create( prototype );

    for( var key in properties ) {

        if ( properties.hasOwnProperty( key ) ) {

            object[ key ] = properties[ key ];

        }

    }

    return object;

};


NGL.deepCopy = function( src ){

    if( typeof src !== "object" ){
        return src;
    }

    var dst = Array.isArray( src ) ? [] : {};

    for( var key in src ){
        dst[ key ] = NGL.deepCopy( src[ key ] );
    }

    return dst;

}


NGL.download = function( data, downloadName ){

    if( !data ){
        NGL.warn( "NGL.download: no data given." );
        return;
    }

    downloadName = downloadName || "download";

    var a = document.createElement( 'a' );
    a.style.display = "hidden";
    document.body.appendChild( a );
    if( data instanceof Blob ){
        a.href = URL.createObjectURL( data );
    }else{
        a.href = data;
    }
    a.download = downloadName;
    a.target = "_blank";
    a.click();

    document.body.removeChild( a );
    if( data instanceof Blob ){
        URL.revokeObjectURL( data );
    }

};


NGL.submit = function( url, data, callback, onerror ){

    if( data instanceof FormData ){

        var xhr = new XMLHttpRequest();
        xhr.open( "POST", url );

        xhr.addEventListener( 'load', function ( event ) {

            if ( xhr.status === 200 || xhr.status === 304 ) {

                callback( xhr.response );

            } else {

                if( typeof onerror === "function" ){

                    onerror( xhr.status );

                }

            }

        }, false );

        xhr.send( data );

    }else{

        NGL.warn( "NGL.submit: type not supported.", data  );

    }

};


NGL.open = function( callback, extensionList ){

    extensionList = extensionList || [ "*" ];

    var fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.multiple = true;
    fileInput.style.display = "hidden";
    document.body.appendChild( fileInput );
    fileInput.accept = "." + extensionList.join( ",." );
    fileInput.addEventListener( 'change', function( e ){

        callback( e.target.files );

    }, false );

    fileInput.click();

};


NGL.unicodeHelper = function(){

    var replace_map = {
        "{alpha}": "\u03B1",
        "{beta}": "\u03B2",
        "{gamma}": "\u03B3",
        "{dot}": "\u00B7",
        "{bullet}": "\u2022",
    }

    var keys = Object.keys( replace_map ).join('|');

    var rg = new RegExp( '(' + keys + ')', 'gi' );

    return function( str ){

        return str.replace(
            rg, function( s, p1, p2, offset, sx ){
                return replace_map[ String( s ) ];
            }
        );

    };

}();


NGL.getFileInfo = function( file ){

    var compressedExtList = [ "gz", "zip", "lzma", "bz2" ];

    var path, compressed, protocol;

    if( file instanceof File || file instanceof Blob ){
        path = file.name || "";
    }else{
        path = file
    }

    var name = path.replace( /^.*[\\\/]/, '' );
    var base = name.substring( 0, name.lastIndexOf( '.' ) );

    var pathSplit = path.split( '.' );
    var ext = pathSplit.length > 1 ? pathSplit.pop().toLowerCase() : "";

    var protocolMatch = path.match( /^(.+):\/\/(.+)$/ );
    if( protocolMatch ){
        protocol = protocolMatch[ 1 ].toLowerCase();
        path = protocolMatch[ 2 ];
    }

    var dir = path.substring( 0, path.lastIndexOf( '/' ) + 1 );

    if( compressedExtList.indexOf( ext ) !== -1 ){

        compressed = ext;

        var n = path.length - ext.length - 1;
        ext = path.substr( 0, n ).split( '.' ).pop().toLowerCase();

        var m = base.length - ext.length - 1;
        base = base.substr( 0, m );

    }else{

        compressed = false;

    }

    return {
        "path": path,
        "name": name,
        "ext": ext,
        "base": base,
        "dir": dir,
        "compressed": compressed,
        "protocol": protocol,
        "src": file
    };

};


NGL.fromJSON = function( input ){

    return new NGL[ input.metadata.type ]().fromJSON( input );

};


NGL.processArray = function( array, fn, callback, chunkSize ){

    var n = array.length;

    if( typeof importScripts === 'function' ){

        // no chunking required when inside a web worker
        fn( 0, n, array );
        callback();

    }else{

        chunkSize = chunkSize !== undefined ? chunkSize : 10000;

        var _i = 0;
        var _step = chunkSize;
        var _n = Math.min( _step, n );

        async.until(

            function(){

                return _i >= n;

            },

            function( wcallback ){

                requestAnimationFrame( function(){

                    // NGL.log( _i, _n, n );

                    var stop = fn( _i, _n, array );

                    if( stop ){

                        _i = n;

                    }else{

                        _i += _step;
                        _n = Math.min( _n + _step, n );

                    }

                    wcallback();

                } );

            },

            callback

        );

    }

};


NGL.throttle = function( func, wait, options ){

    // from http://underscorejs.org/docs/underscore.html

    var context, args, result;
    var timeout = null;
    var previous = 0;

    if( !options ) options = {};

    var later = function(){
        previous = options.leading === false ? 0 : Date.now();
        timeout = null;
        result = func.apply( context, args );
        if( !timeout ) context = args = null;
    };

    return function(){

        var now = Date.now();
        if( !previous && options.leading === false ) previous = now;
        var remaining = wait - ( now - previous );
        context = this;
        args = arguments;
        if( remaining <= 0 || remaining > wait ){
            if( timeout ){
                clearTimeout( timeout );
                timeout = null;
            }
            previous = now;
            result = func.apply(context, args);
            if( !timeout ) context = args = null;
        }else if( !timeout && options.trailing !== false ){
            timeout = setTimeout( later, remaining );
        }

        return result;

    };

};


NGL.binarySearchIndexOf = function(){
    function _compareFunction( elm1, elm2 ){
        if( elm1 < elm2 ) return -1;
        if( elm1 > elm2 ) return 1;
        return 0;
    }
    return function( array, element, compareFunction ){
        var low = 0;
        var high = array.length - 1;
        if( !compareFunction ) compareFunction = _compareFunction;
        while( low <= high ){
            var i = ( low + high ) >> 1;
            var cmp = compareFunction( element, array[ i ] );
            if( cmp > 0 ){
                low = i + 1;
            }else if( cmp < 0 ){
                high = i - 1;
            } else {
                return i;
            }
        }
        return -low - 1;
    }
}();


// String/arraybuffer conversion

NGL.Uint8ToString = function( u8a ){

    // from http://stackoverflow.com/a/12713326/1435042

    var CHUNK_SZ = 0x1000;
    var c = [];

    for( var i = 0; i < u8a.length; i += CHUNK_SZ ){

        c.push( String.fromCharCode.apply(

            null, u8a.subarray( i, i + CHUNK_SZ )

        ) );

    }

    return c.join("");

};


NGL.Uint8ToLines = function( u8a, chunkSize, newline ){

    NGL.time( "NGL.Uint8ToLines" );

    chunkSize = chunkSize !== undefined ? chunkSize : 1024 * 1024 * 10;
    newline = newline !== undefined ? newline : "\n";

    var partialLine = "";
    var lines = [];

    for( var i = 0; i < u8a.length; i += chunkSize ){

        var str = NGL.Uint8ToString( u8a.subarray( i, i + chunkSize ) );
        var idx = str.lastIndexOf( newline );

        if( idx === -1 ){

            partialLine += str;

        }else{

            var str2 = partialLine + str.substr( 0, idx );
            lines = lines.concat( str2.split( newline ) );

            if( idx === str.length - newline.length ){

                partialLine = "";

            }else{

                partialLine = str.substr( idx + newline.length );

            }

        }

    }

    if( partialLine !== "" ){

        lines.push( partialLine );

    }

    NGL.timeEnd( "NGL.Uint8ToLines" );

    return lines;

};


// Decompress

NGL.decompress = function( data, file, asBinary, callback ){

    var binData, decompressedData;
    var ext = NGL.getFileInfo( file ).compressed;

    NGL.time( "NGL.decompress " + ext );

    if( data instanceof ArrayBuffer ){

        data = new Uint8Array( data );

    }

    if( ext === "gz" ){

        binData = pako.ungzip( data );

    }else if( ext === "zip" ){

        var zip = new JSZip( data );
        var name = Object.keys( zip.files )[ 0 ];
        binData = zip.files[ name ].asUint8Array();

    }else if( ext === "lzma" ){

        var inStream = {
            data: data,
            offset: 0,
            readByte: function(){
                return this.data[ this.offset++ ];
            }
        };

        var outStream = {
            data: [ /* Uncompressed data will be putted here */ ],
            offset: 0,
            writeByte: function( value ){
                this.data[ this.offset++ ] = value;
            }
        };

        LZMA.decompressFile( inStream, outStream );
        binData = new Uint8Array( outStream.data );

    }else if( ext === "bz2" ){

        // FIXME need to get binData
        var bitstream = bzip2.array( data );
        decompressedData = bzip2.simple( bitstream )

    }else{

        NGL.warn( "no decompression method available for '" + ext + "'" );
        decompressedData = data;

    }

    if( !asBinary && decompressedData === undefined ){

        decompressedData = NGL.Uint8ToString( binData );

    }

    NGL.timeEnd( "NGL.decompress " + ext );

    var returnData = asBinary ? binData : decompressedData;

    if( typeof callback === "function" ){

        callback( returnData );

    }

    return returnData;

};


NGL.WorkerRegistry.add( "decompress", function( e, callback ){

    var d = e.data;

    var value = NGL.decompress( d.data, d.file, d.asBinary );
    var transferable = [];

    if( d.asBinary ){
        transferable.push( value.buffer );
    }

    callback( value, transferable );

} );


NGL.decompressWorker = function( data, file, asBinary, callback ){

    if( NGL.useWorker && typeof Worker !== "undefined" &&
        typeof importScripts !== 'function'
    ){

        var worker = new NGL.Worker( "decompress" ).post(

            { data: data, file: file, asBinary: asBinary },

            [ data.buffer ? data.buffer : data ],

            function( e ){

                worker.terminate();
                callback( e.data );

            },

            function( e ){

                console.warn(
                    "NGL.decompressWorker error - trying without worker", e
                );
                worker.terminate();

                NGL.decompress( data, file, asBinary, callback );

            }

        );

    }else{

        NGL.decompress( data, file, asBinary, callback );

    }

};


// Counter

NGL.Counter = function(){

    var SIGNALS = signals;

    this.count = 0;

    this.signals = {

        countChanged: new SIGNALS.Signal(),

    }

};

NGL.Counter.prototype = {

    clear: function(){

        this.change( -this.count );

    },

    change: function( delta ){

        this.count += delta;
        this.signals.countChanged.dispatch( delta, this.count );

        if( this.count < 0 ){

            NGL.warn( "NGL.Counter.count below zero", this.count );

        }

    },

    increment: function(){

        this.change( 1 );

    },

    decrement: function(){

        this.change( -1 );

    },

    listen: function( counter ){

        // incorporate changes of another counter

        this.change( counter.count );

        counter.signals.countChanged.add( function( delta, count ){

            this.change( delta );

        }.bind( this ) );

    },

    onZeroOnce: function( callback, context ){

        if( this.count === 0 ){

            callback.call( context, 0, 0 );

        }else{

            var fn = function(){

                if( this.count === 0 ){

                    this.signals.countChanged.remove( fn, this );

                    callback.apply( context, arguments );

                }

            }

            this.signals.countChanged.add( fn, this );

        }

    },

    dispose: function(){

        this.clear();

    }

};

// File:js/ngl/symmetry.js

/**
 * @file Symmetry
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


NGL.Unitcell = function( a, b, c, alpha, beta, gamma, spacegroup, cartToFrac ){

    this.a = a || 1;
    this.b = b || 1;
    this.c = c || 1;

    this.alpha = alpha || 90;
    this.beta = beta || 90;
    this.gamma = gamma || 90;

    this.spacegroup = spacegroup || "P 1";

    //

    var alphaRad = THREE.Math.degToRad( this.alpha );
    var betaRad = THREE.Math.degToRad( this.beta );
    var gammaRad = THREE.Math.degToRad( this.gamma );
    var cosAlpha = Math.cos( alphaRad );
    var cosBeta = Math.cos( betaRad );
    var cosGamma = Math.cos( gammaRad );
    var sinAlpha = Math.sin( alphaRad );
    var sinBeta = Math.sin( betaRad );
    var sinGamma = Math.sin( gammaRad );

    this.volume = (
        this.a * this.b * this.c *
        Math.sqrt(
            1 - cosAlpha * cosAlpha - cosBeta * cosBeta - cosGamma * cosGamma +
            2.0 * cosAlpha * cosBeta * cosGamma
        )
    );

    //

    this.cartToFrac = cartToFrac;

    if( this.cartToFrac === undefined ){

        var cStar = ( this.a * this.b * sinGamma ) / this.volume;
        var cosAlphaStar = (
            ( cosBeta * cosGamma - cosAlpha ) /
            ( sinBeta * sinGamma )
        );

        this.cartToFrac = new THREE.Matrix4().set(
            this.a, 0, 0, 0,
            this.b * cosGamma, this.b * sinGamma, 0, 0,
            this.c * cosBeta, -this.c * sinBeta * cosAlphaStar, 1.0 / cStar, 0,
            0, 0, 0, 1
        );

    }

    this.fracToCart = new THREE.Matrix4().getInverse(
        this.cartToFrac
    );

};

NGL.Unitcell.prototype = {

    toJSON: function(){

        var output = {

            metadata: {
                version: 0.1,
                type: 'Unitcell',
                generator: 'UnitcellExporter'
            },

            a: this.a,
            b: this.b,
            c: this.c,

            alpha: this.alpha,
            beta: this.beta,
            gamma: this.gamma,

            spacegroup: this.spacegroup,
            volume: this.volume,

            cartToFrac: this.cartToFrac.toArray(),
            fracToCart: this.fracToCart.toArray(),

        }

        return output;

    },

    fromJSON: function( input ){

        this.a = input.a;
        this.b = input.b;
        this.c = input.c;

        this.alpha = input.alpha;
        this.beta = input.beta;
        this.gamma = input.gamma;

        this.spacegroup = input.spacegroup;
        this.volume = input.volume;

        this.cartToFrac.fromArray( input.cartToFrac );
        this.fracToCart.fromArray( input.fracToCart );

        return this;

    }

};


NGL.getSymmetryOperations = function( spacegroup ){

    var symopList = NGL.SymOp[ spacegroup ];

    var matrixDict = {};

    if( symopList === undefined ){

        console.warn(
            "NGL.getSymmetryOperations: spacegroup '" +
            spacegroup + "' not found in symop library"
        );
        return matrixDict;

    }

    var reInteger = /^[1-9]$/;

    symopList.forEach( function( symop ){

        var ls = symop.split( "," );

        var row = 0;
        var matrix = new THREE.Matrix4().set(
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 0,
            0, 0, 0, 1
        );
        var me = matrix.elements;

        matrixDict[ symop ] = matrix;

        // console.log( "symop", ls )

        ls.forEach( function( elm ){

            // console.log( "row", row );

            var negate = false;
            var denominator = false;

            for( var i = 0, n = elm.length; i < n; ++i ){

                var c = elm[ i ];

                if( c === "-" ){

                    negate = true;

                }else if( c === "+" ){

                    negate = false;

                }else if( c === "/" ){

                    denominator = true;

                }else if( c === "X" ){

                    me[ 0 + row ] = negate ? -1 : 1;

                }else if( c === "Y" ){

                    me[ 4 + row ] = negate ? -1 : 1;

                }else if( c === "Z" ){

                    me[ 8 + row ] = negate ? -1 : 1;

                }else if( reInteger.test( c ) ){

                    var integer = parseInt( c );

                    if( denominator ){

                        me[ 12 + row ] /= integer;

                    }else{

                        me[ 12 + row ] = integer;

                    }

                }else{

                    NGL.warn(
                        "NGL.getSymmetryOperations: unknown token " +
                        "'" + c + "'"
                    );

                }

                // console.log( "token", c )

            }

            row += 1;

        } );

        // console.log( "matrix", me )

    } );

    return matrixDict;

};

// from CCP4 symop.lib
NGL.SymOp = {
    "P 1": [
        "X,Y,Z"
    ],
    "P -1": [
        "X,Y,Z",
        "-X,-Y,-Z"
    ],
    "P 1 2 1": [
        "X,Y,Z",
        "-X,Y,-Z"
    ],
    "P 1 21 1": [
        "X,Y,Z",
        "-X,Y+1/2,-Z"
    ],
    "C 1 2 1": [
        "X,Y,Z",
        "-X,Y,-Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2+Y,-Z"
    ],
    "P 1 m 1": [
        "X,Y,Z",
        "X,-Y,Z"
    ],
    "P 1 c 1": [
        "X,Y,Z",
        "X,-Y,1/2+Z"
    ],
    "C 1 m 1": [
        "X,Y,Z",
        "X,-Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2+X,1/2-Y,Z"
    ],
    "C 1 c 1": [
        "X,Y,Z",
        "X,-Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "1/2+X,1/2-Y,1/2+Z"
    ],
    "P 1 2/m 1": [
        "X,Y,Z",
        "X,-Y,Z",
        "-X,Y,-Z",
        "-X,-Y,-Z"
    ],
    "P 1 21/m 1": [
        "X,Y,Z",
        "-X,1/2+Y,-Z",
        "-X,-Y,-Z",
        "X,1/2-Y,Z"
    ],
    "C 1 2/m 1": [
        "X,Y,Z",
        "X,-Y,Z",
        "-X,Y,-Z",
        "-X,-Y,-Z",
        "1/2+X,1/2+Y,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2-X,1/2-Y,-Z"
    ],
    "P 1 2/c 1": [
        "X,Y,Z",
        "-X,Y,1/2-Z",
        "-X,-Y,-Z",
        "X,-Y,1/2+Z"
    ],
    "P 1 21/c 1": [
        "X,Y,Z",
        "-X,-Y,-Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2+Z"
    ],
    "C 1 2/c 1": [
        "X,Y,Z",
        "-X,Y,1/2-Z",
        "-X,-Y,-Z",
        "X,-Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2-Y,1/2+Z"
    ],
    "P 2 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z"
    ],
    "P 2 2 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-X,Y,1/2-Z",
        "X,-Y,-Z"
    ],
    "P 21 21 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z"
    ],
    "P 21 21 21": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z"
    ],
    "C 2 2 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-X,Y,1/2-Z",
        "X,-Y,-Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z"
    ],
    "C 2 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z"
    ],
    "F 2 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z"
    ],
    "I 2 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,-Z",
        "-X,Y,-Z",
        "X+1/2,Y+1/2,Z+1/2",
        "-X+1/2,-Y+1/2,Z+1/2",
        "X+1/2,-Y+1/2,-Z+1/2",
        "-X+1/2,Y+1/2,-Z+1/2"
    ],
    "I 21 21 21": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,Y,-Z",
        "X,-Y,1/2-Z"
    ],
    "P m m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,Z",
        "-X,Y,Z"
    ],
    "P m c 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "X,-Y,1/2+Z",
        "-X,Y,Z"
    ],
    "P c c 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z"
    ],
    "P m a 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,-Y,Z",
        "1/2-X,Y,Z"
    ],
    "P c a 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "1/2+X,-Y,Z",
        "1/2-X,Y,1/2+Z"
    ],
    "P n c 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z"
    ],
    "P m n 21": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "1/2+X,-Y,1/2+Z",
        "-X,Y,Z"
    ],
    "P b a 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "P n a 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "P n n 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "C m m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "C m c 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "X,-Y,1/2+Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z"
    ],
    "C c c 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "A m m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z"
    ],
    "A b m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,1/2-Y,Z",
        "-X,1/2+Y,Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z"
    ],
    "A m a 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,-Y,Z",
        "1/2-X,Y,Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "A b a 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z"
    ],
    "F m m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "F d d 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/4+X,1/4-Y,1/4+Z",
        "1/4-X,1/4+Y,1/4+Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "1/4+X,3/4-Y,3/4+Z",
        "1/4-X,3/4+Y,3/4+Z",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "3/4+X,1/4-Y,3/4+Z",
        "3/4-X,1/4+Y,3/4+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "3/4+X,3/4-Y,1/4+Z",
        "3/4-X,3/4+Y,1/4+Z"
    ],
    "I m m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "I b a 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z"
    ],
    "I m a 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,-Y,Z",
        "1/2-X,Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z"
    ],
    "P 2/m 2/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z"
    ],
    "P 2/n 2/n 2/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "P 2/c 2/c 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z"
    ],
    "P 2/b 2/a 2/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "P 21/m 2/m 2/a": [
        "X,Y,Z",
        "1/2-X,-Y,Z",
        "-X,Y,-Z",
        "1/2+X,-Y,-Z",
        "-X,-Y,-Z",
        "1/2+X,Y,-Z",
        "X,-Y,Z",
        "1/2-X,Y,Z"
    ],
    "P 2/n 21/n 2/a": [
        "X,Y,Z",
        "1/2-X,-Y,Z",
        "1/2-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "-X,-Y,-Z",
        "1/2+X,Y,-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z"
    ],
    "P 2/m 2/n 21/a": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "-X,Y,Z"
    ],
    "P 21/c 2/c 2/a": [
        "X,Y,Z",
        "1/2-X,-Y,Z",
        "-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "-X,-Y,-Z",
        "1/2+X,Y,-Z",
        "X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z"
    ],
    "P 21/b 21/a 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "P 21/c 21/c 2/n": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "-X,-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,Y,1/2+Z"
    ],
    "P 2/b 21/c 21/m": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,Z"
    ],
    "P 21/n 21/n 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "P 21/m 21/m 2/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-X,Y+1/2,-Z",
        "X+1/2,1/2-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "X+1/2,Y+1/2,-Z",
        "X,-Y,Z",
        "-X,Y,Z"
    ],
    "P 21/b 2/c 21/n": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-X,Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "-X,-Y,-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "X,-Y,1/2+Z",
        "1/2-X,1/2+Y,Z"
    ],
    "P 21/b 21/c 21/a": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z"
    ],
    "P 21/n 21/m 21/a": [
        "X,Y,Z",
        "-X+1/2,-Y,Z+1/2",
        "-X,Y+1/2,-Z",
        "X+1/2,-Y+1/2,-Z+1/2",
        "-X,-Y,-Z",
        "X+1/2,Y,-Z+1/2",
        "X,-Y+1/2,Z",
        "-X+1/2,Y+1/2,Z+1/2"
    ],
    "C 2/m 2/c 21/m": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-X,Y,1/2-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,1/2-Z",
        "X,-Y,1/2+Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z"
    ],
    "C 2/m 2/c 21/a": [
        "X,Y,Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,1/2+Y,Z"
    ],
    "C 2/m 2/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "C 2/c 2/c 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "C 2/m 2/m 2/a": [
        "X,Y,Z",
        "-X,1/2-Y,Z",
        "-X,1/2+Y,-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,1/2+Y,-Z",
        "X,1/2-Y,Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,-Y,Z",
        "1/2-X,Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,Y,-Z",
        "1/2+X,-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "C 2/c 2/c 2/a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "-X,Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "-X,1/2-Y,1/2-Z",
        "1/2+X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "-X,-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "X,-Y,-Z",
        "1/2-X,-Y,1/2-Z",
        "X,1/2+Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z"
    ],
    "F 2/m 2/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "-X,1/2-Y,1/2-Z",
        "X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2-X,-Y,1/2-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z"
    ],
    "F 2/d 2/d 2/d": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "1/4-X,1/4-Y,1/4-Z",
        "1/4+X,1/4+Y,1/4-Z",
        "1/4+X,1/4-Y,1/4+Z",
        "1/4-X,1/4+Y,1/4+Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "1/4-X,3/4-Y,3/4-Z",
        "1/4+X,3/4+Y,3/4-Z",
        "1/4+X,3/4-Y,3/4+Z",
        "1/4-X,3/4+Y,3/4+Z",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "3/4-X,1/4-Y,3/4-Z",
        "3/4+X,1/4+Y,3/4-Z",
        "3/4+X,1/4-Y,3/4+Z",
        "3/4-X,1/4+Y,3/4+Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "3/4-X,3/4-Y,1/4-Z",
        "3/4+X,3/4+Y,1/4-Z",
        "3/4+X,3/4-Y,1/4+Z",
        "3/4-X,3/4+Y,1/4+Z"
    ],
    "I 2/m 2/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "I 2/b 2/a 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z"
    ],
    "I 21/b 21/c 21/a": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,Y,-Z",
        "X,-Y,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "X,1/2+Y,-Z",
        "1/2+X,-Y,Z",
        "-X,Y,1/2+Z"
    ],
    "I 21/m 21/m 21/a": [
        "X,Y,Z",
        "-X,1/2-Y,Z",
        "-X,1/2+Y,-Z",
        "X,-Y,-Z",
        "-X,-Y,-Z",
        "X,1/2+Y,-Z",
        "X,1/2-Y,Z",
        "-X,Y,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z"
    ],
    "P 4": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z"
    ],
    "P 41": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-Y,X,1/4+Z",
        "Y,-X,3/4+Z"
    ],
    "P 42": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z"
    ],
    "P 43": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-Y,X,3/4+Z",
        "Y,-X,1/4+Z"
    ],
    "I 4": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z"
    ],
    "I 41": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z"
    ],
    "P -4": [
        "X,Y,Z",
        "-X,-Y,Z",
        "Y,-X,-Z",
        "-Y,X,-Z"
    ],
    "I -4": [
        "X,Y,Z",
        "-X,-Y,Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z"
    ],
    "P 4/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z"
    ],
    "P 42/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,1/2-Z",
        "-Y,X,1/2-Z"
    ],
    "P 4/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,Z",
        "1/2+Y,1/2-X,Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z"
    ],
    "P 42/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "Y,-X,-Z",
        "-Y,X,-Z"
    ],
    "I 4/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z"
    ],
    "I 41/a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "-X,1/2-Y,1/4-Z",
        "1/2+X,Y,3/4-Z",
        "Y,-X,-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z",
        "1/2-X,-Y,3/4-Z",
        "X,1/2+Y,1/4-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "-Y,X,-Z"
    ],
    "P 4 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z"
    ],
    "P 4 21 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,Z",
        "1/2+Y,1/2-X,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z"
    ],
    "P 41 2 2": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-Y,X,1/4+Z",
        "Y,-X,3/4+Z",
        "-X,Y,-Z",
        "X,-Y,1/2-Z",
        "Y,X,3/4-Z",
        "-Y,-X,1/4-Z"
    ],
    "P 41 21 2": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "1/2-Y,1/2+X,1/4+Z",
        "1/2+Y,1/2-X,3/4+Z",
        "1/2-X,1/2+Y,1/4-Z",
        "1/2+X,1/2-Y,3/4-Z",
        "Y,X,-Z",
        "-Y,-X,1/2-Z"
    ],
    "P 42 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z"
    ],
    "P 42 21 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "Y,X,-Z",
        "-Y,-X,-Z"
    ],
    "P 43 2 2": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-Y,X,3/4+Z",
        "Y,-X,1/4+Z",
        "-X,Y,-Z",
        "X,-Y,1/2-Z",
        "Y,X,1/4-Z",
        "-Y,-X,3/4-Z"
    ],
    "P 43 21 2": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "1/2-Y,1/2+X,3/4+Z",
        "1/2+Y,1/2-X,1/4+Z",
        "1/2-X,1/2+Y,3/4-Z",
        "1/2+X,1/2-Y,1/4-Z",
        "Y,X,-Z",
        "-Y,-X,1/2-Z"
    ],
    "I 4 2 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z"
    ],
    "I 41 2 2": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "1/2-X,Y,3/4-Z",
        "X,1/2-Y,1/4-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "-Y,-X,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z",
        "-X,1/2+Y,1/4-Z",
        "1/2+X,-Y,3/4-Z",
        "Y,X,-Z",
        "1/2-Y,1/2-X,1/2-Z"
    ],
    "P 4 m m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 4 b m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "P 42 c m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 42 n m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 4 c c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z"
    ],
    "P 4 n c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P 42 m c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z"
    ],
    "P 42 b c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "I 4 m m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Y,-X,Z",
        "Y,X,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "I 4 c m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "I 41 m d": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "X,-Y,Z",
        "1/2-X,1/2+Y,1/2+Z",
        "-Y,1/2-X,1/4+Z",
        "1/2+Y,X,3/4+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z",
        "1/2+X,1/2-Y,1/2+Z",
        "-X,Y,Z",
        "1/2-Y,-X,3/4+Z",
        "Y,1/2+X,1/4+Z"
    ],
    "I 41 c d": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "X,-Y,1/2+Z",
        "1/2-X,1/2+Y,Z",
        "-Y,1/2-X,3/4+Z",
        "1/2+Y,X,1/4+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z",
        "1/2+X,1/2-Y,Z",
        "-X,Y,1/2+Z",
        "1/2-Y,-X,1/4+Z",
        "Y,1/2+X,3/4+Z"
    ],
    "P -4 2 m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P -4 2 c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z"
    ],
    "P -4 21 m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "P -4 21 c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P -4 m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "Y,X,-Z",
        "-Y,-X,-Z"
    ],
    "P -4 c 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z"
    ],
    "P -4 b 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z"
    ],
    "P -4 n 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z"
    ],
    "I -4 m 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z"
    ],
    "I -4 c 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z"
    ],
    "I -4 2 m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "-Y,-X,Z",
        "Y,X,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "I -4 2 d": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "1/2-X,Y,3/4-Z",
        "1/2+X,-Y,3/4-Z",
        "1/2-Y,-X,3/4+Z",
        "1/2+Y,X,3/4+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "-X,1/2+Y,1/4-Z",
        "X,1/2-Y,1/4-Z",
        "-Y,1/2-X,1/4+Z",
        "Y,1/2+X,1/4+Z"
    ],
    "P 4/m 2/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 4/m 2/c 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z"
    ],
    "P 4/n 2/b 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+Y,1/2-X,-Z",
        "1/2-Y,1/2+X,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "P 4/n 2/n 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P 4/m 21/b 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "P 4/m 21/n 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P 4/n 21/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,Z",
        "1/2+Y,1/2-X,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "P 4/n 2/c 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,Z",
        "1/2+Y,1/2-X,Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P 42/m 2/m 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,1/2-Z",
        "-Y,X,1/2-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z"
    ],
    "P 42/m 2/c 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,1/2-Z",
        "-Y,X,1/2-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 42/n 2/b 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z"
    ],
    "P 42/n 2/n 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 42/m 21/b 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,1/2+Z",
        "Y,-X,1/2+Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,1/2-Z",
        "-Y,X,1/2-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P 42/m 21/n 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,X+1/2,Z+1/2",
        "Y+1/2,1/2-X,Z+1/2",
        "1/2-X,Y+1/2,1/2-Z",
        "X+1/2,1/2-Y,1/2-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y+1/2,1/2-X,1/2-Z",
        "1/2-Y,X+1/2,1/2-Z",
        "X+1/2,1/2-Y,Z+1/2",
        "1/2-X,Y+1/2,Z+1/2",
        "-Y,-X,Z",
        "Y,X,Z"
    ],
    "P 42/n 21/m 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "P 42/n 21/c 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "I 4/m 2/m 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Y,-X,Z",
        "Y,X,Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z"
    ],
    "I 4/m 2/c 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-Y,X,Z",
        "Y,-X,Z",
        "-X,Y,1/2-Z",
        "X,-Y,1/2-Z",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,-Y,1/2+Z",
        "-X,Y,1/2+Z",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z"
    ],
    "I 41/a 2/m 2/d": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "1/2-X,Y,3/4-Z",
        "X,1/2-Y,1/4-Z",
        "1/2+Y,1/2+X,1/2-Z",
        "-Y,-X,-Z",
        "-X,1/2-Y,1/4-Z",
        "1/2+X,Y,3/4-Z",
        "Y,-X,-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "-X,Y,Z",
        "1/2-Y,-X,3/4+Z",
        "Y,1/2+X,1/4+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z",
        "-X,1/2+Y,1/4-Z",
        "1/2+X,-Y,3/4-Z",
        "Y,X,-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2-X,-Y,3/4-Z",
        "X,1/2+Y,1/4-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "-Y,X,-Z",
        "X,-Y,Z",
        "1/2-X,1/2+Y,1/2+Z",
        "-Y,1/2-X,1/4+Z",
        "1/2+Y,X,3/4+Z"
    ],
    "I 41/a 2/c 2/d": [
        "X,Y,Z",
        "1/2-X,1/2-Y,1/2+Z",
        "-Y,1/2+X,1/4+Z",
        "1/2+Y,-X,3/4+Z",
        "1/2-X,Y,1/4-Z",
        "X,1/2-Y,3/4-Z",
        "1/2+Y,1/2+X,-Z",
        "-Y,-X,1/2-Z",
        "-X,1/2-Y,1/4-Z",
        "1/2+X,Y,3/4-Z",
        "Y,-X,-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2-Y,Z",
        "-X,Y,1/2+Z",
        "1/2-Y,-X,1/4+Z",
        "Y,1/2+X,3/4+Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-Y,X,3/4+Z",
        "Y,1/2-X,1/4+Z",
        "-X,1/2+Y,3/4-Z",
        "1/2+X,-Y,1/4-Z",
        "Y,X,1/2-Z",
        "1/2-Y,1/2-X,-Z",
        "1/2-X,-Y,3/4-Z",
        "X,1/2+Y,1/4-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "-Y,X,-Z",
        "X,-Y,1/2+Z",
        "1/2-X,1/2+Y,Z",
        "-Y,1/2-X,3/4+Z",
        "1/2+Y,X,1/4+Z"
    ],
    "P 3": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z"
    ],
    "P 31": [
        "X,Y,Z",
        "-Y,X-Y,Z+1/3",
        "Y-X,-X,Z+2/3"
    ],
    "P 32": [
        "X,Y,Z",
        "-Y,X-Y,Z+2/3",
        "Y-X,-X,Z+1/3"
    ],
    "H 3": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "X+2/3,Y+1/3,Z+1/3",
        "-Y+2/3,X-Y+1/3,Z+1/3",
        "Y-X+2/3,-X+1/3,Z+1/3",
        "X+1/3,Y+2/3,Z+2/3",
        "-Y+1/3,X-Y+2/3,Z+2/3",
        "Y-X+1/3,-X+2/3,Z+2/3"
    ],
    "R 3": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X"
    ],
    "P -3": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z"
    ],
    "H -3": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "2/3+X,1/3+Y,1/3+Z",
        "2/3-Y,1/3+X-Y,1/3+Z",
        "2/3+Y-X,1/3-X,1/3+Z",
        "2/3-X,1/3-Y,1/3-Z",
        "2/3+Y,1/3+Y-X,1/3-Z",
        "2/3+X-Y,1/3+X,1/3-Z",
        "1/3+X,2/3+Y,2/3+Z",
        "1/3-Y,2/3+X-Y,2/3+Z",
        "1/3+Y-X,2/3-X,2/3+Z",
        "1/3-X,2/3-Y,2/3-Z",
        "1/3+Y,2/3+Y-X,2/3-Z",
        "1/3+X-Y,2/3+X,2/3-Z"
    ],
    "R -3": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X",
        "-X,-Y,-Z",
        "-Z,-X,-Y",
        "-Y,-Z,-X"
    ],
    "P 3 1 2": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z"
    ],
    "P 3 2 1": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z"
    ],
    "P 31 1 2": [
        "X,Y,Z",
        "-Y,X-Y,1/3+Z",
        "Y-X,-X,2/3+Z",
        "-Y,-X,2/3-Z",
        "Y-X,Y,1/3-Z",
        "X,X-Y,-Z"
    ],
    "P 31 2 1": [
        "X,Y,Z",
        "-Y,X-Y,Z+1/3",
        "Y-X,-X,Z+2/3",
        "Y,X,-Z",
        "X-Y,-Y,2/3-Z",
        "-X,Y-X,1/3-Z"
    ],
    "P 32 1 2": [
        "X,Y,Z",
        "-Y,X-Y,2/3+Z",
        "Y-X,-X,1/3+Z",
        "-Y,-X,1/3-Z",
        "Y-X,Y,2/3-Z",
        "X,X-Y,-Z"
    ],
    "P 32 2 1": [
        "X,Y,Z",
        "-Y,X-Y,Z+2/3",
        "Y-X,-X,Z+1/3",
        "Y,X,-Z",
        "X-Y,-Y,1/3-Z",
        "-X,Y-X,2/3-Z"
    ],
    "H 3 2": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "2/3+X,1/3+Y,1/3+Z",
        "2/3-Y,1/3+X-Y,1/3+Z",
        "2/3+Y-X,1/3-X,1/3+Z",
        "2/3+Y,1/3+X,1/3-Z",
        "2/3+X-Y,1/3-Y,1/3-Z",
        "2/3-X,1/3+Y-X,1/3-Z",
        "1/3+X,2/3+Y,2/3+Z",
        "1/3-Y,2/3+X-Y,2/3+Z",
        "1/3+Y-X,2/3-X,2/3+Z",
        "1/3+Y,2/3+X,2/3-Z",
        "1/3+X-Y,2/3-Y,2/3-Z",
        "1/3-X,2/3+Y-X,2/3-Z"
    ],
    "R 3 2": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X",
        "-Y,-X,-Z",
        "-X,-Z,-Y",
        "-Z,-Y,-X"
    ],
    "P 3 m 1": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z"
    ],
    "P 3 1 m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P 3 c 1": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z"
    ],
    "P 3 1 c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "H 3 m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "2/3+X,1/3+Y,1/3+Z",
        "2/3-Y,1/3+X-Y,1/3+Z",
        "2/3+Y-X,1/3-X,1/3+Z",
        "2/3-Y,1/3-X,1/3+Z",
        "2/3+Y-X,1/3+Y,1/3+Z",
        "2/3+X,1/3+X-Y,1/3+Z",
        "1/3+X,2/3+Y,2/3+Z",
        "1/3-Y,2/3+X-Y,2/3+Z",
        "1/3+Y-X,2/3-X,2/3+Z",
        "1/3-Y,2/3-X,2/3+Z",
        "1/3+Y-X,2/3+Y,2/3+Z",
        "1/3+X,2/3+X-Y,2/3+Z"
    ],
    "R 3 m": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X",
        "Y,X,Z",
        "X,Z,Y",
        "Z,Y,X"
    ],
    "H 3 c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "2/3+X,1/3+Y,1/3+Z",
        "2/3-Y,1/3+X-Y,1/3+Z",
        "2/3+Y-X,1/3-X,1/3+Z",
        "2/3-Y,1/3-X,5/6+Z",
        "2/3+Y-X,1/3+Y,5/6+Z",
        "2/3+X,1/3+X-Y,5/6+Z",
        "1/3+X,2/3+Y,2/3+Z",
        "1/3-Y,2/3+X-Y,2/3+Z",
        "1/3+Y-X,2/3-X,2/3+Z",
        "1/3-Y,2/3-X,1/6+Z",
        "1/3+Y-X,2/3+Y,1/6+Z",
        "1/3+X,2/3+X-Y,1/6+Z"
    ],
    "R 3 c": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X",
        "Y+1/2,X+1/2,Z+1/2",
        "X+1/2,Z+1/2,Y+1/2",
        "Z+1/2,Y+1/2,X+1/2"
    ],
    "P -3 1 2/m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P -3 1 2/c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-Y,-X,1/2-Z",
        "Y-X,Y,1/2-Z",
        "X,X-Y,1/2-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "P -3 2/m 1": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z"
    ],
    "P -3 2/c 1": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,1/2-Z",
        "X-Y,-Y,1/2-Z",
        "-X,Y-X,1/2-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z"
    ],
    "H -3 2/m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "2/3+X,1/3+Y,1/3+Z",
        "2/3-Y,1/3+X-Y,1/3+Z",
        "2/3+Y-X,1/3-X,1/3+Z",
        "2/3+Y,1/3+X,1/3-Z",
        "2/3+X-Y,1/3-Y,1/3-Z",
        "2/3-X,1/3+Y-X,1/3-Z",
        "2/3-X,1/3-Y,1/3-Z",
        "2/3+Y,1/3+Y-X,1/3-Z",
        "2/3+X-Y,1/3+X,1/3-Z",
        "2/3-Y,1/3-X,1/3+Z",
        "2/3+Y-X,1/3+Y,1/3+Z",
        "2/3+X,1/3+X-Y,1/3+Z",
        "1/3+X,2/3+Y,2/3+Z",
        "1/3-Y,2/3+X-Y,2/3+Z",
        "1/3+Y-X,2/3-X,2/3+Z",
        "1/3+Y,2/3+X,2/3-Z",
        "1/3+X-Y,2/3-Y,2/3-Z",
        "1/3-X,2/3+Y-X,2/3-Z",
        "1/3-X,2/3-Y,2/3-Z",
        "1/3+Y,2/3+Y-X,2/3-Z",
        "1/3+X-Y,2/3+X,2/3-Z",
        "1/3-Y,2/3-X,2/3+Z",
        "1/3+Y-X,2/3+Y,2/3+Z",
        "1/3+X,2/3+X-Y,2/3+Z"
    ],
    "R -3 2/m": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X",
        "-Y,-X,-Z",
        "-X,-Z,-Y",
        "-Z,-Y,-X",
        "-X,-Y,-Z",
        "-Z,-X,-Y",
        "-Y,-Z,-X",
        "Y,X,Z",
        "X,Z,Y",
        "Z,Y,X"
    ],
    "H -3 2/c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "Y,X,1/2-Z",
        "X-Y,-Y,1/2-Z",
        "-X,Y-X,1/2-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "2/3+X,1/3+Y,1/3+Z",
        "2/3-Y,1/3+X-Y,1/3+Z",
        "2/3+Y-X,1/3-X,1/3+Z",
        "2/3+Y,1/3+X,5/6-Z",
        "2/3+X-Y,1/3-Y,5/6-Z",
        "2/3-X,1/3+Y-X,5/6-Z",
        "2/3-X,1/3-Y,1/3-Z",
        "2/3+Y,1/3+Y-X,1/3-Z",
        "2/3+X-Y,1/3+X,1/3-Z",
        "2/3-Y,1/3-X,5/6+Z",
        "2/3+Y-X,1/3+Y,5/6+Z",
        "2/3+X,1/3+X-Y,5/6+Z",
        "1/3+X,2/3+Y,2/3+Z",
        "1/3-Y,2/3+X-Y,2/3+Z",
        "1/3+Y-X,2/3-X,2/3+Z",
        "1/3+Y,2/3+X,1/6-Z",
        "1/3+X-Y,2/3-Y,1/6-Z",
        "1/3-X,2/3+Y-X,1/6-Z",
        "1/3-X,2/3-Y,2/3-Z",
        "1/3+Y,2/3+Y-X,2/3-Z",
        "1/3+X-Y,2/3+X,2/3-Z",
        "1/3-Y,2/3-X,1/6+Z",
        "1/3+Y-X,2/3+Y,1/6+Z",
        "1/3+X,2/3+X-Y,1/6+Z"
    ],
    "R -3 2/c": [
        "X,Y,Z",
        "Z,X,Y",
        "Y,Z,X",
        "-Y+1/2,-X+1/2,-Z+1/2",
        "-X+1/2,-Z+1/2,-Y+1/2",
        "-Z+1/2,-Y+1/2,-X+1/2",
        "-X,-Y,-Z",
        "-Z,-X,-Y",
        "-Y,-Z,-X",
        "Y+1/2,X+1/2,Z+1/2",
        "X+1/2,Z+1/2,Y+1/2",
        "Z+1/2,Y+1/2,X+1/2"
    ],
    "P 6": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z"
    ],
    "P 61": [
        "X,Y,Z",
        "-Y,X-Y,Z+1/3",
        "Y-X,-X,Z+2/3",
        "-X,-Y,Z+1/2",
        "Y,Y-X,Z+5/6",
        "X-Y,X,Z+1/6"
    ],
    "P 65": [
        "X,Y,Z",
        "-Y,X-Y,Z+2/3",
        "Y-X,-X,Z+1/3",
        "-X,-Y,Z+1/2",
        "Y,Y-X,Z+1/6",
        "X-Y,X,Z+5/6"
    ],
    "P 62": [
        "X,Y,Z",
        "-Y,X-Y,2/3+Z",
        "Y-X,-X,1/3+Z",
        "-X,-Y,Z",
        "Y,Y-X,2/3+Z",
        "X-Y,X,1/3+Z"
    ],
    "P 64": [
        "X,Y,Z",
        "-Y,X-Y,1/3+Z",
        "Y-X,-X,2/3+Z",
        "-X,-Y,Z",
        "Y,Y-X,1/3+Z",
        "X-Y,X,2/3+Z"
    ],
    "P 63": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z"
    ],
    "P -6": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "X,Y,-Z",
        "-Y,X-Y,-Z",
        "Y-X,-X,-Z"
    ],
    "P 6/m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "X,Y,-Z",
        "-Y,X-Y,-Z",
        "Y-X,-X,-Z"
    ],
    "P 63/m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "X,Y,1/2-Z",
        "-Y,X-Y,1/2-Z",
        "Y-X,-X,1/2-Z"
    ],
    "P 6 2 2": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z"
    ],
    "P 61 2 2": [
        "X,Y,Z",
        "-Y,X-Y,1/3+Z",
        "Y-X,-X,2/3+Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,5/6+Z",
        "X-Y,X,1/6+Z",
        "Y,X,1/3-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,2/3-Z",
        "-Y,-X,5/6-Z",
        "Y-X,Y,1/2-Z",
        "X,X-Y,1/6-Z"
    ],
    "P 65 2 2": [
        "X,Y,Z",
        "-Y,X-Y,2/3+Z",
        "Y-X,-X,1/3+Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/6+Z",
        "X-Y,X,5/6+Z",
        "Y,X,2/3-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,1/3-Z",
        "-Y,-X,1/6-Z",
        "Y-X,Y,1/2-Z",
        "X,X-Y,5/6-Z"
    ],
    "P 62 2 2": [
        "X,Y,Z",
        "-Y,X-Y,2/3+Z",
        "Y-X,-X,1/3+Z",
        "-X,-Y,Z",
        "Y,Y-X,2/3+Z",
        "X-Y,X,1/3+Z",
        "Y,X,2/3-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,1/3-Z",
        "-Y,-X,2/3-Z",
        "Y-X,Y,-Z",
        "X,X-Y,1/3-Z"
    ],
    "P 64 2 2": [
        "X,Y,Z",
        "-Y,X-Y,1/3+Z",
        "Y-X,-X,2/3+Z",
        "-X,-Y,Z",
        "Y,Y-X,1/3+Z",
        "X-Y,X,2/3+Z",
        "Y,X,1/3-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,2/3-Z",
        "-Y,-X,1/3-Z",
        "Y-X,Y,-Z",
        "X,X-Y,2/3-Z"
    ],
    "P 63 2 2": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "-Y,-X,1/2-Z",
        "Y-X,Y,1/2-Z",
        "X,X-Y,1/2-Z"
    ],
    "P 6 m m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P 6 c c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "P 63 c m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P 63 m c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "P -6 m 2": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "X,Y,-Z",
        "-Y,X-Y,-Z",
        "Y-X,-X,-Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z"
    ],
    "P -6 c 2": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "X,Y,1/2-Z",
        "-Y,X-Y,1/2-Z",
        "Y-X,-X,1/2-Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z"
    ],
    "P -6 2 m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "X,Y,-Z",
        "-Y,X-Y,-Z",
        "Y-X,-X,-Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P -6 2 c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "X,Y,1/2-Z",
        "-Y,X-Y,1/2-Z",
        "Y-X,-X,1/2-Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "P 6/m 2/m 2/m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "X,Y,-Z",
        "Y-X,-X,-Z",
        "-Y,X-Y,-Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P 6/m 2/c 2/c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,Z",
        "Y,Y-X,Z",
        "X-Y,X,Z",
        "Y,X,1/2-Z",
        "X-Y,-Y,1/2-Z",
        "-X,Y-X,1/2-Z",
        "-Y,-X,1/2-Z",
        "Y-X,Y,1/2-Z",
        "X,X-Y,1/2-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "X,Y,-Z",
        "Y-X,-X,-Z",
        "-Y,X-Y,-Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "P 63/m 2/c 2/m": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z",
        "Y,X,1/2-Z",
        "X-Y,-Y,1/2-Z",
        "-X,Y-X,1/2-Z",
        "-Y,-X,-Z",
        "Y-X,Y,-Z",
        "X,X-Y,-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "X,Y,1/2-Z",
        "Y-X,-X,1/2-Z",
        "-Y,X-Y,1/2-Z",
        "-Y,-X,1/2+Z",
        "Y-X,Y,1/2+Z",
        "X,X-Y,1/2+Z",
        "Y,X,Z",
        "X-Y,-Y,Z",
        "-X,Y-X,Z"
    ],
    "P 63/m 2/m 2/c": [
        "X,Y,Z",
        "-Y,X-Y,Z",
        "Y-X,-X,Z",
        "-X,-Y,1/2+Z",
        "Y,Y-X,1/2+Z",
        "X-Y,X,1/2+Z",
        "Y,X,-Z",
        "X-Y,-Y,-Z",
        "-X,Y-X,-Z",
        "-Y,-X,1/2-Z",
        "Y-X,Y,1/2-Z",
        "X,X-Y,1/2-Z",
        "-X,-Y,-Z",
        "Y,Y-X,-Z",
        "X-Y,X,-Z",
        "X,Y,1/2-Z",
        "Y-X,-X,1/2-Z",
        "-Y,X-Y,1/2-Z",
        "-Y,-X,Z",
        "Y-X,Y,Z",
        "X,X-Y,Z",
        "Y,X,1/2+Z",
        "X-Y,-Y,1/2+Z",
        "-X,Y-X,1/2+Z"
    ],
    "P 2 3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X"
    ],
    "F 2 3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X"
    ],
    "I 2 3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,1/2-Y",
        "1/2-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,1/2-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,1/2-X",
        "1/2-Y,1/2-Z,1/2+X"
    ],
    "P 21 3": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X"
    ],
    "I 21 3": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,Y,-Z",
        "X,-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "Z,-X,1/2-Y",
        "-Z,1/2-X,Y",
        "1/2-Z,X,-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,Z,-X",
        "Y,-Z,1/2-X",
        "-Y,1/2-Z,X"
    ],
    "P 2/m -3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X"
    ],
    "P 2/n -3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "1/2-Z,1/2+X,1/2+Y",
        "1/2+Z,1/2+X,1/2-Y",
        "1/2+Z,1/2-X,1/2+Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,1/2+X",
        "1/2+Y,1/2+Z,1/2-X"
    ],
    "F 2/m -3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "-X,1/2-Y,1/2-Z",
        "X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z",
        "-Z,1/2-X,1/2-Y",
        "-Z,1/2+X,1/2+Y",
        "Z,1/2+X,1/2-Y",
        "Z,1/2-X,1/2+Y",
        "-Y,1/2-Z,1/2-X",
        "Y,1/2-Z,1/2+X",
        "-Y,1/2+Z,1/2+X",
        "Y,1/2+Z,1/2-X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/2-X,-Y,1/2-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z",
        "1/2-Z,-X,1/2-Y",
        "1/2-Z,X,1/2+Y",
        "1/2+Z,X,1/2-Y",
        "1/2+Z,-X,1/2+Y",
        "1/2-Y,-Z,1/2-X",
        "1/2+Y,-Z,1/2+X",
        "1/2-Y,Z,1/2+X",
        "1/2+Y,Z,1/2-X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Z,1/2-X,-Y",
        "1/2-Z,1/2+X,Y",
        "1/2+Z,1/2+X,-Y",
        "1/2+Z,1/2-X,Y",
        "1/2-Y,1/2-Z,-X",
        "1/2+Y,1/2-Z,X",
        "1/2-Y,1/2+Z,X",
        "1/2+Y,1/2+Z,-X"
    ],
    "F 2/d -3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/4-X,1/4-Y,1/4-Z",
        "1/4+X,1/4+Y,1/4-Z",
        "1/4+X,1/4-Y,1/4+Z",
        "1/4-X,1/4+Y,1/4+Z",
        "1/4-Z,1/4-X,1/4-Y",
        "1/4-Z,1/4+X,1/4+Y",
        "1/4+Z,1/4+X,1/4-Y",
        "1/4+Z,1/4-X,1/4+Y",
        "1/4-Y,1/4-Z,1/4-X",
        "1/4+Y,1/4-Z,1/4+X",
        "1/4-Y,1/4+Z,1/4+X",
        "1/4+Y,1/4+Z,1/4-X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "1/4-X,3/4-Y,3/4-Z",
        "1/4+X,3/4+Y,3/4-Z",
        "1/4+X,3/4-Y,3/4+Z",
        "1/4-X,3/4+Y,3/4+Z",
        "1/4-Z,3/4-X,3/4-Y",
        "1/4-Z,3/4+X,3/4+Y",
        "1/4+Z,3/4+X,3/4-Y",
        "1/4+Z,3/4-X,3/4+Y",
        "1/4-Y,3/4-Z,3/4-X",
        "1/4+Y,3/4-Z,3/4+X",
        "1/4-Y,3/4+Z,3/4+X",
        "1/4+Y,3/4+Z,3/4-X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "3/4-X,1/4-Y,3/4-Z",
        "3/4+X,1/4+Y,3/4-Z",
        "3/4+X,1/4-Y,3/4+Z",
        "3/4-X,1/4+Y,3/4+Z",
        "3/4-Z,1/4-X,3/4-Y",
        "3/4-Z,1/4+X,3/4+Y",
        "3/4+Z,1/4+X,3/4-Y",
        "3/4+Z,1/4-X,3/4+Y",
        "3/4-Y,1/4-Z,3/4-X",
        "3/4+Y,1/4-Z,3/4+X",
        "3/4-Y,1/4+Z,3/4+X",
        "3/4+Y,1/4+Z,3/4-X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "3/4-X,3/4-Y,1/4-Z",
        "3/4+X,3/4+Y,1/4-Z",
        "3/4+X,3/4-Y,Z+1/4",
        "3/4-X,3/4+Y,Z+1/4",
        "3/4-Z,3/4-X,1/4-Y",
        "3/4-Z,3/4+X,1/4+Y",
        "3/4+Z,3/4+X,1/4-Y",
        "3/4+Z,3/4-X,1/4+Y",
        "3/4-Y,3/4-Z,1/4-X",
        "3/4+Y,3/4-Z,1/4+X",
        "3/4-Y,3/4+Z,1/4+X",
        "3/4+Y,3/4+Z,1/4-X"
    ],
    "I 2/m -3": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,1/2-Y",
        "1/2-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,1/2-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,1/2-X",
        "1/2-Y,1/2-Z,1/2+X",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "1/2-Z,1/2+X,1/2+Y",
        "1/2+Z,1/2+X,1/2-Y",
        "1/2+Z,1/2-X,1/2+Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,1/2+X",
        "1/2+Y,1/2+Z,1/2-X"
    ],
    "P 21/a -3": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z",
        "-Z,-X,-Y",
        "1/2-Z,1/2+X,Y",
        "1/2+Z,X,1/2-Y",
        "Z,1/2-X,1/2+Y",
        "-Y,-Z,-X",
        "Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,X",
        "1/2+Y,Z,1/2-X"
    ],
    "I 21/a -3": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z",
        "-Z,-X,-Y",
        "1/2-Z,1/2+X,Y",
        "1/2+Z,X,1/2-Y",
        "Z,1/2-X,1/2+Y",
        "-Y,-Z,-X",
        "Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,X",
        "1/2+Y,Z,1/2-X",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,+Y,-Z",
        "X,-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "Z,-X,1/2-Y",
        "-Z,1/2-X,Y",
        "1/2-Z,X,-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,Z,-X",
        "Y,-Z,1/2-X",
        "-Y,1/2-Z,X",
        "1/2-X,1/2-Y,1/2-Z",
        "X,1/2+Y,-Z",
        "1/2+X,-Y,Z",
        "-X,Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "-Z,X,1/2+Y",
        "Z,1/2+X,-Y",
        "1/2+Z,-X,Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,-Z,X",
        "-Y,Z,1/2+X",
        "Y,1/2+Z,-X"
    ],
    "P 4 3 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X"
    ],
    "P 42 3 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+X,1/2+Z,1/2-Y",
        "1/2-X,1/2+Z,1/2+Y",
        "1/2-X,1/2-Z,1/2-Y",
        "1/2+X,1/2-Z,1/2+Y",
        "1/2+Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2+X",
        "1/2-Z,1/2-Y,1/2-X"
    ],
    "F 4 3 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "Y,1/2+X,1/2-Z",
        "-Y,1/2-X,1/2-Z",
        "Y,1/2-X,1/2+Z",
        "-Y,1/2+X,1/2+Z",
        "X,1/2+Z,1/2-Y",
        "-X,1/2+Z,1/2+Y",
        "-X,1/2-Z,1/2-Y",
        "X,1/2-Z,1/2+Y",
        "Z,1/2+Y,1/2-X",
        "Z,1/2-Y,1/2+X",
        "-Z,1/2+Y,1/2+X",
        "-Z,1/2-Y,1/2-X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/2+Y,X,1/2-Z",
        "1/2-Y,-X,1/2-Z",
        "1/2+Y,-X,1/2+Z",
        "1/2-Y,X,1/2+Z",
        "1/2+X,Z,1/2-Y",
        "1/2-X,Z,1/2+Y",
        "1/2-X,-Z,1/2-Y",
        "1/2+X,-Z,1/2+Y",
        "1/2+Z,Y,1/2-X",
        "1/2+Z,-Y,1/2+X",
        "1/2-Z,Y,1/2+X",
        "1/2-Z,-Y,1/2-X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z",
        "1/2+Y,1/2-X,Z",
        "1/2-Y,1/2+X,Z",
        "1/2+X,1/2+Z,-Y",
        "1/2-X,1/2+Z,Y",
        "1/2-X,1/2-Z,-Y",
        "1/2+X,1/2-Z,Y",
        "1/2+Z,1/2+Y,-X",
        "1/2+Z,1/2-Y,X",
        "1/2-Z,1/2+Y,X",
        "1/2-Z,1/2-Y,-X"
    ],
    "F 41 3 2": [
        "X,Y,Z",
        "-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,-Y,1/2-Z",
        "Z,X,Y",
        "1/2+Z,-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,-Y",
        "Y,Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "3/4+Y,1/4+X,3/4-Z",
        "1/4-Y,1/4-X,1/4-Z",
        "1/4+Y,3/4-X,3/4+Z",
        "3/4-Y,3/4+X,1/4+Z",
        "3/4+X,1/4+Z,3/4-Y",
        "3/4-X,3/4+Z,1/4+Y",
        "1/4-X,1/4-Z,1/4-Y",
        "1/4+X,3/4-Z,3/4+Y",
        "3/4+Z,1/4+Y,3/4-X",
        "1/4+Z,3/4-Y,3/4+X",
        "3/4-Z,3/4+Y,1/4+X",
        "1/4-Z,1/4-Y,1/4-X",
        "X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,-Y",
        "-Z,-X,Y",
        "1/2-Z,X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "-Y,-Z,X",
        "3/4+Y,3/4+X,1/4-Z",
        "1/4-Y,3/4-X,3/4-Z",
        "1/4+Y,1/4-X,1/4+Z",
        "3/4-Y,1/4+X,3/4+Z",
        "3/4+X,3/4+Z,1/4-Y",
        "3/4-X,1/4+Z,3/4+Y",
        "1/4-X,3/4-Z,3/4-Y",
        "1/4+X,1/4-Z,1/4+Y",
        "3/4+Z,3/4+Y,1/4-X",
        "1/4+Z,1/4-Y,1/4+X",
        "3/4-Z,1/4+Y,3/4+X",
        "1/4-Z,3/4-Y,3/4-X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,1/2-Y,Z",
        "-X,1/2+Y,1/2-Z",
        "X,-Y,-Z",
        "1/2+Z,X,1/2+Y",
        "Z,-X,-Y",
        "1/2-Z,1/2-X,Y",
        "-Z,1/2+X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/4+Y,1/4+X,1/4-Z",
        "3/4-Y,1/4-X,3/4-Z",
        "3/4+Y,3/4-X,1/4+Z",
        "1/4-Y,3/4+X,3/4+Z",
        "1/4+X,1/4+Z,1/4-Y",
        "1/4-X,3/4+Z,3/4+Y",
        "3/4-X,1/4-Z,3/4-Y",
        "3/4+X,3/4-Z,1/4+Y",
        "1/4+Z,1/4+Y,1/4-X",
        "3/4+Z,3/4-Y,1/4+X",
        "1/4-Z,3/4+Y,3/4+X",
        "3/4-Z,1/4-Y,3/4-X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,Y,-Z",
        "X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,Y",
        "Z,1/2-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,X,-Y",
        "1/2+Y,1/2+Z,X",
        "-Y,Z,-X",
        "Y,1/2-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/4+Y,3/4+X,3/4-Z",
        "3/4-Y,3/4-X,1/4-Z",
        "3/4+Y,1/4-X,3/4+Z",
        "1/4-Y,1/4+X,1/4+Z",
        "1/4+X,3/4+Z,3/4-Y",
        "1/4-X,1/4+Z,1/4+Y",
        "3/4-X,3/4-Z,1/4-Y",
        "3/4+X,1/4-Z,3/4+Y",
        "1/4+Z,3/4+Y,3/4-X",
        "3/4+Z,1/4-Y,3/4+X",
        "1/4-Z,1/4+Y,1/4+X",
        "3/4-Z,3/4-Y,1/4-X"
    ],
    "I 4 3 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,1/2-Y",
        "1/2-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,1/2-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,1/2-X",
        "1/2-Y,1/2-Z,1/2+X",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+X,1/2+Z,1/2-Y",
        "1/2-X,1/2+Z,1/2+Y",
        "1/2-X,1/2-Z,1/2-Y",
        "1/2+X,1/2-Z,1/2+Y",
        "1/2+Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2+X",
        "1/2-Z,1/2-Y,1/2-X"
    ],
    "P 43 3 2": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "1/4+Y,3/4+X,3/4-Z",
        "1/4-Y,1/4-X,1/4-Z",
        "3/4+Y,3/4-X,1/4+Z",
        "3/4-Y,1/4+X,3/4+Z",
        "1/4+X,3/4+Z,3/4-Y",
        "3/4-X,1/4+Z,3/4+Y",
        "1/4-X,1/4-Z,1/4-Y",
        "3/4+X,3/4-Z,1/4+Y",
        "1/4+Z,3/4+Y,3/4-X",
        "3/4+Z,3/4-Y,1/4+X",
        "3/4-Z,1/4+Y,3/4+X",
        "1/4-Z,1/4-Y,1/4-X"
    ],
    "P 41 3 2": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "3/4+Y,1/4+X,1/4-Z",
        "3/4-Y,3/4-X,3/4-Z",
        "1/4+Y,1/4-X,3/4+Z",
        "1/4-Y,3/4+X,1/4+Z",
        "3/4+X,1/4+Z,1/4-Y",
        "1/4-X,3/4+Z,1/4+Y",
        "3/4-X,3/4-Z,3/4-Y",
        "1/4+X,1/4-Z,3/4+Y",
        "3/4+Z,1/4+Y,1/4-X",
        "1/4+Z,1/4-Y,3/4+X",
        "1/4-Z,3/4+Y,1/4+X",
        "3/4-Z,3/4-Y,3/4-X"
    ],
    "I 41 3 2": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "3/4+Y,1/4+X,1/4-Z",
        "3/4-Y,3/4-X,3/4-Z",
        "1/4+Y,1/4-X,3/4+Z",
        "1/4-Y,3/4+X,1/4+Z",
        "3/4+X,1/4+Z,1/4-Y",
        "1/4-X,3/4+Z,1/4+Y",
        "3/4-X,3/4-Z,3/4-Y",
        "1/4+X,1/4-Z,3/4+Y",
        "3/4+Z,1/4+Y,1/4-X",
        "1/4+Z,1/4-Y,3/4+X",
        "1/4-Z,3/4+Y,1/4+X",
        "3/4-Z,3/4-Y,3/4-X",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,Y,-Z",
        "X,-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "Z,-X,1/2-Y",
        "-Z,1/2-X,Y",
        "1/2-Z,X,-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,Z,-X",
        "Y,-Z,1/2-X",
        "-Y,1/2-Z,X",
        "1/4+Y,3/4+X,3/4-Z",
        "1/4-Y,1/4-X,1/4-Z",
        "3/4+Y,3/4-X,1/4+Z",
        "3/4-Y,1/4+X,3/4+Z",
        "1/4+X,3/4+Z,3/4-Y",
        "3/4-X,1/4+Z,3/4+Y",
        "1/4-X,1/4-Z,1/4-Y",
        "3/4+X,3/4-Z,1/4+Y",
        "1/4+Z,3/4+Y,3/4-X",
        "3/4+Z,3/4-Y,1/4+X",
        "3/4-Z,1/4+Y,3/4+X",
        "1/4-Z,1/4-Y,1/4-X"
    ],
    "P -4 3 m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,Z",
        "-Y,-X,Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,Z,Y",
        "-X,Z,-Y",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "Z,Y,X",
        "Z,-Y,-X",
        "-Z,Y,-X",
        "-Z,-Y,X"
    ],
    "F -4 3 m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,Z",
        "-Y,-X,Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,Z,Y",
        "-X,Z,-Y",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "Z,Y,X",
        "Z,-Y,-X",
        "-Z,Y,-X",
        "-Z,-Y,X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "Y,1/2+X,1/2+Z",
        "-Y,1/2-X,1/2+Z",
        "Y,1/2-X,1/2-Z",
        "-Y,1/2+X,1/2-Z",
        "X,1/2+Z,1/2+Y",
        "-X,1/2+Z,1/2-Y",
        "-X,1/2-Z,1/2+Y",
        "X,1/2-Z,1/2-Y",
        "Z,1/2+Y,1/2+X",
        "Z,1/2-Y,1/2-X",
        "-Z,1/2+Y,1/2-X",
        "-Z,1/2-Y,1/2+X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/2+Y,X,1/2+Z",
        "1/2-Y,-X,1/2+Z",
        "1/2+Y,-X,1/2-Z",
        "1/2-Y,X,1/2-Z",
        "1/2+X,Z,1/2+Y",
        "1/2-X,Z,1/2-Y",
        "1/2-X,-Z,1/2+Y",
        "1/2+X,-Z,1/2-Y",
        "1/2+Z,Y,1/2+X",
        "1/2+Z,-Y,1/2-X",
        "1/2-Z,Y,1/2-X",
        "1/2-Z,-Y,1/2+X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/2+Y,1/2+X,Z",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2-X,-Z",
        "1/2-Y,1/2+X,-Z",
        "1/2+X,1/2+Z,Y",
        "1/2-X,1/2+Z,-Y",
        "1/2-X,1/2-Z,Y",
        "1/2+X,1/2-Z,-Y",
        "1/2+Z,1/2+Y,X",
        "1/2+Z,1/2-Y,-X",
        "1/2-Z,1/2+Y,-X",
        "1/2-Z,1/2-Y,X"
    ],
    "I -4 3 m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,Z",
        "-Y,-X,Z",
        "Y,-X,-Z",
        "-Y,X,-Z",
        "X,Z,Y",
        "-X,Z,-Y",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "Z,Y,X",
        "Z,-Y,-X",
        "-Z,Y,-X",
        "-Z,-Y,X",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,1/2-Y",
        "1/2-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,1/2-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,1/2-X",
        "1/2-Y,1/2-Z,1/2+X",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+Z,1/2+Y,1/2+X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2-Z,1/2-Y,1/2+X"
    ],
    "P -4 3 n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+Z,1/2+Y,1/2+X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2-Z,1/2-Y,1/2+X"
    ],
    "F -4 3 c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+Z,1/2+Y,1/2+X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2-Z,1/2-Y,1/2+X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "1/2+Y,X,Z",
        "1/2-Y,-X,Z",
        "1/2+Y,-X,-Z",
        "1/2-Y,X,-Z",
        "1/2+X,Z,Y",
        "1/2-X,Z,-Y",
        "1/2-X,-Z,Y",
        "1/2+X,-Z,-Y",
        "1/2+Z,Y,X",
        "1/2+Z,-Y,-X",
        "1/2-Z,Y,-X",
        "1/2-Z,-Y,X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "Y,1/2+X,Z",
        "-Y,1/2-X,Z",
        "Y,1/2-X,-Z",
        "-Y,1/2+X,-Z",
        "X,1/2+Z,Y",
        "-X,1/2+Z,-Y",
        "-X,1/2-Z,Y",
        "X,1/2-Z,-Y",
        "Z,1/2+Y,X",
        "Z,1/2-Y,-X",
        "-Z,1/2+Y,-X",
        "-Z,1/2-Y,X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "Y,X,1/2+Z",
        "-Y,-X,1/2+Z",
        "Y,-X,1/2-Z",
        "-Y,X,1/2-Z",
        "X,Z,1/2+Y",
        "-X,Z,1/2-Y",
        "-X,-Z,1/2+Y",
        "X,-Z,1/2-Y",
        "Z,Y,1/2+X",
        "Z,-Y,1/2-X",
        "-Z,Y,1/2-X",
        "-Z,-Y,1/2+X"
    ],
    "I -4 3 d": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "1/4+Y,1/4+X,1/4+Z",
        "1/4-Y,3/4-X,3/4+Z",
        "3/4+Y,1/4-X,3/4-Z",
        "3/4-Y,3/4+X,1/4-Z",
        "1/4+X,1/4+Z,1/4+Y",
        "3/4-X,3/4+Z,1/4-Y",
        "1/4-X,3/4-Z,3/4+Y",
        "3/4+X,1/4-Z,3/4-Y",
        "1/4+Z,1/4+Y,1/4+X",
        "3/4+Z,1/4-Y,3/4-X",
        "3/4-Z,3/4+Y,1/4-X",
        "1/4-Z,3/4-Y,3/4+X",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,Y,-Z",
        "X,-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "Z,-X,1/2-Y",
        "-Z,1/2-X,Y",
        "1/2-Z,X,-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,Z,-X",
        "Y,-Z,1/2-X",
        "-Y,1/2-Z,X",
        "3/4+Y,3/4+X,3/4+Z",
        "3/4-Y,1/4-X,1/4+Z",
        "1/4+Y,3/4-X,1/4-Z",
        "1/4-Y,1/4+X,3/4-Z",
        "3/4+X,3/4+Z,3/4+Y",
        "1/4-X,1/4+Z,3/4-Y",
        "3/4-X,1/4-Z,1/4+Y",
        "1/4+X,3/4-Z,1/4-Y",
        "3/4+Z,3/4+Y,3/4+X",
        "1/4+Z,3/4-Y,1/4-X",
        "1/4-Z,1/4+Y,3/4-X",
        "3/4-Z,1/4-Y,1/4+X"
    ],
    "P 4/m -3 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "-Y,-X,Z",
        "Y,X,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "X,Z,Y",
        "-X,Z,-Y",
        "-Z,-Y,X",
        "-Z,Y,-X",
        "Z,-Y,-X",
        "Z,Y,X"
    ],
    "P 4/n -3 2/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "1/2-Z,1/2+X,1/2+Y",
        "1/2+Z,1/2+X,1/2-Y",
        "1/2+Z,1/2-X,1/2+Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,1/2+X",
        "1/2+Y,1/2+Z,1/2-X",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2+Z,1/2+Y,1/2+X"
    ],
    "P 42/m -3 2/n": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+X,1/2+Z,1/2-Y",
        "1/2-X,1/2+Z,1/2+Y",
        "1/2-X,1/2-Z,1/2-Y",
        "1/2+X,1/2-Z,1/2+Y",
        "1/2+Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2+X",
        "1/2-Z,1/2-Y,1/2-X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2+Z,1/2+Y,1/2+X"
    ],
    "P 42/n -3 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+X,1/2+Z,1/2-Y",
        "1/2-X,1/2+Z,1/2+Y",
        "1/2-X,1/2-Z,1/2-Y",
        "1/2+X,1/2-Z,1/2+Y",
        "1/2+Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2+X",
        "1/2-Z,1/2-Y,1/2-X",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "1/2-Z,1/2+X,1/2+Y",
        "1/2+Z,1/2+X,1/2-Y",
        "1/2+Z,1/2-X,1/2+Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,1/2+X",
        "1/2+Y,1/2+Z,1/2-X",
        "-Y,-X,Z",
        "Y,X,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "X,Z,Y",
        "-X,Z,-Y",
        "-Z,-Y,X",
        "-Z,Y,-X",
        "Z,-Y,-X",
        "Z,Y,X"
    ],
    "F 4/m -3 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "-Y,-X,Z",
        "Y,X,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "X,Z,Y",
        "-X,Z,-Y",
        "-Z,-Y,X",
        "-Z,Y,-X",
        "Z,-Y,-X",
        "Z,Y,X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "Y,1/2+X,1/2-Z",
        "-Y,1/2-X,1/2-Z",
        "Y,1/2-X,1/2+Z",
        "-Y,1/2+X,1/2+Z",
        "X,1/2+Z,1/2-Y",
        "-X,1/2+Z,1/2+Y",
        "-X,1/2-Z,1/2-Y",
        "X,1/2-Z,1/2+Y",
        "Z,1/2+Y,1/2-X",
        "Z,1/2-Y,1/2+X",
        "-Z,1/2+Y,1/2+X",
        "-Z,1/2-Y,1/2-X",
        "-X,1/2-Y,1/2-Z",
        "X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z",
        "-Z,1/2-X,1/2-Y",
        "-Z,1/2+X,1/2+Y",
        "Z,1/2+X,1/2-Y",
        "Z,1/2-X,1/2+Y",
        "-Y,1/2-Z,1/2-X",
        "Y,1/2-Z,1/2+X",
        "-Y,1/2+Z,1/2+X",
        "Y,1/2+Z,1/2-X",
        "-Y,1/2-X,1/2+Z",
        "Y,1/2+X,1/2+Z",
        "-Y,1/2+X,1/2-Z",
        "Y,1/2-X,1/2-Z",
        "-X,1/2-Z,1/2+Y",
        "X,1/2-Z,1/2-Y",
        "X,1/2+Z,1/2+Y",
        "-X,1/2+Z,1/2-Y",
        "-Z,1/2-Y,1/2+X",
        "-Z,1/2+Y,1/2-X",
        "Z,1/2-Y,1/2-X",
        "Z,1/2+Y,1/2+X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/2+Y,X,1/2-Z",
        "1/2-Y,-X,1/2-Z",
        "1/2+Y,-X,1/2+Z",
        "1/2-Y,X,1/2+Z",
        "1/2+X,Z,1/2-Y",
        "1/2-X,Z,1/2+Y",
        "1/2-X,-Z,1/2-Y",
        "1/2+X,-Z,1/2+Y",
        "1/2+Z,Y,1/2-X",
        "1/2+Z,-Y,1/2+X",
        "1/2-Z,Y,1/2+X",
        "1/2-Z,-Y,1/2-X",
        "1/2-X,-Y,1/2-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z",
        "1/2-Z,-X,1/2-Y",
        "1/2-Z,X,1/2+Y",
        "1/2+Z,X,1/2-Y",
        "1/2+Z,-X,1/2+Y",
        "1/2-Y,-Z,1/2-X",
        "1/2+Y,-Z,1/2+X",
        "1/2-Y,Z,1/2+X",
        "1/2+Y,Z,1/2-X",
        "1/2-Y,-X,1/2+Z",
        "1/2+Y,X,1/2+Z",
        "1/2-Y,X,1/2-Z",
        "1/2+Y,-X,1/2-Z",
        "1/2-X,-Z,1/2+Y",
        "1/2+X,-Z,1/2-Y",
        "1/2+X,Z,1/2+Y",
        "1/2-X,Z,1/2-Y",
        "1/2-Z,-Y,1/2+X",
        "1/2-Z,Y,1/2-X",
        "1/2+Z,-Y,1/2-X",
        "1/2+Z,Y,1/2+X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/2+Y,1/2+X,-Z",
        "1/2-Y,1/2-X,-Z",
        "1/2+Y,1/2-X,Z",
        "1/2-Y,1/2+X,Z",
        "1/2+X,1/2+Z,-Y",
        "1/2-X,1/2+Z,Y",
        "1/2-X,1/2-Z,-Y",
        "1/2+X,1/2-Z,Y",
        "1/2+Z,1/2+Y,-X",
        "1/2+Z,1/2-Y,X",
        "1/2-Z,1/2+Y,X",
        "1/2-Z,1/2-Y,-X",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Z,1/2-X,-Y",
        "1/2-Z,1/2+X,Y",
        "1/2+Z,1/2+X,-Y",
        "1/2+Z,1/2-X,Y",
        "1/2-Y,1/2-Z,-X",
        "1/2+Y,1/2-Z,X",
        "1/2-Y,1/2+Z,X",
        "1/2+Y,1/2+Z,-X",
        "1/2-Y,1/2-X,Z",
        "1/2+Y,1/2+X,Z",
        "1/2-Y,1/2+X,-Z",
        "1/2+Y,1/2-X,-Z",
        "1/2-X,1/2-Z,Y",
        "1/2+X,1/2-Z,-Y",
        "1/2+X,1/2+Z,Y",
        "1/2-X,1/2+Z,-Y",
        "1/2-Z,1/2-Y,X",
        "1/2-Z,1/2+Y,-X",
        "1/2+Z,1/2-Y,-X",
        "1/2+Z,1/2+Y,X"
    ],
    "F 4/m -3 2/c": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+X,1/2+Z,1/2-Y",
        "1/2-X,1/2+Z,1/2+Y",
        "1/2-X,1/2-Z,1/2-Y",
        "1/2+X,1/2-Z,1/2+Y",
        "1/2+Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2+X",
        "1/2-Z,1/2-Y,1/2-X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2+Z,1/2+Y,1/2+X",
        "X,1/2+Y,1/2+Z",
        "-X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2-Z",
        "Z,1/2+X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,1/2-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "1/2+Y,X,-Z",
        "1/2-Y,-X,-Z",
        "1/2+Y,-X,Z",
        "1/2-Y,X,Z",
        "1/2+X,Z,-Y",
        "1/2-X,Z,Y",
        "1/2-X,-Z,-Y",
        "1/2+X,-Z,Y",
        "1/2+Z,Y,-X",
        "1/2+Z,-Y,X",
        "1/2-Z,Y,X",
        "1/2-Z,-Y,-X",
        "-X,1/2-Y,1/2-Z",
        "X,1/2+Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "-X,1/2+Y,1/2+Z",
        "-Z,1/2-X,1/2-Y",
        "-Z,1/2+X,1/2+Y",
        "Z,1/2+X,1/2-Y",
        "Z,1/2-X,1/2+Y",
        "-Y,1/2-Z,1/2-X",
        "Y,1/2-Z,1/2+X",
        "-Y,1/2+Z,1/2+X",
        "Y,1/2+Z,1/2-X",
        "1/2-Y,-X,Z",
        "1/2+Y,X,Z",
        "1/2-Y,X,-Z",
        "1/2+Y,-X,-Z",
        "1/2-X,-Z,Y",
        "1/2+X,-Z,-Y",
        "1/2+X,Z,Y",
        "1/2-X,Z,-Y",
        "1/2-Z,-Y,X",
        "1/2-Z,Y,-X",
        "1/2+Z,-Y,-X",
        "1/2+Z,Y,X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2+Z,X,1/2+Y",
        "1/2+Z,-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "1/2-Z,X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "Y,1/2+X,-Z",
        "-Y,1/2-X,-Z",
        "Y,1/2-X,Z",
        "-Y,1/2+X,Z",
        "X,1/2+Z,-Y",
        "-X,1/2+Z,Y",
        "-X,1/2-Z,-Y",
        "X,1/2-Z,Y",
        "Z,1/2+Y,-X",
        "Z,1/2-Y,X",
        "-Z,1/2+Y,X",
        "-Z,1/2-Y,-X",
        "1/2-X,-Y,1/2-Z",
        "1/2+X,Y,1/2-Z",
        "1/2+X,-Y,1/2+Z",
        "1/2-X,Y,1/2+Z",
        "1/2-Z,-X,1/2-Y",
        "1/2-Z,X,1/2+Y",
        "1/2+Z,X,1/2-Y",
        "1/2+Z,-X,1/2+Y",
        "1/2-Y,-Z,1/2-X",
        "1/2+Y,-Z,1/2+X",
        "1/2-Y,Z,1/2+X",
        "1/2+Y,Z,1/2-X",
        "-Y,1/2-X,Z",
        "Y,1/2+X,Z",
        "-Y,1/2+X,-Z",
        "Y,1/2-X,-Z",
        "-X,1/2-Z,Y",
        "X,1/2-Z,-Y",
        "X,1/2+Z,Y",
        "-X,1/2+Z,-Y",
        "-Z,1/2-Y,X",
        "-Z,1/2+Y,-X",
        "Z,1/2-Y,-X",
        "Z,1/2+Y,X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,1/2-Y,Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,1/2-Y,-Z",
        "1/2+Z,1/2+X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,1/2-X,Y",
        "1/2-Z,1/2+X,-Y",
        "1/2+Y,1/2+Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,1/2-Z,X",
        "Y,X,1/2-Z",
        "-Y,-X,1/2-Z",
        "Y,-X,1/2+Z",
        "-Y,X,1/2+Z",
        "X,Z,1/2-Y",
        "-X,Z,1/2+Y",
        "-X,-Z,1/2-Y",
        "X,-Z,1/2+Y",
        "Z,Y,1/2-X",
        "Z,-Y,1/2+X",
        "-Z,Y,1/2+X",
        "-Z,-Y,1/2-X",
        "1/2-X,1/2-Y,-Z",
        "1/2+X,1/2+Y,-Z",
        "1/2+X,1/2-Y,Z",
        "1/2-X,1/2+Y,Z",
        "1/2-Z,1/2-X,-Y",
        "1/2-Z,1/2+X,Y",
        "1/2+Z,1/2+X,-Y",
        "1/2+Z,1/2-X,Y",
        "1/2-Y,1/2-Z,-X",
        "1/2+Y,1/2-Z,X",
        "1/2-Y,1/2+Z,X",
        "1/2+Y,1/2+Z,-X",
        "-Y,-X,1/2+Z",
        "Y,X,1/2+Z",
        "-Y,X,1/2-Z",
        "Y,-X,1/2-Z",
        "-X,-Z,1/2+Y",
        "X,-Z,1/2-Y",
        "X,Z,1/2+Y",
        "-X,Z,1/2-Y",
        "-Z,-Y,1/2+X",
        "-Z,Y,1/2-X",
        "Z,-Y,1/2-X",
        "Z,Y,1/2+X"
    ],
    "F 41/d -3 2/m": [
        "X,Y,Z",
        "-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,-Y,1/2-Z",
        "Z,X,Y",
        "1/2+Z,-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,-Y",
        "Y,Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "3/4+Y,1/4+X,3/4-Z",
        "1/4-Y,1/4-X,1/4-Z",
        "1/4+Y,3/4-X,3/4+Z",
        "3/4-Y,3/4+X,1/4+Z",
        "3/4+X,1/4+Z,3/4-Y",
        "3/4-X,3/4+Z,1/4+Y",
        "1/4-X,1/4-Z,1/4-Y",
        "1/4+X,3/4-Z,3/4+Y",
        "3/4+Z,1/4+Y,3/4-X",
        "1/4+Z,3/4-Y,3/4+X",
        "3/4-Z,3/4+Y,1/4+X",
        "1/4-Z,1/4-Y,1/4-X",
        "1/4-X,1/4-Y,1/4-Z",
        "1/4+X,3/4+Y,3/4-Z",
        "3/4+X,3/4-Y,1/4+Z",
        "3/4-X,1/4+Y,3/4+Z",
        "1/4-Z,1/4-X,1/4-Y",
        "3/4-Z,1/4+X,3/4+Y",
        "1/4+Z,3/4+X,3/4-Y",
        "3/4+Z,3/4-X,1/4+Y",
        "1/4-Y,1/4-Z,1/4-X",
        "3/4+Y,3/4-Z,1/4+X",
        "3/4-Y,1/4+Z,3/4+X",
        "1/4+Y,3/4+Z,3/4-X",
        "1/2-Y,-X,1/2+Z",
        "Y,X,Z",
        "-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,-Z",
        "1/2-X,-Z,1/2+Y",
        "1/2+X,1/2-Z,-Y",
        "X,Z,Y",
        "-X,1/2+Z,1/2-Y",
        "1/2-Z,-Y,1/2+X",
        "-Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,-X",
        "Z,Y,X",
        "X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,-Y",
        "-Z,-X,Y",
        "1/2-Z,X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "-Y,-Z,X",
        "3/4+Y,3/4+X,1/4-Z",
        "1/4-Y,3/4-X,3/4-Z",
        "1/4+Y,1/4-X,1/4+Z",
        "3/4-Y,1/4+X,3/4+Z",
        "3/4+X,3/4+Z,1/4-Y",
        "3/4-X,1/4+Z,3/4+Y",
        "1/4-X,3/4-Z,3/4-Y",
        "1/4+X,1/4-Z,1/4+Y",
        "3/4+Z,3/4+Y,1/4-X",
        "1/4+Z,1/4-Y,1/4+X",
        "3/4-Z,1/4+Y,3/4+X",
        "1/4-Z,3/4-Y,3/4-X",
        "1/4-X,3/4-Y,3/4-Z",
        "1/4+X,1/4+Y,1/4-Z",
        "3/4+X,1/4-Y,3/4+Z",
        "3/4-X,3/4+Y,1/4+Z",
        "1/4-Z,3/4-X,3/4-Y",
        "3/4-Z,3/4+X,1/4+Y",
        "1/4+Z,1/4+X,1/4-Y",
        "3/4+Z,1/4-X,3/4+Y",
        "1/4-Y,3/4-Z,3/4-X",
        "3/4+Y,1/4-Z,3/4+X",
        "3/4-Y,3/4+Z,1/4+X",
        "1/4+Y,1/4+Z,1/4-X",
        "1/2-Y,1/2-X,Z",
        "Y,1/2+X,1/2+Z",
        "-Y,X,-Z",
        "1/2+Y,-X,1/2-Z",
        "1/2-X,1/2-Z,Y",
        "1/2+X,-Z,1/2-Y",
        "X,1/2+Z,1/2+Y",
        "-X,Z,-Y",
        "1/2-Z,1/2-Y,X",
        "-Z,Y,-X",
        "1/2+Z,-Y,1/2-X",
        "Z,1/2+Y,1/2+X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,1/2-Y,Z",
        "-X,1/2+Y,1/2-Z",
        "X,-Y,-Z",
        "1/2+Z,X,1/2+Y",
        "Z,-X,-Y",
        "1/2-Z,1/2-X,Y",
        "-Z,1/2+X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/4+Y,1/4+X,1/4-Z",
        "3/4-Y,1/4-X,3/4-Z",
        "3/4+Y,3/4-X,1/4+Z",
        "1/4-Y,3/4+X,3/4+Z",
        "1/4+X,1/4+Z,1/4-Y",
        "1/4-X,3/4+Z,3/4+Y",
        "3/4-X,1/4-Z,3/4-Y",
        "3/4+X,3/4-Z,1/4+Y",
        "1/4+Z,1/4+Y,1/4-X",
        "3/4+Z,3/4-Y,1/4+X",
        "1/4-Z,3/4+Y,3/4+X",
        "3/4-Z,1/4-Y,3/4-X",
        "3/4-X,1/4-Y,3/4-Z",
        "3/4+X,3/4+Y,1/4-Z",
        "1/4+X,3/4-Y,3/4+Z",
        "1/4-X,1/4+Y,1/4+Z",
        "3/4-Z,1/4-X,3/4-Y",
        "1/4-Z,1/4+X,1/4+Y",
        "3/4+Z,3/4+X,1/4-Y",
        "1/4+Z,3/4-X,3/4+Y",
        "3/4-Y,1/4-Z,3/4-X",
        "1/4+Y,3/4-Z,3/4+X",
        "1/4-Y,1/4+Z,1/4+X",
        "3/4+Y,3/4+Z,1/4-X",
        "-Y,-X,Z",
        "1/2+Y,X,1/2+Z",
        "1/2-Y,1/2+X,-Z",
        "Y,1/2-X,1/2-Z",
        "-X,-Z,Y",
        "X,1/2-Z,1/2-Y",
        "1/2+X,Z,1/2+Y",
        "1/2-X,1/2+Z,-Y",
        "-Z,-Y,X",
        "1/2-Z,1/2+Y,-X",
        "Z,1/2-Y,1/2-X",
        "1/2+Z,Y,1/2+X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,Y,-Z",
        "X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,Y",
        "Z,1/2-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,X,-Y",
        "1/2+Y,1/2+Z,X",
        "-Y,Z,-X",
        "Y,1/2-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/4+Y,3/4+X,3/4-Z",
        "3/4-Y,3/4-X,1/4-Z",
        "3/4+Y,1/4-X,3/4+Z",
        "1/4-Y,1/4+X,1/4+Z",
        "1/4+X,3/4+Z,3/4-Y",
        "1/4-X,1/4+Z,1/4+Y",
        "3/4-X,3/4-Z,1/4-Y",
        "3/4+X,1/4-Z,3/4+Y",
        "1/4+Z,3/4+Y,3/4-X",
        "3/4+Z,1/4-Y,3/4+X",
        "1/4-Z,1/4+Y,1/4+X",
        "3/4-Z,3/4-Y,1/4-X",
        "3/4-X,3/4-Y,1/4-Z",
        "3/4+X,1/4+Y,3/4-Z",
        "1/4+X,1/4-Y,1/4+Z",
        "1/4-X,3/4+Y,3/4+Z",
        "3/4-Z,3/4-X,1/4-Y",
        "1/4-Z,3/4+X,3/4+Y",
        "3/4+Z,1/4+X,3/4-Y",
        "1/4+Z,1/4-X,1/4+Y",
        "3/4-Y,3/4-Z,1/4-X",
        "1/4+Y,1/4-Z,1/4+X",
        "1/4-Y,3/4+Z,3/4+X",
        "3/4+Y,1/4+Z,3/4-X",
        "-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,Z",
        "1/2-Y,X,1/2-Z",
        "Y,-X,-Z",
        "-X,1/2-Z,1/2+Y",
        "X,-Z,-Y",
        "1/2+X,1/2+Z,Y",
        "1/2-X,Z,1/2-Y",
        "-Z,1/2-Y,1/2+X",
        "1/2-Z,Y,1/2-X",
        "Z,-Y,-X",
        "1/2+Z,1/2+Y,X"
    ],
    "F 41/d -3 2/c": [
        "X,Y,Z",
        "-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,-Z",
        "1/2+X,-Y,1/2-Z",
        "Z,X,Y",
        "1/2+Z,-X,1/2-Y",
        "-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,-Y",
        "Y,Z,X",
        "1/2-Y,1/2+Z,-X",
        "1/2+Y,-Z,1/2-X",
        "-Y,1/2-Z,1/2+X",
        "3/4+Y,1/4+X,3/4-Z",
        "1/4-Y,1/4-X,1/4-Z",
        "1/4+Y,3/4-X,3/4+Z",
        "3/4-Y,3/4+X,1/4+Z",
        "3/4+X,1/4+Z,3/4-Y",
        "3/4-X,3/4+Z,1/4+Y",
        "1/4-X,1/4-Z,1/4-Y",
        "1/4+X,3/4-Z,3/4+Y",
        "3/4+Z,1/4+Y,3/4-X",
        "1/4+Z,3/4-Y,3/4+X",
        "3/4-Z,3/4+Y,1/4+X",
        "1/4-Z,1/4-Y,1/4-X",
        "3/4-X,3/4-Y,3/4-Z",
        "3/4+X,1/4+Y,1/4-Z",
        "1/4+X,1/4-Y,3/4+Z",
        "1/4-X,3/4+Y,1/4+Z",
        "3/4-Z,3/4-X,3/4-Y",
        "1/4-Z,3/4+X,1/4+Y",
        "3/4+Z,1/4+X,1/4-Y",
        "1/4+Z,1/4-X,3/4+Y",
        "3/4-Y,3/4-Z,3/4-X",
        "1/4+Y,1/4-Z,3/4+X",
        "1/4-Y,3/4+Z,1/4+X",
        "3/4+Y,1/4+Z,1/4-X",
        "-Y,1/2-X,Z",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,X,-Z",
        "Y,-X,1/2-Z",
        "-X,1/2-Z,Y",
        "X,-Z,1/2-Y",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,Z,-Y",
        "-Z,1/2-Y,X",
        "1/2-Z,Y,-X",
        "Z,-Y,1/2-X",
        "1/2+Z,1/2+Y,1/2+X",
        "X,1/2+Y,1/2+Z",
        "-X,-Y,Z",
        "1/2-X,Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,-Y",
        "-Z,-X,Y",
        "1/2-Z,X,1/2-Y",
        "Y,1/2+Z,1/2+X",
        "1/2-Y,Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "-Y,-Z,X",
        "3/4+Y,3/4+X,1/4-Z",
        "1/4-Y,3/4-X,3/4-Z",
        "1/4+Y,1/4-X,1/4+Z",
        "3/4-Y,1/4+X,3/4+Z",
        "3/4+X,3/4+Z,1/4-Y",
        "3/4-X,1/4+Z,3/4+Y",
        "1/4-X,3/4-Z,3/4-Y",
        "1/4+X,1/4-Z,1/4+Y",
        "3/4+Z,3/4+Y,1/4-X",
        "1/4+Z,1/4-Y,1/4+X",
        "3/4-Z,1/4+Y,3/4+X",
        "1/4-Z,3/4-Y,3/4-X",
        "3/4-X,1/4-Y,1/4-Z",
        "3/4+X,3/4+Y,3/4-Z",
        "1/4+X,3/4-Y,1/4+Z",
        "1/4-X,1/4+Y,3/4+Z",
        "3/4-Z,1/4-X,1/4-Y",
        "1/4-Z,1/4+X,3/4+Y",
        "3/4+Z,3/4+X,3/4-Y",
        "1/4+Z,3/4-X,1/4+Y",
        "3/4-Y,1/4-Z,1/4-X",
        "1/4+Y,3/4-Z,1/4+X",
        "1/4-Y,1/4+Z,3/4+X",
        "3/4+Y,3/4+Z,3/4-X",
        "-Y,-X,1/2+Z",
        "1/2+Y,X,Z",
        "1/2-Y,1/2+X,1/2-Z",
        "Y,1/2-X,-Z",
        "-X,-Z,1/2+Y",
        "X,1/2-Z,-Y",
        "1/2+X,Z,Y",
        "1/2-X,1/2+Z,1/2-Y",
        "-Z,-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2-X",
        "Z,1/2-Y,-X",
        "1/2+Z,Y,X",
        "1/2+X,Y,1/2+Z",
        "1/2-X,1/2-Y,Z",
        "-X,1/2+Y,1/2-Z",
        "X,-Y,-Z",
        "1/2+Z,X,1/2+Y",
        "Z,-X,-Y",
        "1/2-Z,1/2-X,Y",
        "-Z,1/2+X,1/2-Y",
        "1/2+Y,Z,1/2+X",
        "-Y,1/2+Z,1/2-X",
        "Y,-Z,-X",
        "1/2-Y,1/2-Z,X",
        "1/4+Y,1/4+X,1/4-Z",
        "3/4-Y,1/4-X,3/4-Z",
        "3/4+Y,3/4-X,1/4+Z",
        "1/4-Y,3/4+X,3/4+Z",
        "1/4+X,1/4+Z,1/4-Y",
        "1/4-X,3/4+Z,3/4+Y",
        "3/4-X,1/4-Z,3/4-Y",
        "3/4+X,3/4-Z,1/4+Y",
        "1/4+Z,1/4+Y,1/4-X",
        "3/4+Z,3/4-Y,1/4+X",
        "1/4-Z,3/4+Y,3/4+X",
        "3/4-Z,1/4-Y,3/4-X",
        "1/4-X,3/4-Y,1/4-Z",
        "1/4+X,1/4+Y,3/4-Z",
        "3/4+X,1/4-Y,1/4+Z",
        "3/4-X,3/4+Y,3/4+Z",
        "1/4-Z,3/4-X,1/4-Y",
        "3/4-Z,3/4+X,3/4+Y",
        "1/4+Z,1/4+X,3/4-Y",
        "3/4+Z,1/4-X,1/4+Y",
        "1/4-Y,3/4-Z,1/4-X",
        "3/4+Y,1/4-Z,1/4+X",
        "3/4-Y,3/4+Z,3/4+X",
        "1/4+Y,1/4+Z,3/4-X",
        "1/2-Y,1/2-X,1/2+Z",
        "Y,1/2+X,Z",
        "-Y,X,1/2-Z",
        "1/2+Y,-X,-Z",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,-Z,-Y",
        "X,1/2+Z,Y",
        "-X,Z,1/2-Y",
        "1/2-Z,1/2-Y,1/2+X",
        "-Z,Y,1/2-X",
        "1/2+Z,-Y,-X",
        "Z,1/2+Y,X",
        "1/2+X,1/2+Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,Y,-Z",
        "X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,Y",
        "Z,1/2-X,1/2-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,X,-Y",
        "1/2+Y,1/2+Z,X",
        "-Y,Z,-X",
        "Y,1/2-Z,1/2-X",
        "1/2-Y,-Z,1/2+X",
        "1/4+Y,3/4+X,3/4-Z",
        "3/4-Y,3/4-X,1/4-Z",
        "3/4+Y,1/4-X,3/4+Z",
        "1/4-Y,1/4+X,1/4+Z",
        "1/4+X,3/4+Z,3/4-Y",
        "1/4-X,1/4+Z,1/4+Y",
        "3/4-X,3/4-Z,1/4-Y",
        "3/4+X,1/4-Z,3/4+Y",
        "1/4+Z,3/4+Y,3/4-X",
        "3/4+Z,1/4-Y,3/4+X",
        "1/4-Z,1/4+Y,1/4+X",
        "3/4-Z,3/4-Y,1/4-X",
        "1/4-X,1/4-Y,3/4-Z",
        "1/4+X,3/4+Y,1/4-Z",
        "3/4+X,3/4-Y,3/4+Z",
        "3/4-X,1/4+Y,1/4+Z",
        "1/4-Z,1/4-X,3/4-Y",
        "3/4-Z,1/4+X,1/4+Y",
        "1/4+Z,3/4+X,1/4-Y",
        "3/4+Z,3/4-X,3/4+Y",
        "1/4-Y,1/4-Z,3/4-X",
        "3/4+Y,3/4-Z,3/4+X",
        "3/4-Y,1/4+Z,1/4+X",
        "1/4+Y,3/4+Z,1/4-X",
        "1/2-Y,-X,Z",
        "Y,X,1/2+Z",
        "-Y,1/2+X,-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-X,-Z,Y",
        "1/2+X,1/2-Z,1/2-Y",
        "X,Z,1/2+Y",
        "-X,1/2+Z,-Y",
        "1/2-Z,-Y,X",
        "-Z,1/2+Y,-X",
        "1/2+Z,1/2-Y,1/2-X",
        "Z,Y,1/2+X"
    ],
    "I 4/m -3 2/m": [
        "X,Y,Z",
        "-X,-Y,Z",
        "-X,Y,-Z",
        "X,-Y,-Z",
        "Z,X,Y",
        "Z,-X,-Y",
        "-Z,-X,Y",
        "-Z,X,-Y",
        "Y,Z,X",
        "-Y,Z,-X",
        "Y,-Z,-X",
        "-Y,-Z,X",
        "Y,X,-Z",
        "-Y,-X,-Z",
        "Y,-X,Z",
        "-Y,X,Z",
        "X,Z,-Y",
        "-X,Z,Y",
        "-X,-Z,-Y",
        "X,-Z,Y",
        "Z,Y,-X",
        "Z,-Y,X",
        "-Z,Y,X",
        "-Z,-Y,-X",
        "-X,-Y,-Z",
        "X,Y,-Z",
        "X,-Y,Z",
        "-X,Y,Z",
        "-Z,-X,-Y",
        "-Z,X,Y",
        "Z,X,-Y",
        "Z,-X,Y",
        "-Y,-Z,-X",
        "Y,-Z,X",
        "-Y,Z,X",
        "Y,Z,-X",
        "-Y,-X,Z",
        "Y,X,Z",
        "-Y,X,-Z",
        "Y,-X,-Z",
        "-X,-Z,Y",
        "X,-Z,-Y",
        "X,Z,Y",
        "-X,Z,-Y",
        "-Z,-Y,X",
        "-Z,Y,-X",
        "Z,-Y,-X",
        "Z,Y,X",
        "1/2+X,1/2+Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "1/2+Z,1/2-X,1/2-Y",
        "1/2-Z,1/2-X,1/2+Y",
        "1/2-Z,1/2+X,1/2-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,1/2-X",
        "1/2-Y,1/2-Z,1/2+X",
        "1/2+Y,1/2+X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z",
        "1/2+Y,1/2-X,1/2+Z",
        "1/2-Y,1/2+X,1/2+Z",
        "1/2+X,1/2+Z,1/2-Y",
        "1/2-X,1/2+Z,1/2+Y",
        "1/2-X,1/2-Z,1/2-Y",
        "1/2+X,1/2-Z,1/2+Y",
        "1/2+Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2+X",
        "1/2-Z,1/2-Y,1/2-X",
        "1/2-X,1/2-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "1/2-Z,1/2+X,1/2+Y",
        "1/2+Z,1/2+X,1/2-Y",
        "1/2+Z,1/2-X,1/2+Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,1/2+X",
        "1/2+Y,1/2+Z,1/2-X",
        "1/2-Y,1/2-X,1/2+Z",
        "1/2+Y,1/2+X,1/2+Z",
        "1/2-Y,1/2+X,1/2-Z",
        "1/2+Y,1/2-X,1/2-Z",
        "1/2-X,1/2-Z,1/2+Y",
        "1/2+X,1/2-Z,1/2-Y",
        "1/2+X,1/2+Z,1/2+Y",
        "1/2-X,1/2+Z,1/2-Y",
        "1/2-Z,1/2-Y,1/2+X",
        "1/2-Z,1/2+Y,1/2-X",
        "1/2+Z,1/2-Y,1/2-X",
        "1/2+Z,1/2+Y,1/2+X"
    ],
    "I 41/a -3 2/d": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2-Y,-Z",
        "Z,X,Y",
        "1/2+Z,1/2-X,-Y",
        "1/2-Z,-X,1/2+Y",
        "-Z,1/2+X,1/2-Y",
        "Y,Z,X",
        "-Y,1/2+Z,1/2-X",
        "1/2+Y,1/2-Z,-X",
        "1/2-Y,-Z,1/2+X",
        "3/4+Y,1/4+X,1/4-Z",
        "3/4-Y,3/4-X,3/4-Z",
        "1/4+Y,1/4-X,3/4+Z",
        "1/4-Y,3/4+X,1/4+Z",
        "3/4+X,1/4+Z,1/4-Y",
        "1/4-X,3/4+Z,1/4+Y",
        "3/4-X,3/4-Z,3/4-Y",
        "1/4+X,1/4-Z,3/4+Y",
        "3/4+Z,1/4+Y,1/4-X",
        "1/4+Z,1/4-Y,3/4+X",
        "1/4-Z,3/4+Y,1/4+X",
        "3/4-Z,3/4-Y,3/4-X",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2-Z",
        "X,1/2-Y,1/2+Z",
        "1/2-X,1/2+Y,Z",
        "-Z,-X,-Y",
        "1/2-Z,1/2+X,Y",
        "1/2+Z,X,1/2-Y",
        "Z,1/2-X,1/2+Y",
        "-Y,-Z,-X",
        "Y,1/2-Z,1/2+X",
        "1/2-Y,1/2+Z,X",
        "1/2+Y,Z,1/2-X",
        "1/4-Y,3/4-X,3/4+Z",
        "1/4+Y,1/4+X,1/4+Z",
        "3/4-Y,3/4+X,1/4-Z",
        "3/4+Y,1/4-X,3/4-Z",
        "1/4-X,3/4-Z,3/4+Y",
        "3/4+X,1/4-Z,3/4-Y",
        "1/4+X,1/4+Z,1/4+Y",
        "3/4-X,3/4+Z,1/4-Y",
        "1/4-Z,3/4-Y,3/4+X",
        "3/4-Z,3/4+Y,1/4-X",
        "3/4+Z,1/4-Y,3/4-X",
        "1/4+Z,1/4+Y,1/4+X",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,1/2-Y,Z",
        "1/2-X,Y,-Z",
        "X,-Y,1/2-Z",
        "1/2+Z,1/2+X,1/2+Y",
        "Z,-X,1/2-Y",
        "-Z,1/2-X,Y",
        "1/2-Z,X,-Y",
        "1/2+Y,1/2+Z,1/2+X",
        "1/2-Y,Z,-X",
        "Y,-Z,1/2-X",
        "-Y,1/2-Z,X",
        "1/4+Y,3/4+X,3/4-Z",
        "1/4-Y,1/4-X,1/4-Z",
        "3/4+Y,3/4-X,1/4+Z",
        "3/4-Y,1/4+X,3/4+Z",
        "1/4+X,3/4+Z,3/4-Y",
        "3/4-X,1/4+Z,3/4+Y",
        "1/4-X,1/4-Z,1/4-Y",
        "3/4+X,3/4-Z,1/4+Y",
        "1/4+Z,3/4+Y,3/4-X",
        "3/4+Z,3/4-Y,1/4+X",
        "3/4-Z,1/4+Y,3/4+X",
        "1/4-Z,1/4-Y,1/4-X",
        "1/2-X,1/2-Y,1/2-Z",
        "X,1/2+Y,-Z",
        "1/2+X,-Y,Z",
        "-X,Y,1/2+Z",
        "1/2-Z,1/2-X,1/2-Y",
        "-Z,X,1/2+Y",
        "Z,1/2+X,-Y",
        "1/2+Z,-X,Y",
        "1/2-Y,1/2-Z,1/2-X",
        "1/2+Y,-Z,X",
        "-Y,Z,1/2+X",
        "Y,1/2+Z,-X",
        "3/4-Y,1/4-X,1/4+Z",
        "3/4+Y,3/4+X,3/4+Z",
        "1/4-Y,1/4+X,3/4-Z",
        "1/4+Y,3/4-X,1/4-Z",
        "3/4-X,1/4-Z,1/4+Y",
        "1/4+X,3/4-Z,1/4-Y",
        "3/4+X,3/4+Z,3/4+Y",
        "1/4-X,1/4+Z,3/4-Y",
        "3/4-Z,1/4-Y,1/4+X",
        "1/4-Z,1/4+Y,3/4-X",
        "1/4+Z,3/4-Y,1/4-X",
        "3/4+Z,3/4+Y,3/4+X"
    ],
    "P 1 1 2": [
        "X,Y,Z",
        "-X,-Y,Z"
    ],
    "P 1 1 21": [
        "X,Y,Z",
        "-X,-Y,1/2+Z"
    ],
    "B 1 1 2": [
        "X,Y,Z",
        "-X,-Y,Z",
        "1/2+X,+Y,1/2+Z",
        "1/2-X,-Y,1/2+Z"
    ],
    "A 1 2 1": [
        "X,Y,Z",
        "-X,Y,-Z",
        "X,1/2+Y,1/2+Z",
        "-X,1/2+Y,1/2-Z"
    ],
    "C 1 21 1": [
        "X,Y,Z",
        "-X,1/2+Y,-Z",
        "1/2+X,1/2+Y,Z",
        "1/2-X,Y,-Z"
    ],
    "I 1 2 1": [
        "X,Y,Z",
        "-X,Y,-Z",
        "X+1/2,Y+1/2,Z+1/2",
        "-X+1/2,Y+1/2,-Z+1/2"
    ],
    "I 1 21 1": [
        "X,Y,Z",
        "-X,1/2+Y,-Z",
        "X+1/2,Y+1/2,Z+1/2",
        "-X+1/2,Y,1/2-Z"
    ],
    "P 1 1 m": [
        "X,Y,Z",
        "X,Y,-Z"
    ],
    "P 1 1 b": [
        "X,Y,Z",
        "X,1/2+Y,-Z"
    ],
    "B 1 1 m": [
        "X,Y,Z",
        "X,Y,-Z",
        "1/2+X,Y,1/2+Z",
        "1/2+X,Y,1/2-Z"
    ],
    "B 1 1 b": [
        "X,Y,Z",
        "X,1/2+Y,-Z",
        "1/2+X,Y,1/2+Z",
        "1/2+X,1/2+Y,1/2-Z"
    ],
    "P 1 1 2/m": [
        "X,Y,Z",
        "X,Y,-Z",
        "-X,-Y,Z",
        "-X,-Y,-Z"
    ],
    "P 1 1 21/m": [
        "X,Y,Z",
        "-X,-Y,1/2+Z",
        "-X,-Y,-Z",
        "X,Y,1/2-Z"
    ],
    "B 1 1 2/m": [
        "X,Y,Z",
        "X,Y,-Z",
        "-X,-Y,Z",
        "-X,-Y,-Z",
        "1/2+X,Y,1/2+Z",
        "1/2+X,Y,1/2-Z",
        "1/2-X,-Y,1/2+Z",
        "1/2-X,-Y,1/2-Z"
    ],
    "P 1 1 2/b": [
        "X,Y,Z",
        "-X,1/2-Y,Z",
        "-X,-Y,-Z",
        "X,1/2+Y,-Z"
    ],
    "P 1 1 21/b": [
        "X,Y,Z",
        "-X,-Y,-Z",
        "-X,1/2-Y,1/2+Z",
        "X,1/2+Y,1/2-Z"
    ],
    "B 1 1 2/b": [
        "X,Y,Z",
        "-X,1/2-Y,Z",
        "-X,-Y,-Z",
        "X,1/2+Y,-Z",
        "1/2+X,Y,1/2+Z",
        "1/2-X,1/2-Y,1/2+Z",
        "1/2-X,-Y,1/2-Z",
        "1/2+X,1/2+Y,1/2-Z"
    ],
    "P 21 2 2": [
        "X,Y,Z",
        "-X,Y,-Z",
        "1/2+X,-Y,-Z",
        "1/2-X,-Y,Z"
    ],
    "P 2 21 2": [
        "X,Y,Z",
        "X,1/2-Y,-Z",
        "-X,1/2+Y,-Z",
        "-X,-Y,Z"
    ],
    "P 21 21 2 (a)": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "X+1/2,-Y,-Z",
        "-X,Y+1/2,-Z"
    ],
    "P 21 2 21": [
        "X,Y,Z",
        "-X,Y,-Z",
        "1/2+X,-Y,1/2-Z",
        "1/2-X,-Y,1/2+Z"
    ],
    "P 2 21 21": [
        "X,Y,Z",
        "X,-Y,-Z",
        "-X,1/2+Y,1/2-Z",
        "-X,1/2-Y,1/2+Z"
    ],
    "C 2 2 21a)": [
        "X,Y,Z",
        "1/2-X,-Y,1/2+Z",
        "1/2+X,1/2-Y,-Z",
        "-X,1/2+Y,1/2-Z",
        "1/2+X,1/2+Y,Z",
        "-X,1/2-Y,1/2+Z",
        "X,-Y,-Z",
        "1/2-X,Y,1/2-Z"
    ],
    "C 2 2 2a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "X+1/2,-Y,-Z",
        "-X,Y+1/2,-Z",
        "1/2+ X,1/2+Y,Z",
        "-X,-Y,Z",
        "X,1/2-Y,-Z",
        "1/2-X,Y,-Z"
    ],
    "F 2 2 2a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "X+1/2,-Y,-Z",
        "-X,Y+1/2,-Z",
        "X,Y+1/2,Z+1/2",
        "1/2-X,-Y,Z+1/2",
        "X+1/2,-Y+1/2,-Z+1/2",
        "-X,Y,-Z+1/2",
        "X+1/2,Y,Z+1/2",
        "-X,1/2-Y,Z+1/2",
        "X,-Y,-Z+1/2",
        "-X+1/2,Y+1/2,-Z+1/2",
        "X+1/2,Y+1/2,Z",
        "-X,-Y,Z",
        "X,-Y+1/2,-Z",
        "-X+1/2,Y,-Z"
    ],
    "I 2 2 2a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "X+1/2,-Y,-Z",
        "-X,Y+1/2,-Z",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,1/2+Z",
        "1/2-X,Y,1/2-Z",
        "X,1/2-Y,1/2-Z"
    ],
    "P 21/m 21/m 2/n a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "-X,1/2+Y,-Z",
        "1/2+X,-Y,-Z",
        "-X,-Y,-Z",
        "X+1/2,Y+1/2,-Z",
        "X,1/2-Y,Z",
        "1/2-X,Y,Z"
    ],
    "P 42 21 2a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "-Y,X+1/2,1/2+Z",
        "Y+1/2,-X,1/2+Z",
        "-X,Y+1/2,-Z",
        "X+1/2,-Y,-Z",
        "Y,X,1/2-Z",
        "1/2-Y,1/2-X,1/2-Z"
    ],
    "I 2 3a": [
        "X,Y,Z",
        "1/2-X,1/2-Y,Z",
        "X+1/2,-Y,-Z",
        "-X,Y+1/2,-Z",
        "Y,Z,X",
        "1/2-Y,1/2-Z,X",
        "Y+1/2,-Z,-X",
        "-Y,Z+1/2,-X",
        "Z,X,Y",
        "1/2-Z,1/2-X,Y",
        "Z+1/2,-X,-Y",
        "-Z,X+1/2,-Y",
        "1/2+X,1/2+Y,1/2+Z",
        "-X,-Y,1/2+Z",
        "X,1/2-Y,1/2-Z",
        "1/2-X,Y,1/2-Z",
        "1/2+Y,1/2+Z,1/2+X",
        "-Y,-Z,1/2+X",
        "Y,1/2-Z,1/2-X",
        "1/2-Y,Z,1/2-X",
        "1/2+Z,1/2+X,1/2+Y",
        "-Z,-X,1/2+Y",
        "Z,1/2-X,1/2-Y",
        "1/2-Z,X,1/2-Y"
    ]
};

// File:js/ngl/alignment.js

/**
 * @file Alignment
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


//////////////
// Alignment

NGL.SubstitutionMatrices = function(){

    var blosum62x = [
        [4,0,-2,-1,-2,0,-2,-1,-1,-1,-1,-2,-1,-1,-1,1,0,0,-3,-2],        // A
        [0,9,-3,-4,-2,-3,-3,-1,-3,-1,-1,-3,-3,-3,-3,-1,-1,-1,-2,-2],    // C
        [-2,-3,6,2,-3,-1,-1,-3,-1,-4,-3,1,-1,0,-2,0,-1,-3,-4,-3],       // D
        [-1,-4,2,5,-3,-2,0,-3,1,-3,-2,0,-1,2,0,0,-1,-2,-3,-2],          // E
        [-2,-2,-3,-3,6,-3,-1,0,-3,0,0,-3,-4,-3,-3,-2,-2,-1,1,3],        // F
        [0,-3,-1,-2,-3,6,-2,-4,-2,-4,-3,0,-2,-2,-2,0,-2,-3,-2,-3],      // G
        [-2,-3,-1,0,-1,-2,8,-3,-1,-3,-2,1,-2,0,0,-1,-2,-3,-2,2],        // H
        [-1,-1,-3,-3,0,-4,-3,4,-3,2,1,-3,-3,-3,-3,-2,-1,3,-3,-1],       // I
        [-1,-3,-1,1,-3,-2,-1,-3,5,-2,-1,0,-1,1,2,0,-1,-2,-3,-2],        // K
        [-1,-1,-4,-3,0,-4,-3,2,-2,4,2,-3,-3,-2,-2,-2,-1,1,-2,-1],       // L
        [-1,-1,-3,-2,0,-3,-2,1,-1,2,5,-2,-2,0,-1,-1,-1,1,-1,-1],        // M
        [-2,-3,1,0,-3,0,1,-3,0,-3,-2,6,-2,0,0,1,0,-3,-4,-2],            // N
        [-1,-3,-1,-1,-4,-2,-2,-3,-1,-3,-2,-2,7,-1,-2,-1,-1,-2,-4,-3],   // P
        [-1,-3,0,2,-3,-2,0,-3,1,-2,0,0,-1,5,1,0,-1,-2,-2,-1],           // Q
        [-1,-3,-2,0,-3,-2,0,-3,2,-2,-1,0,-2,1,5,-1,-1,-3,-3,-2],        // R
        [1,-1,0,0,-2,0,-1,-2,0,-2,-1,1,-1,0,-1,4,1,-2,-3,-2],           // S
        [0,-1,-1,-1,-2,-2,-2,-1,-1,-1,-1,0,-1,-1,-1,1,5,0,-2,-2],       // T
        [0,-1,-3,-2,-1,-3,-3,3,-2,1,1,-3,-2,-2,-3,-2,0,4,-3,-1],        // V
        [-3,-2,-4,-3,1,-2,-2,-3,-3,-2,-1,-4,-4,-2,-3,-3,-2,-3,11,2],    // W
        [-2,-2,-3,-2,3,-3,2,-1,-2,-1,-1,-2,-3,-1,-2,-2,-2,-1,2,7]       // Y
    ];

    var blosum62 = [
        //A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V  B  Z  X
        [ 4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0,-2,-1, 0], // A
        [-1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3,-1, 0,-1], // R
        [-2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3, 3, 0,-1], // N
        [-2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3, 4, 1,-1], // D
        [ 0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-3,-2], // C
        [-1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2, 0, 3,-1], // Q
        [-1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2, 1, 4,-1], // E
        [ 0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3,-1,-2,-1], // G
        [-2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3, 0, 0,-1], // H
        [-1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3,-3,-3,-1], // I
        [-1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1,-4,-3,-1], // L
        [-1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2, 0, 1,-1], // K
        [-1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1,-3,-1,-1], // M
        [-2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1,-3,-3,-1], // F
        [-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2,-2,-1,-2], // P
        [ 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2, 0, 0, 0], // S
        [ 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0,-1,-1, 0], // T
        [-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3,-4,-3,-2], // W
        [-2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1,-3,-2,-1], // Y
        [ 0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4,-3,-2,-1], // V
        [-2,-1, 3, 4,-3, 0, 1,-1, 0,-3,-4, 0,-3,-3,-2, 0,-1,-4,-3,-3, 4, 1,-1], // B
        [-1, 0, 0, 1,-3, 3, 4,-2, 0,-3,-3, 1,-1,-3,-1, 0,-1,-3,-2,-2, 1, 4,-1], // Z
        [ 0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2, 0, 0,-2,-1,-1,-1,-1,-1]  // X
    ];

    var nucleotides = 'ACTG';

    var aminoacidsX = 'ACDEFGHIKLMNPQRSTVWY';

    var aminoacids = 'ARNDCQEGHILKMFPSTWYVBZ?';

    function prepareMatrix( cellNames, mat ){

        var j;
        var i = 0;
        var matDict = {};

        mat.forEach( function( row ){

            j = 0;
            var rowDict = {};

            row.forEach( function( elm ){

                rowDict[ cellNames[ j++ ] ] = elm;

            } );

            matDict[ cellNames[ i++ ] ] = rowDict;

        } );

        return matDict;

    }

    return {

        blosum62: prepareMatrix( aminoacids, blosum62 ),

        blosum62x: prepareMatrix( aminoacidsX, blosum62x ),

    };

}();


NGL.Alignment = function( seq1, seq2, gapPenalty, gapExtensionPenalty, substMatrix ){

    // TODO try encoding seqs as integers and use array subst matrix, maybe faster

    this.seq1 = seq1;
    this.seq2 = seq2;

    this.gapPenalty = gapPenalty || -10;
    this.gapExtensionPenalty = gapExtensionPenalty || -1;
    this.substMatrix = substMatrix || "blosum62";

    if( this.substMatrix ){
        this.substMatrix = NGL.SubstitutionMatrices[ this.substMatrix ];
    }

};

NGL.Alignment.prototype = {

    constructor: NGL.Alignment,

    initMatrices: function(){

        this.n = this.seq1.length;
        this.m = this.seq2.length;

        // NGL.log(this.n, this.m);

        this.score = undefined;
        this.ali = '';

        this.S = [];
        this.V = [];
        this.H = [];

        for( var i = 0; i <= this.n; ++i ){

            this.S[ i ] = [];
            this.V[ i ] = [];
            this.H[ i ] = [];

            for( var j = 0; j <= this.m; ++j ){

                this.S[ i ][ j ] = 0;
                this.V[ i ][ j ] = 0;
                this.H[ i ][ j ] = 0;

            }

        }

        for( var i = 0; i <= this.n; ++i ){

            this.S[ i ][ 0 ] = this.gap( 0 );
            this.H[ i ][ 0 ] = -Infinity;

        }

        for( var j = 0; j <= this.m; ++j ){

            this.S[ 0 ][ j ] = this.gap( 0 );
            this.V[ 0 ][ j ] = -Infinity;

        }

        this.S[ 0 ][ 0 ] = 0;

        // NGL.log(this.S, this.V, this.H);

    },

    gap: function( len ){

        return this.gapPenalty + len * this.gapExtensionPenalty;

    },

    makeScoreFn: function(){

        var seq1 = this.seq1;
        var seq2 = this.seq2;

        var substMatrix = this.substMatrix;

        var c1, c2;

        if( substMatrix ){

            return function( i, j ){

                c1 = seq1[ i ];
                c2 = seq2[ j ];

                try{

                    return substMatrix[ c1 ][ c2 ];

                }catch( e ){

                    return -4;

                }

            }

        } else {

            NGL.warn('NGL.Alignment: no subst matrix');

            return function( i, j ){

                c1 = seq1[ i ];
                c2 = seq2[ j ];

                return c1 === c2 ? 5 : -3;

            }

        }

    },

    calc: function(){

        NGL.time( "NGL.Alignment.calc" );

        this.initMatrices();

        var gap0 = this.gap(0);
        var scoreFn = this.makeScoreFn();
        var gapExtensionPenalty = this.gapExtensionPenalty;

        var V = this.V;
        var H = this.H;
        var S = this.S;

        var n = this.n;
        var m = this.m;

        var Vi1, Si1, Vi, Hi, Si;

        var i, j;

        for( i = 1; i <= n; ++i ){

            Si1 = S[ i - 1 ];
            Vi1 = V[ i - 1 ];

            Vi = V[ i ];
            Hi = H[ i ];
            Si = S[ i ];

            for( j = 1; j <= m; ++j ){

                Vi[j] = Math.max(
                    Si1[ j ] + gap0,
                    Vi1[ j ] + gapExtensionPenalty
                );

                Hi[j] = Math.max(
                    Si[ j - 1 ] + gap0,
                    Hi[ j - 1 ] + gapExtensionPenalty
                );

                Si[j] = Math.max(
                    Si1[ j - 1 ] + scoreFn( i - 1, j - 1 ), // match
                    Vi[ j ], //del
                    Hi[ j ]  // ins
                );

            }

        }

        NGL.timeEnd( "NGL.Alignment.calc" );

        // NGL.log(this.S, this.V, this.H);

    },

    trace: function(){

        // NGL.time( "NGL.Alignment.trace" );

        this.ali1 = '';
        this.ali2 = '';

        var scoreFn = this.makeScoreFn();

        var i = this.n;
        var j = this.m;
        var mat = "S";

        if( this.S[i][j] >= this.V[i][j] && this.S[i][j] >= this.V[i][j] ){
            mat = "S";
            this.score = this.S[i][j];
        }else if( this.V[i][j] >= this.H[i][j] ){
            mat = "V";
            this.score = this.V[i][j];
        }else{
            mat = "H";
            this.score = this.H[i][j];
        }

        // NGL.log("NGL.Alignment: SCORE", this.score);
        // NGL.log("NGL.Alignment: S, V, H", this.S[i][j], this.V[i][j], this.H[i][j]);

        while( i > 0 && j > 0 ){

            if( mat=="S" ){

                if( this.S[i][j]==this.S[i-1][j-1] + scoreFn(i-1, j-1) ){
                    this.ali1 = this.seq1[i-1] + this.ali1;
                    this.ali2 = this.seq2[j-1] + this.ali2;
                    --i;
                    --j;
                    mat = "S";
                }else if( this.S[i][j]==this.V[i][j] ){
                    mat = "V";
                }else if( this.S[i][j]==this.H[i][j] ){
                    mat = "H";
                }else{
                    NGL.error('NGL.Alignment: S');
                    --i;
                    --j;
                }

            }else if( mat=="V" ){

                if( this.V[i][j]==this.V[i-1][j] + this.gapExtensionPenalty ){
                    this.ali1 = this.seq1[i-1] + this.ali1;
                    this.ali2 = '-' + this.ali2;
                    --i;
                    mat = "V";
                }else if( this.V[i][j]==this.S[i-1][j] + this.gap(0) ){
                    this.ali1 = this.seq1[i-1] + this.ali1;
                    this.ali2 = '-' + this.ali2;
                    --i;
                    mat = "S";
                }else{
                    NGL.error('NGL.Alignment: V');
                    --i;
                }

            }else if( mat=="H" ){

                if( this.H[i][j] == this.H[i][j-1] + this.gapExtensionPenalty ){
                    this.ali1 = '-' + this.ali1;
                    this.ali2 = this.seq2[j-1] + this.ali2;
                    --j;
                    mat = "H";
                }else if( this.H[i][j] == this.S[i][j-1] + this.gap(0) ){
                    this.ali1 = '-' + this.ali1;
                    this.ali2 = this.seq2[j-1] + this.ali2;
                    --j;
                    mat = "S";
                }else{
                    NGL.error('NGL.Alignment: H');
                    --j;
                }

            }else{

                NGL.error('NGL.Alignment: no matrix');

            }

        }

        while( i > 0 ){

            this.ali1 = this.seq1[ i - 1 ] + this.ali1;
            this.ali2 = '-' + this.ali2;
            --i;

        }

        while( j > 0 ){

            this.ali1 = '-' + this.ali1;
            this.ali2 = this.seq2[ j - 1 ] + this.ali2;
            --j;

        }

        // NGL.timeEnd( "NGL.Alignment.trace" );

        // NGL.log([this.ali1, this.ali2]);

    }

};

// File:js/ngl/geometry.js

/**
 * @file Geometry
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


///////////
// Spline

NGL.Spline = function( fiber, arrows ){

    this.arrows = arrows || false;

    this.fiber = fiber;
    this.size = fiber.residueCount - 2;

    this.type = this.fiber.getType();
    this.tension = this.type === NGL.NucleicType ? 0.5 : 0.9;

};

NGL.Spline.prototype = {

    constructor: NGL.Spline,

    // from THREE.js
    // ASR added tension
    interpolate: function( p0, p1, p2, p3, t, tension ) {

        var v0 = ( p2 - p0 ) * tension;
        var v1 = ( p3 - p1 ) * tension;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 +
               ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 +
               v0 * t + p1;

    },

    getSubdividedColor: function( m, params ){

        var n = this.size;
        var n1 = n - 1;

        var col = new Float32Array( n1 * m * 3 + 3 );
        var pcol = new Float32Array( n1 * m * 3 + 3 );

        var p = params || {};
        p.structure = this.fiber.structure;

        var colorMaker = NGL.ColorMakerRegistry.getScheme( p );
        var pickingColorMaker = NGL.ColorMakerRegistry.getPickingScheme( p );

        var k = 0;
        var j, l, mh, a2, c2, pc2, a3, c3, pc3;

        this.fiber.eachAtomN( 4, function( a1, a2, a3, a4 ){

            mh = Math.ceil( m / 2 );

            for( j = 0; j < mh; ++j ){

                l = k + j * 3;

                colorMaker.atomColorToArray( a2, col, l );
                pickingColorMaker.atomColorToArray( a2, pcol, l );

            }

            for( j = mh; j < m; ++j ){

                l = k + j * 3;

                colorMaker.atomColorToArray( a3, col, l );
                pickingColorMaker.atomColorToArray( a3, pcol, l );

            }

            k += 3 * m;

        }, "trace" );

        col[ n1 * m * 3 + 0 ] = col[ n1 * m * 3 - 3 ];
        col[ n1 * m * 3 + 1 ] = col[ n1 * m * 3 - 2 ];
        col[ n1 * m * 3 + 2 ] = col[ n1 * m * 3 - 1 ];

        pcol[ n1 * m * 3 + 0 ] = pcol[ n1 * m * 3 - 3 ];
        pcol[ n1 * m * 3 + 1 ] = pcol[ n1 * m * 3 - 2 ];
        pcol[ n1 * m * 3 + 2 ] = pcol[ n1 * m * 3 - 1 ];

        return {
            "color": col,
            "pickingColor": pcol
        };

    },

    getSubdividedPosition: function( m, tension ){

        if( isNaN( tension ) ) tension = this.tension;

        var pos = this.getPosition( m, tension );

        return {
            "position": pos
        }

    },

    getSubdividedOrientation: function( m, tension ){

        if( isNaN( tension ) ) tension = this.tension;

        var tan = this.getTangent( m, tension );
        var normals = this.getNormals( m, tension, tan );

        return {
            "tangent": tan,
            "normal": normals.normal,
            "binormal": normals.binormal
        }

    },

    getSubdividedSize: function( m, type, scale ){

        var n = this.size;
        var n1 = n - 1;
        var arrows = this.arrows;

        var size = new Float32Array( n1 * m + 1 );

        var radiusFactory = new NGL.RadiusFactory( type, scale );

        var k = 0;
        var j, l, a2, a3, s2, s3, t;

        this.fiber.eachAtomN( 4, function( a1, a2, a3, a4 ){

            s2 = radiusFactory.atomRadius( a2 );
            s3 = radiusFactory.atomRadius( a3 );

            if( arrows && (
                    ( a2.ss==="s" && a3.ss!=="s" ) ||
                    ( a2.ss==="h" && a3.ss!=="h" ) ||
                    ( a2.ss==="g" && a3.ss!=="g" ) ||
                    ( a2.ss==="i" && a3.ss!=="i" )
                )
            ){

                s2 *= 1.7;
                var m2 = Math.ceil( m / 2 );

                for( j = 0; j < m2; ++j ){

                    // linear interpolation
                    t = j / m2;
                    size[ k + j ] = ( 1 - t ) * s2 + t * s3;

                }

                for( j = m2; j < m; ++j ){

                    size[ k + j ] = s3;

                }

            }else{

                for( j = 0; j < m; ++j ){

                    // linear interpolation
                    t = j / m;
                    size[ k + j ] = ( 1 - t ) * s2 + t * s3;

                }

            }

            k += m;

        }, "trace" );

        size[ k ] = size[ k - 1 ];

        return {
            "size": size
        };

    },

    getPosition: function( m, tension, atomname ){

        if( isNaN( tension ) ) tension = this.tension;

        var interpolate = this.interpolate;

        var n = this.size;
        var n1 = n - 1;

        var pos = new Float32Array( n1 * m * 3 + 3 );

        var k = 0;
        var dt = 1.0 / m;

        var j, l, d;
        var _a3;

        this.fiber.eachAtomN( 4, function( a1, a2, a3, a4 ){

            _a3 = a3;

            for( j = 0; j < m; ++j ){

                d = dt * j
                l = k + j * 3;

                pos[ l + 0 ] = interpolate( a1.x, a2.x, a3.x, a4.x, d, tension );
                pos[ l + 1 ] = interpolate( a1.y, a2.y, a3.y, a4.y, d, tension );
                pos[ l + 2 ] = interpolate( a1.z, a2.z, a3.z, a4.z, d, tension );

            }

            k += 3 * m;

        }, atomname || "trace" );

        _a3.positionToArray( pos, k );

        return pos;

    },

    getTangent: function( m, tension, atomname ){

        if( isNaN( tension ) ) tension = this.tension;

        var interpolate = this.interpolate;

        var p1 = new THREE.Vector3();
        var p2 = new THREE.Vector3();

        var n = this.size;
        var n1 = n - 1;

        var tan = new Float32Array( n1 * m * 3 + 3 );

        var k = 0;
        var dt = 1.0 / m;
        var delta = 0.0001;

        var j, l, d, d1, d2;

        this.fiber.eachAtomN( 4, function( a1, a2, a3, a4 ){

            for( j = 0; j < m; ++j ){

                d = dt * j
                d1 = d - delta;
                d2 = d + delta;
                l = k + j * 3;

                // capping as a precation
                if ( d1 < 0 ) d1 = 0;
                if ( d2 > 1 ) d2 = 1;

                p1.x = interpolate( a1.x, a2.x, a3.x, a4.x, d1, tension );
                p1.y = interpolate( a1.y, a2.y, a3.y, a4.y, d1, tension );
                p1.z = interpolate( a1.z, a2.z, a3.z, a4.z, d1, tension );

                p2.x = interpolate( a1.x, a2.x, a3.x, a4.x, d2, tension );
                p2.y = interpolate( a1.y, a2.y, a3.y, a4.y, d2, tension );
                p2.z = interpolate( a1.z, a2.z, a3.z, a4.z, d2, tension );

                p2.sub( p1 ).normalize();
                p2.toArray( tan, l );

            }

            k += 3 * m;

        }, atomname || "trace" );


        p2.toArray( tan, k );

        // var o = n1 * m * 3;
        // NGL.Utils.copyArray( tan, tan, o - 3, o, 3 );

        return tan;

    },

    getNormals: function( m, tension, tan ){

        var interpolate = this.interpolate;
        var type = this.type;
        var fiber = this.fiber;

        var n = this.size;
        var n1 = n - 1;

        var norm = new Float32Array( n1 * m * 3 + 3 );
        var bin = new Float32Array( n1 * m * 3 + 3 );

        var p1 = new THREE.Vector3();
        var p2 = new THREE.Vector3();

        var vSub1 = new THREE.Vector3();
        var vSub2 = new THREE.Vector3();
        var vSub3 = new THREE.Vector3();
        var vSub4 = new THREE.Vector3();

        var vDir = new THREE.Vector3();
        var vTan = new THREE.Vector3();
        var vNorm = new THREE.Vector3().set( 0, 0, 1 );
        var vBin = new THREE.Vector3();
        var vBinPrev = new THREE.Vector3();

        var d1a1 = new THREE.Vector3();
        var d1a2 = new THREE.Vector3();
        var d1a3 = new THREE.Vector3();
        var d1a4 = new THREE.Vector3();

        var d2a1 = new THREE.Vector3();
        var d2a2 = new THREE.Vector3();
        var d2a3 = new THREE.Vector3();
        var d2a4 = new THREE.Vector3();

        var k = 0;
        var dt = 1.0 / m;
        var first = true;
        var m2 = Math.ceil( m / 2 );

        var j, l, d, d1, d2;

        if( !fiber.computedAtoms[ "direction1" ] ){
            fiber.computeAtom( "direction1" );
        }
        if( !fiber.computedAtoms[ "direction2" ] ){
            fiber.computeAtom( "direction2" );
        }
        var direction1 = fiber.computedAtoms[ "direction1" ];
        var direction2 = fiber.computedAtoms[ "direction2" ];

        var len = direction1.length;

        for( var i = 4; i <= len; i++ ){

            if( type !== NGL.CgType ){

                if( first ){

                    first = false;

                    d1a1.copy( direction1[ i - 4 ] );
                    d1a2.copy( direction1[ i - 3 ] );
                    d1a3.copy( direction1[ i - 2 ] );

                    d2a1.copy( direction2[ i - 4 ] );
                    d2a2.copy( direction2[ i - 3 ] );
                    d2a3.copy( direction2[ i - 2 ] );

                    vSub1.subVectors( d2a1, d1a1 );
                    vSub2.subVectors( d2a2, d1a2 );
                    if( vSub1.dot( vSub2 ) < 0 ){
                        vSub2.multiplyScalar( -1 );
                        d2a2.addVectors( d1a2, vSub2 );
                    }

                    vSub3.subVectors( d2a3, d1a3 );
                    if( vSub2.dot( vSub3 ) < 0 ){
                        vSub3.multiplyScalar( -1 );
                        d2a3.addVectors( d1a3, vSub3 );
                    }

                }else{

                    d1a1.copy( d1a2 );
                    d1a2.copy( d1a3 );
                    d1a3.copy( d1a4 );

                    d2a1.copy( d2a2 );
                    d2a2.copy( d2a3 );
                    d2a3.copy( d2a4 );

                    vSub3.copy( vSub4 );

                }

                d1a4.copy( direction1[ i - 1 ] );
                d2a4.copy( direction2[ i - 1 ] );

                vSub4.subVectors( d2a4, d1a4 );
                if( vSub3.dot( vSub4 ) < 0 ){
                    vSub4.multiplyScalar( -1 );
                    d2a4.addVectors( d1a4, vSub4 );
                }

            }

            for( j = 0; j < m; ++j ){

                l = k + j * 3;

                if( type === NGL.CgType ){

                    vDir.copy( vNorm );

                }else{

                    if( type === NGL.ProteinType ){
                        // shift half a residue
                        l += m2 * 3;
                    }
                    d = dt * j

                    p1.x = interpolate( d1a1.x, d1a2.x, d1a3.x, d1a4.x, d, tension );
                    p1.y = interpolate( d1a1.y, d1a2.y, d1a3.y, d1a4.y, d, tension );
                    p1.z = interpolate( d1a1.z, d1a2.z, d1a3.z, d1a4.z, d, tension );

                    p2.x = interpolate( d2a1.x, d2a2.x, d2a3.x, d2a4.x, d, tension );
                    p2.y = interpolate( d2a1.y, d2a2.y, d2a3.y, d2a4.y, d, tension );
                    p2.z = interpolate( d2a1.z, d2a2.z, d2a3.z, d2a4.z, d, tension );

                    vDir.subVectors( p2, p1 ).normalize();

                }

                vTan.fromArray( tan, l );

                vBin.crossVectors( vDir, vTan ).normalize();
                vBin.toArray( bin, l );

                vNorm.crossVectors( vTan, vBin ).normalize();
                vNorm.toArray( norm, l );

            }

            k += 3 * m;

        }

        if( type === NGL.ProteinType ){

            vBin.fromArray( bin, m2 * 3 );
            vNorm.fromArray( norm, m2 * 3 );

            for( j = 0; j < m2; ++j ){
                vBin.toArray( bin, j * 3 );
                vNorm.toArray( norm, j * 3 );
            }

        }else{

            vBin.toArray( bin, k );
            vNorm.toArray( norm, k );

        }

        return {
            "normal": norm,
            "binormal": bin
        }

    }

};


////////////////
// Helixorient

NGL.Helixorient = function( fiber ){

    this.fiber = fiber;

    this.size = fiber.residueCount;

};

NGL.Helixorient.prototype = {

    constructor: NGL.Helixorient,

    getFiber: function( smooth, padded ){

        var center = this.getPosition().center;

        var i, j, a, r, fr, fa;
        var residues = [];
        var n = center.length / 3;
        var fiber = this.fiber;

        if( !fiber.computedAtoms[ "trace" ] ) fiber.computeAtom( "trace" );
        var trace = fiber.computedAtoms[ "trace" ];

        for( i = 0; i < n; ++i ){

            fa = trace[ i ];
            fr = fa.residue;

            r = new NGL.Residue();
            a = new NGL.Atom( r, fa.globalindex );  // FIXME get rid of globalindex

            r.atoms.push( a );
            r.atomCount += 1;
            r.resname = fr.resname;
            r.index = fr.index;
            r.chain = fr.chain;

            j = 3 * i;

            a.positionFromArray( center, j );

            if( smooth ){

                var l, k, t;
                var w = Math.min( smooth, i, n - i - 1 );

                for( k = 1; k <= w; ++k ){

                    l = k * 3;
                    t = ( w + 1 - k ) / ( w + 1 );

                    a.x += t * center[ j - l + 0 ] + t * center[ j + l + 0 ];
                    a.y += t * center[ j - l + 1 ] + t * center[ j + l + 1 ];
                    a.z += t * center[ j - l + 2 ] + t * center[ j + l + 2 ];

                }

                a.x /= w + 1;
                a.y /= w + 1;
                a.z /= w + 1;

            }

            a.atomname = fa.atomname;
            a.index = fa.index;
            a.resname = fa.resname;
            a.chainname = fa.chainname;
            a.bfactor = fa.bfactor;
            a.ss = fa.ss;

            residues.push( r );

            if( padded && ( i === 0 || i === n - 1 ) ){
                residues.push( r );
            }

        }

        var f = new NGL.Fiber( residues, fiber.structure );

        return f;

    },

    getColor: function( params ){

        var n = this.size;
        var fiber = this.fiber;

        var col = new Float32Array( n * 3 );
        var pcol = new Float32Array( n * 3 );

        var p = params || {};
        p.structure = fiber.structure;

        var colorMaker = NGL.ColorMakerRegistry.getScheme( p );
        var pickingColorMaker = NGL.ColorMakerRegistry.getPickingScheme( p );

        if( !fiber.computedAtoms[ "trace" ] ) fiber.computeAtom( "trace" );
        var trace = fiber.computedAtoms[ "trace" ];

        for( var i = 0; i < n; ++i ){

            var a = trace[ i ];
            var i3 = i * 3;

            colorMaker.atomColorToArray( a, col, i3 );
            pickingColorMaker.atomColorToArray( a, pcol, i3 );

        }

        return {
            "color": col,
            "pickingColor": pcol
        };

    },

    getSize: function( type, scale ){

        var n = this.size;
        var fiber = this.fiber;

        var size = new Float32Array( n );

        var radiusFactory = new NGL.RadiusFactory( type, scale );

        if( !fiber.computedAtoms[ "trace" ] ) fiber.computeAtom( "trace" );
        var trace = fiber.computedAtoms[ "trace" ];

        for( var i = 0; i < n; ++i ){

            size[ i ] = radiusFactory.atomRadius( trace[ i ] );

        }

        return {
            "size": size
        };

    },

    getPosition: function(){

        var i = 0;
        var n = this.size;

        var center = new Float32Array( 3 * n );
        var axis = new Float32Array( 3 * n );
        var diff = new Float32Array( n );
        var radius = new Float32Array( n );
        var rise = new Float32Array( n );
        var twist = new Float32Array( n );
        var resdir = new Float32Array( 3 * n );

        var tmp, j;
        var a1, a2, a3, a4;
        var diff13Length, diff24Length;

        var r12 = new THREE.Vector3();
        var r23 = new THREE.Vector3();
        var r34 = new THREE.Vector3();

        var diff13 = new THREE.Vector3();
        var diff24 = new THREE.Vector3();

        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();

        var _axis = new THREE.Vector3();
        var _prevAxis = new THREE.Vector3();

        var _resdir = new THREE.Vector3();
        var _crossdir = new THREE.Vector3();
        var _center = new THREE.Vector3( 0, 0, 0 );

        this.fiber.eachAtomN( 4, function( a1, a2, a3, a4 ){

            j = 3 * i;

            // ported from GROMACS src/tools/gmx_helixorient.c

            r12.subVectors( a2, a1 );
            r23.subVectors( a3, a2 );
            r34.subVectors( a4, a3 );

            diff13.subVectors( r12, r23 );
            diff24.subVectors( r23, r34 );

            _axis.crossVectors( diff13, diff24 ).normalize();
            _axis.toArray( axis, j );

            if( i > 0 ){
                diff[ i ] = _axis.angleTo( _prevAxis );
            }

            tmp = Math.cos( diff13.angleTo( diff24 ) );
            twist[ i ] = 180.0 / Math.PI * Math.acos( tmp );

            diff13Length = diff13.length();
            diff24Length = diff24.length();

            radius[ i ] = (
                Math.sqrt( diff24Length * diff13Length ) /
                // clamp, to avoid instabilities for when
                // angle between diff13 and diff24 is near 0
                Math.max( 2.0, 2.0 * ( 1.0 - tmp ) )
            );

            rise[ i ] = Math.abs( r23.dot( _axis ) );

            //

            v1.copy( diff13 ).multiplyScalar( radius[ i ] / diff13Length );
            v2.copy( diff24 ).multiplyScalar( radius[ i ] / diff24Length );

            v1.subVectors( a2, v1 );
            v2.subVectors( a3, v2 );

            v1.toArray( center, j + 3 );
            v2.toArray( center, j + 6 );

            //

            _resdir.subVectors( a1, _center );
            _resdir.toArray( resdir, j );

            i += 1;
            _prevAxis.copy( _axis );
            _center.copy( v1 );

        }, "trace" );

        //

        var res = this.fiber.residues;

        // calc axis as dir of second and third center pos
        // project first traceAtom onto axis to get first center pos
        v1.fromArray( center, 3 );
        v2.fromArray( center, 6 );
        _axis.subVectors( v1, v2 ).normalize();
        _center.copy( res[ 0 ].getTraceAtom() );
        v1 = NGL.Utils.pointVectorIntersection( _center, v1, _axis );
        v1.toArray( center, 0 );

        // calc first resdir
        _resdir.subVectors( _center, v1 );
        _resdir.toArray( resdir, 0 );

        // calc axis as dir of n-1 and n-2 center pos
        // project last traceAtom onto axis to get last center pos
        v1.fromArray( center, 3 * n - 6 );
        v2.fromArray( center, 3 * n - 9 );
        _axis.subVectors( v1, v2 ).normalize();
        _center.copy( res[ n - 1 ].getTraceAtom() );
        v1 = NGL.Utils.pointVectorIntersection( _center, v1, _axis );
        v1.toArray( center, 3 * n - 3 );

        // calc last three resdir
        for( i = n - 3; i < n; ++i ){

            v1.fromArray( center, 3 * i );
            _center.copy( res[ i ].getTraceAtom() );

            _resdir.subVectors( _center, v1 );
            _resdir.toArray( resdir, 3 * i );

        }

        // average measures to define them on the residues

        var resRadius = new Float32Array( n );
        var resTwist = new Float32Array( n );
        var resRise = new Float32Array( n );
        var resBending = new Float32Array( n );

        resRadius[ 1 ] = radius[ 0 ];
        resTwist[ 1 ] = twist[ 0 ];
        resRise[ 1 ] = radius[ 0 ];

        for( i = 2; i < n - 2; i++ ){

            resRadius[ i ] = 0.5 * ( radius[ i - 2 ] + radius[ i - 1 ] );
            resTwist[ i ] = 0.5 * ( twist[ i - 2 ] + twist[ i - 1 ] );
            resRise[ i ] = 0.5 * ( rise[ i - 2 ] + rise[ i - 1 ] );

            v1.fromArray( axis, 3 * ( i - 2 ) );
            v2.fromArray( axis, 3 * ( i - 1 ) );
            resBending[ i ] = 180.0 / Math.PI * Math.acos( Math.cos( v1.angleTo( v2 ) ) );

        }

        resRadius[ n - 2 ] = radius[ n - 4 ];
        resTwist[ n - 2 ] = twist[ n - 4 ];
        resRise[ n - 2 ] = rise[ n - 4 ];

        // average helix axes to define them on the residues

        var resAxis = new Float32Array( 3 * n );

        NGL.Utils.copyArray( axis, resAxis, 0, 0, 3 );
        NGL.Utils.copyArray( axis, resAxis, 0, 3, 3 );

        for( i = 2; i < n - 2; i++ ){

            v1.fromArray( axis, 3 * ( i - 2 ) );
            v2.fromArray( axis, 3 * ( i - 1 ) );

            _axis.addVectors( v2, v1 ).multiplyScalar( 0.5 ).normalize();
            _axis.toArray( resAxis, 3 * i );

        }

        NGL.Utils.copyArray( axis, resAxis, 3 * n - 12, 3 * n - 6, 3 );
        NGL.Utils.copyArray( axis, resAxis, 3 * n - 12, 3 * n - 3, 3 );

        return {
            "center": center,
            "axis": resAxis,
            "bending": resBending,
            "radius": resRadius,
            "rise": resRise,
            "twist": resTwist,
            "resdir": resdir,
        };

    }

};


//////////
// Helix

NGL.Helix = function(){

    this.begin = new THREE.Vector3();
    this.end = new THREE.Vector3();
    this.axis = new THREE.Vector3();
    this.center = new THREE.Vector3();

    this.length = 0;

    this.residues = [];
    this.size = 0;

};

NGL.Helix.prototype = {

    constructor: NGL.Helix,

    fromHelixbundleAxis: function(){

        var v = new THREE.Vector3();

        return function( axis, i ){

            this.begin.fromArray( axis.begin, i * 3 );
            this.end.fromArray( axis.end, i * 3 );
            this.axis.fromArray( axis.axis, i * 3 );
            this.center.fromArray( axis.center, i * 3 );

            this.length = v.subVectors( this.begin, this.end ).length();

            this.residues = axis.residue[ i ];
            this.size = this.residues.length;

            return this;

        }

    }(),

    angleTo: function(){

        var v = new THREE.Vector3();

        return function( helix ){

            var s = v.crossVectors( this.axis, helix.axis ).length();
            var c = this.axis.dot( helix.axis );
            var angle = Math.atan2( s, c );

            return c < 0 ? -angle : angle;

        }

    }(),

    distanceTo: function(){

        var x = new THREE.Vector3();
        var y = new THREE.Vector3();
        var c = new THREE.Vector3();

        return function( helix ){

            this.crossingPoints( helix, x, y );

            c.subVectors( y, x );

            return c.length();

        }

    }(),

    crossingPoints: function(){

        var w = new THREE.Vector3();
        var v = new THREE.Vector3();
        var ca = new THREE.Vector3();
        var cb = new THREE.Vector3();

        return function( helix, x, y ){

            // U = A2-A1;
            // V = B2-B1;
            // W = cross(U,V);
            // X = A1 + dot(cross(B1-A1,V),W)/dot(W,W)*U;
            // Y = B1 + dot(cross(B1-A1,U),W)/dot(W,W)*V;
            // d = norm(Y-X);

            if( !x ) x = new THREE.Vector3();
            if( !y ) y = new THREE.Vector3();

            w.crossVectors( this.axis, helix.axis );
            v.subVectors( helix.begin, this.begin );

            var dotWW = w.dot( w );
            var dotA = ca.crossVectors( v, helix.axis ).dot( w );
            var dotB = cb.crossVectors( v, this.axis ).dot( w );

            x.copy( this.axis ).multiplyScalar( dotA / dotWW ).add( this.begin );
            y.copy( helix.axis ).multiplyScalar( dotB / dotWW ).add( helix.begin );

            return [ x, y ];

        }

    }(),

    crossing: function( helix ){

        var data = {};

        var angle = this.angleTo( helix ) / ( Math.PI / 180 );
        var cp = this.crossingPoints( helix );

        var lineContact = (
            NGL.Utils.isPointOnSegment( cp[ 0 ], this.begin, this.end ) &&
            NGL.Utils.isPointOnSegment( cp[ 1 ], helix.begin, helix.end )
        );

        var i1 = NGL.Utils.pointVectorIntersection(
            this.begin, helix.begin, helix.axis
        );
        var i2 = NGL.Utils.pointVectorIntersection(
            this.end, helix.begin, helix.axis
        );
        var i3 = NGL.Utils.pointVectorIntersection(
            helix.begin, this.begin, this.axis
        );
        var i4 = NGL.Utils.pointVectorIntersection(
            helix.end, this.begin, this.axis
        );

        var c1 = NGL.Utils.isPointOnSegment(
            i1, helix.begin, helix.end
        );
        var c2 = NGL.Utils.isPointOnSegment(
            i2, helix.begin, helix.end
        );
        var c3 = NGL.Utils.isPointOnSegment(
            i3, this.begin, this.end
        );
        var c4 = NGL.Utils.isPointOnSegment(
            i4, this.begin, this.end
        );

        var overlap = [ 0, 0, 0, 0 ];

        if( c1 && c2 ){
            overlap[ 0 ] = i1.distanceTo( i2 );
        }
        if( c3 && c4 ){
            overlap[ 1 ] = i3.distanceTo( i4 );
        }
        if( c1 && !c2 ){
            if( i2.distanceTo( helix.begin ) < i2.distanceTo( helix.end ) ){
                overlap[ 2 ] = i1.distanceTo( helix.begin );
            }else{
                overlap[ 2 ] = i1.distanceTo( helix.end );
            }
        }
        if( !c1 && c2 ){
            if( i1.distanceTo( helix.begin ) < i1.distanceTo( helix.end ) ){
                overlap[ 2 ] = i2.distanceTo( helix.begin );
            }else{
                overlap[ 2 ] = i2.distanceTo( helix.end );
            }
        }
        if( c3 && !c4 ){
            if( i4.distanceTo( this.begin ) < i4.distanceTo( this.end ) ){
                overlap[ 3 ] = i3.distanceTo( this.begin );
            }else{
                overlap[ 3 ] = i3.distanceTo( this.end );
            }
        }
        if( !c3 && c4 ){
            if( i3.distanceTo( this.begin ) < i3.distanceTo( this.end ) ){
                overlap[ 3 ] = i4.distanceTo( this.begin );
            }else{
                overlap[ 3 ] = i4.distanceTo( this.end );
            }
        }

        var maxOverlap = Math.max.apply( null, overlap );

        var onSegment = [ c1, c2, c3, c4 ];

        if( !lineContact ){

            var candidates = [];

            if( angle > 120 || angle < 60 ){

                candidates.push( {
                    "distance": this.begin.distanceTo( i1 ),
                    "contact": c1,
                    "p1": this.begin,
                    "p2": i1
                } );

                candidates.push( {
                    "distance": this.end.distanceTo( i2 ),
                    "contact": c2,
                    "p1": this.end,
                    "p2": i2
                } );

                candidates.push( {
                    "distance": helix.begin.distanceTo( i3 ),
                    "contact": c3,
                    "p1": helix.begin,
                    "p2": i3
                } );

                candidates.push( {
                    "distance": helix.end.distanceTo( i4 ),
                    "contact": c4,
                    "p1": helix.end,
                    "p2": i4
                } );

            }

            //

            if( maxOverlap > 0 && ( angle > 120 || angle < 60 ) ){

                candidates.push( {
                    "distance": this.begin.distanceTo( helix.begin ),
                    "contact": true,
                    "p1": this.begin,
                    "p2": helix.begin
                } );

                candidates.push( {
                    "distance": this.begin.distanceTo( helix.end ),
                    "contact": true,
                    "p1": this.begin,
                    "p2": helix.end
                } );

                candidates.push( {
                    "distance": this.end.distanceTo( helix.begin ),
                    "contact": true,
                    "p1": this.end,
                    "p2": helix.begin
                } );

                candidates.push( {
                    "distance": this.end.distanceTo( helix.end ),
                    "contact": true,
                    "p1": this.end,
                    "p2": helix.end
                } );

            }

            //

            data.distance = Infinity;
            candidates.forEach( function( c ){
                if( c.contact && c.distance < data.distance ){
                    data = c;
                }
            } );

        }else{

            data = {
                "distance": this.distanceTo( helix ),
                "contact": true,
                "p1": cp[ 0 ],
                "p2": cp[ 1 ]
            };

        }

        return Object.assign( {
            "distance": Infinity,
            "contact": false,
            "angle": angle,
            "onSegment": onSegment,
            "overlap": overlap,
            "maxOverlap": maxOverlap,
            "lineContact": lineContact
        }, data );

    }

};


////////////////
// Helixbundle

NGL.Helixbundle = function( fiber ){

    this.fiber = fiber;

    this.helixorient = new NGL.Helixorient( fiber );
    this.position = this.helixorient.getPosition();

    this.size = fiber.residueCount;

};

NGL.Helixbundle.prototype = {

    constructor: NGL.Helixbundle,

    getFiber: function( smooth ){

    },

    getColor: function( type ){

    },

    getSize: function( type, scale ){

    },

    getAxis: function( localAngle, centerDist, ssBorder, colorParams, radius, scale ){

        localAngle = localAngle || 30;
        centerDist = centerDist || 2.5;
        ssBorder = ssBorder === undefined ? false : ssBorder;

        var pos = this.position;

        var cp = colorParams || {};
        cp.structure = this.fiber.structure;

        var colorMaker = NGL.ColorMakerRegistry.getScheme( cp );
        var pickingColorMaker = NGL.ColorMakerRegistry.getPickingScheme( cp );

        var radiusFactory = new NGL.RadiusFactory( radius, scale );

        var i, r, r2, a;
        var j = 0;
        var k = 0;
        var n = this.size;

        var res = this.fiber.residues;

        var axis = [];
        var center = [];
        var beg = [];
        var end = [];
        var col = [];
        var pcol = [];
        var size = [];
        var residue = [];

        var tmpAxis = [];
        var tmpCenter = [];

        var _axis, _center
        var _beg = new THREE.Vector3();
        var _end = new THREE.Vector3();

        var c = new THREE.Vector3();
        var c2 = new THREE.Vector3();

        var split = false;

        for( i = 0; i < n; ++i ){

            r = res[ i ];
            c.fromArray( pos.center, i * 3 );

            if( i === n - 1 ){
                split = true;
            }else{

                r2 = res[ i + 1 ];
                c2.fromArray( pos.center, i * 3 + 3 );

                if( ssBorder && r.ss !== r2.ss ){
                    split = true;
                }else if( c.distanceTo( c2 ) > centerDist ){
                    split = true;
                }else if( pos.bending[ i ] > localAngle ){
                    split = true;
                }

            }

            if( split ){

                if( i - j < 4 ){

                    j = i;
                    split = false;
                    continue;

                }

                a = r.getTraceAtom();

                // ignore first and last axis
                tmpAxis = pos.axis.subarray( j * 3 + 3, i * 3 );
                tmpCenter = pos.center.subarray( j * 3, i * 3 + 3 );

                _axis = NGL.Utils.calculateMeanVector3( tmpAxis ).normalize();
                _center = NGL.Utils.calculateMeanVector3( tmpCenter );

                _beg.fromArray( tmpCenter );
                _beg = NGL.Utils.pointVectorIntersection( _beg, _center, _axis );

                _end.fromArray( tmpCenter, tmpCenter.length - 3 );
                _end = NGL.Utils.pointVectorIntersection( _end, _center, _axis );

                _axis.subVectors( _end, _beg );

                _axis.toArray( axis, k );
                _center.toArray( center, k );
                _beg.toArray( beg, k );
                _end.toArray( end, k );

                colorMaker.atomColorToArray( a, col, k );
                pickingColorMaker.atomColorToArray( a, pcol, k );

                size.push( radiusFactory.atomRadius( a ) );

                residue.push( res.slice( j, i + 1 ) );

                k += 3;
                j = i;
                split = false;

            }

        }

        return {
            "axis": new Float32Array( axis ),
            "center": new Float32Array( center ),
            "begin": new Float32Array( beg ),
            "end": new Float32Array( end ),
            "color": new Float32Array( col ),
            "pickingColor": new Float32Array( pcol ),
            "size": new Float32Array( size ),
            "residue": residue,
        };

    },

    getPosition: function(){

    }

};


/////////////////
// HelixCrossing

NGL.HelixCrossing = function( helices ){

    this.helices = helices;

};

NGL.HelixCrossing.prototype = {

    constructor: NGL.HelixCrossing,

    getCrossing: function( minDistance ){

        minDistance = minDistance || 12;

        var helices = this.helices;

        var helixLabel = [];
        var helixCenter = [];
        var crossingBeg = [];
        var crossingEnd = [];
        var info = [];

        var k = 0;

        for( var i = 0; i < helices.length; ++i ){

            var h1 = helices[ i ];

            helixLabel.push( "H" + ( i + 1 ) );
            h1.center.toArray( helixCenter, i * 3 );

            for( var j = i + 1; j < helices.length; ++j ){

                var c = h1.crossing( helices[ j ] );

                if( c.contact && c.distance < minDistance ){

                    info.push( {
                        "helix1": i + 1,
                        "helix2": j + 1,
                        "angle": c.angle,
                        "distance": c.distance,
                        "overlap": c.maxOverlap
                    } );

                    c.p1.toArray( crossingBeg, k * 3 );
                    c.p2.toArray( crossingEnd, k * 3 );
                    k += 1;

                }

            }

        }

        return {
            "helixLabel": helixLabel,
            "helixCenter": helixCenter,
            "begin": crossingBeg,
            "end": crossingEnd,
            "info": info
        }

    }

};


///////////
// Kdtree

NGL.Kdtree = function( atoms, useSquaredDist ){

    // NGL.time( "NGL.Kdtree build" );

    if( useSquaredDist ){

        var metric = function( a, b ){

            var dx = a[0] - b[0];
            var dy = a[1] - b[1];
            var dz = a[2] - b[2];

            return dx*dx + dy*dy + dz*dz;

        };

    }else{

        var metric = function( a, b ){

            var dx = a[0] - b[0];
            var dy = a[1] - b[1];
            var dz = a[2] - b[2];

            return Math.sqrt( dx*dx + dy*dy + dz*dz );

        };

    }

    if( atoms instanceof NGL.AtomSet ||
        atoms instanceof NGL.Structure ||
        atoms instanceof NGL.StructureSubset
    ){

        var atomSet = atoms;
        atoms = atomSet.atoms;

    }

    var n = atoms.length;
    var points = new Float32Array( n * 4 );

    for( var i = 0; i < n; ++i ){

        var a = atoms[ i ];
        var i3 = i * 3;
        var i4 = i * 4;

        points[ i4 + 0 ] = a.x;
        points[ i4 + 1 ] = a.y;
        points[ i4 + 2 ] = a.z;
        points[ i4 + 3 ] = i;

    }

    this.points = points;
    this.atoms = atoms;
    this.kdtree = new THREE.TypedArrayUtils.Kdtree( points, metric, 4, 3 );

    // NGL.timeEnd( "NGL.Kdtree build" );

};

NGL.Kdtree.prototype = {

    nearest: function(){

        var pointArray = new Float32Array( 3 );

        return function( point, maxNodes, maxDistance ){

            // NGL.time( "NGL.Kdtree nearest" );

            if( point instanceof THREE.Vector3 ){

                point.toArray( pointArray );

            }else if( point instanceof NGL.Atom || point instanceof NGL.ProxyAtom ){

                point.positionToArray( pointArray );

            }

            var nodeList = this.kdtree.nearest(
                pointArray, maxNodes, maxDistance
            );

            var atoms = this.atoms;
            var atomList = [];

            for( var i = 0, n = nodeList.length; i < n; ++i ){

                var d = nodeList[ i ];
                var node = d[ 0 ];
                var dist = d[ 1 ];

                atomList.push( {
                    atom: atoms[ this.points[ node.pos + 3 ] ],
                    distance: dist
                } );

            }

            // NGL.timeEnd( "NGL.Kdtree nearest" );

            return atomList;

        };

    }()

};


////////////
// Contact

NGL.Contact = function( atomSet1, atomSet2 ){

    this.atomSet1 = atomSet1;
    this.atomSet2 = atomSet2;

    this.kdtree1 = new NGL.Kdtree( atomSet1 );
    this.kdtree2 = new NGL.Kdtree( atomSet2 );

}

NGL.Contact.prototype = {

    within: function( maxDistance, minDistance ){

        NGL.time( "NGL.Contact within" );

        var atomSet = new NGL.AtomSet();
        var bondSet = new NGL.BondSet();

        var kdtree1 = this.kdtree1;
        var kdtree2 = this.kdtree2;

        var atoms = this.atomSet1.atoms;

        for( var i = 0, n = atoms.length; i < n; ++i ){

            var atom1 = atoms[ i ];
            var found = false;
            var contacts = kdtree2.nearest(
                atom1, Infinity, maxDistance
            );

            for( var j = 0, m = contacts.length; j < m; ++j ){

                var d = contacts[ j ];
                var atom2 = d.atom;
                var dist = d.distance;

                if( atom1.residue !== atom2.residue &&
                    ( !minDistance || dist > minDistance ) ){
                    found = true;
                    atomSet.addAtom( atom2 );
                    bondSet.addBond( atom1, atom2, true );
                }

            }

            if( found ){
                atomSet.addAtom( atom1 );
            }

        }

        NGL.timeEnd( "NGL.Contact within" );

        return {
            atomSet: atomSet,
            bondSet: bondSet
        };

    }

}


NGL.polarContacts = function( structure, maxDistance, maxAngle ){

    maxDistance = maxDistance || 3.5;
    maxAngle = maxAngle || 40;

    var donorSelection = new NGL.Selection(
        "( ARG and ( .NE or .NH1 or .NH2 ) ) or " +
        "( ASP and .ND2 ) or " +
        "( GLN and .NE2 ) or " +
        "( HIS and ( .ND1 or .NE2 ) ) or " +
        "( LYS and .NZ ) or " +
        "( SER and .OG ) or " +
        "( THR and .OG1 ) or " +
        "( TRP and .NE1 ) or " +
        "( TYR and .OH ) or " +
        "( PROTEIN and .N )"
    );

    var acceptorSelection = new NGL.Selection(
        "( ASN and .OD1 ) or " +
        "( ASP and ( OD1 or .OD2 ) ) or " +
        "( GLN and .OE1 ) or " +
        "( GLU and ( .OE1 or .OE2 ) ) or " +
        "( HIS and ( .ND1 or .NE2 ) ) or " +
        "( SER and .OG ) or " +
        "( THR and .OG1 ) or " +
        "( TYR and .OH ) or " +
        "( PROTEIN and .O )"
    );

    var donAtomSet = new NGL.AtomSet( structure, donorSelection );
    var accAtomSet = new NGL.AtomSet( structure, acceptorSelection );

    var contact = new NGL.Contact( donAtomSet, accAtomSet );
    var data = contact.within( maxDistance );

    data.atomSet.structure = structure;
    data.bondSet.structure = structure;

    var bondSet = new NGL.BondSet();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    var checkAngle = function( atom1, atom2, oName, cName ){

        var atomO, atomN;

        if( atom1.atomname === oName ){
            atomO = atom1;
            atomN = atom2;
        }else{
            atomO = atom2;
            atomN = atom1;
        }

        var atomC = atomO.residue.getAtomByName( cName );

        v1.subVectors( atomC, atomO );
        v2.subVectors( atomC, atomN );

        return THREE.Math.radToDeg( v1.angleTo( v2 ) ) < maxAngle;

    }

    data.bondSet.eachBond( function( b ){

        var a1 = b.atom1;
        var a2 = b.atom2;

        if( ( a1.atomname === "O" && a2.atomname === "N" ) ||
            ( a1.atomname === "N" && a2.atomname === "O" )
        ){

            // ignore backbone to backbone contacts
            return;

        }else if( a1.atomname === "N" || a2.atomname === "N" ){

            var atomN, atomX;

            if( a1.atomname === "N" ){
                atomN = a1;
                atomX = a2;
            }else{
                atomN = a2;
                atomX = a1;
            }

            var atomCA = atomN.residue.getAtomByName( "CA" );
            if( !atomCA ) return;

            var prevRes = atomN.residue.getPreviousConnectedResidue();
            if( !prevRes ) return;

            var atomC = prevRes.getAtomByName( "C" );
            if( !atomC ) return;

            v1.subVectors( atomN, atomC );
            v2.subVectors( atomN, atomCA );
            v1.add( v2 ).multiplyScalar( 0.5 );
            v2.subVectors( atomX, atomN );

            if( THREE.Math.radToDeg( v1.angleTo( v2 ) ) < maxAngle ){
                bondSet.addBond( a1, a2, true );
            }

        }else if(
            ( a1.atomname === "OH" && a1.resname === "TYR" ) ||
            ( a2.atomname === "OH" && a2.resname === "TYR" )
        ){

            if( checkAngle( a1, a2, "OH", "CZ" ) ){
                bondSet.addBond( a1, a2, true );
            }

        }else{

            bondSet.addBond( a1, a2, true );

        }

    } );

    bondSet.structure = structure;

    data.bondSet.dispose();
    donAtomSet.dispose();
    accAtomSet.dispose();

    return {
        atomSet: data.atomSet,
        bondSet: bondSet
    };

}


NGL.polarBackboneContacts = function( structure, maxDistance, maxAngle ){

    maxDistance = maxDistance || 3.5;
    maxAngle = maxAngle || 40;

    var donorSelection = new NGL.Selection(
        "( PROTEIN and .N )"
    );

    var acceptorSelection = new NGL.Selection(
        "( PROTEIN and .O )"
    );

    var donAtomSet = new NGL.AtomSet( structure, donorSelection );
    var accAtomSet = new NGL.AtomSet( structure, acceptorSelection );

    var contact = new NGL.Contact( donAtomSet, accAtomSet );
    var data = contact.within( maxDistance );

    data.atomSet.structure = structure;
    data.bondSet.structure = structure;

    var bondSet = new NGL.BondSet();
    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    data.bondSet.eachBond( function( b ){

        var a1 = b.atom1;
        var a2 = b.atom2;

        var atomN, atomO;

        if( a1.atomname === "N" ){
            atomN = a1;
            atomO = a2;
        }else{
            atomN = a2;
            atomO = a1;
        }

        var atomCA = atomN.residue.getAtomByName( "CA" );
        if( !atomCA ) return;

        var prevRes = atomN.residue.getPreviousConnectedResidue();
        if( !prevRes ) return;

        var atomC = prevRes.getAtomByName( "C" );
        if( !atomC ) return;

        v1.subVectors( atomN, atomC );
        v2.subVectors( atomN, atomCA );
        v1.add( v2 ).multiplyScalar( 0.5 );
        v2.subVectors( atomO, atomN );

        // NGL.log( THREE.Math.radToDeg( v1.angleTo( v2 ) ) );

        if( THREE.Math.radToDeg( v1.angleTo( v2 ) ) < maxAngle ){
            bondSet.addBond( a1, a2, true );
        }

    } );

    bondSet.structure = structure;

    data.bondSet.dispose();
    donAtomSet.dispose();
    accAtomSet.dispose();

    return {
        atomSet: data.atomSet,
        bondSet: bondSet
    };

}

// File:js/ngl/selection.js

/**
 * @file Selection
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


//////////////
// Selection

NGL.Selection = function( string, extraString ){

    var SIGNALS = signals;

    this.signals = {

        stringChanged: new SIGNALS.Signal(),

    };

    this.setString( string, extraString );

};


NGL.Selection.prototype = {

    constructor: NGL.Selection,

    setString: function( string, extraString, silent ){

        if( string === undefined ){
            string = this.string || "";
        }

        if( extraString === undefined ){
            extraString = this.extraString || "";
        }

        if( string === this.string && extraString === this.extraString ){
            return;
        }

        //

        var combinedString;

        if( !string && !extraString ){

            combinedString = "";

        }else if( !string ){

            combinedString = extraString;

        }else if( !extraString ){

            combinedString = string;

        }else{

            combinedString = (
                "( " + string + " ) and " +
                "( " + extraString + " )"
            );

        }

        if( combinedString === this.combinedString ){
            return;
        }

        //

        try{

            this.parse( combinedString );

        }catch( e ){

            // NGL.error( e.stack );
            this.selection = { "error": e.message };

        }

        this.string = string;
        this.extraString = extraString;
        this.combinedString = combinedString;

        this.test = this.makeAtomTest();
        this.residueTest = this.makeResidueTest();
        this.chainTest = this.makeChainTest();
        this.modelTest = this.makeModelTest();

        this.atomOnlyTest = this.makeAtomTest( true );
        this.residueOnlyTest = this.makeResidueTest( true );
        this.chainOnlyTest = this.makeChainTest( true )
        this.modelOnlyTest = this.makeModelTest( true );

        if( !silent ){
            this.signals.stringChanged.dispatch( this.string );
        }

    },

    parse: function( string ){

        this.selection = {
            operator: undefined,
            rules: []
        };

        if( !string ) return;

        var scope = this;

        var selection = this.selection;
        var selectionStack = [];
        var newSelection, oldSelection;
        var andContext = null;

        string = string.replace( /\(/g, ' ( ' ).replace( /\)/g, ' ) ' ).trim();
        if( string.charAt( 0 ) === "(" && string.substr( -1 ) === ")" ){
            string = string.slice( 1, -1 ).trim();
        }
        var chunks = string.split( /\s+/ );

        // NGL.log( string, chunks )

        var all = [ "*", "", "ALL" ];

        var c, sele, i, error, not;
        var atomname, chain, resno, resname, model, resi;
        var j = 0;

        var createNewContext = function( operator ){

            newSelection = {
                operator: operator,
                rules: []
            };
            if( selection === undefined ){
                selection = newSelection;
                scope.selection = newSelection;
            }else{
                selection.rules.push( newSelection );
                selectionStack.push( selection );
                selection = newSelection;
            }
            j = 0;

        }

        var getPrevContext = function( operator ){

            oldSelection = selection;
            selection = selectionStack.pop();
            if( selection === undefined ){
                createNewContext( operator );
                pushRule( oldSelection );
            }else{
                j = selection.rules.length;
            }

        }

        var pushRule = function( rule ){

            selection.rules.push( rule );
            j += 1;

        }

        for( i = 0; i < chunks.length; ++i ){

            c = chunks[ i ];

            // handle parens

            if( c === "(" ){

                // NGL.log( "(" );

                not = false;
                createNewContext();
                continue;

            }else if( c === ")" ){

                // NGL.log( ")" );

                getPrevContext();
                if( selection.negate ){
                    getPrevContext();
                }
                continue;

            }

            // leave 'not' context

            if( not > 0 ){

                if( c.toUpperCase() === "NOT" ){

                    not = 1;

                }else if( not === 1 ){

                    not = 2;

                }else if( not === 2 ){

                    not = false;
                    getPrevContext();

                }else{

                    throw new Error( "something went wrong with 'not'" );

                }

            }

            // handle logic operators

            if( c.toUpperCase() === "AND" ){

                // NGL.log( "AND" );

                if( selection.operator === "OR" ){
                    var lastRule = selection.rules.pop();
                    createNewContext( "AND" );
                    pushRule( lastRule );
                }else{
                    selection.operator = "AND";
                }
                continue;

            }else if( c.toUpperCase() === "OR" ){

                // NGL.log( "OR" );

                if( selection.operator === "AND" ){
                    getPrevContext( "OR" );
                }else{
                    selection.operator = "OR";
                }
                continue;

            }else if( c.toUpperCase() === "NOT" ){

                // NGL.log( "NOT", j );

                not = 1;
                createNewContext();
                selection.negate = true;
                continue;

            }else{

                // NGL.log( "chunk", c, j, selection );

            }

            // handle keyword attributes

            sele = {};

            if( c.toUpperCase() === "HETERO" ){
                sele.keyword = "HETERO";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "WATER" ){
                sele.keyword = "WATER";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "PROTEIN" ){
                sele.keyword = "PROTEIN";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "NUCLEIC" ){
                sele.keyword = "NUCLEIC";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "RNA" ){
                sele.keyword = "RNA";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "DNA" ){
                sele.keyword = "DNA";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "POLYMER" ){
                sele.keyword = "POLYMER";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "HYDROGEN" ){
                sele.element = "H";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "SMALL" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "GLY" },
                        { resname: "ALA" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "NUCLEOPHILIC" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "SER" },
                        { resname: "THR" },
                        { resname: "CYS" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "HYDROPHOBIC" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "VAL" },
                        { resname: "LEU" },
                        { resname: "ILE" },
                        { resname: "MET" },
                        { resname: "PRO" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "AROMATIC" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "PHE" },
                        { resname: "TYR" },
                        { resname: "TRP" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "AMIDE" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "ASN" },
                        { resname: "GLN" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "ACIDIC" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "ASP" },
                        { resname: "GLU" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "BASIC" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "HIS" },
                        { resname: "LYS" },
                        { resname: "ARG" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "CHARGED" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "ASP" },
                        { resname: "GLU" },
                        { resname: "HIS" },
                        { resname: "LYS" },
                        { resname: "ARG" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "POLAR" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "ASP" },
                        { resname: "GLU" },
                        { resname: "HIS" },
                        { resname: "LYS" },
                        { resname: "ARG" },
                        { resname: "ASN" },
                        { resname: "GLN" },
                        { resname: "SER" },
                        { resname: "THR" },
                        { resname: "TYR" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "NONPOLAR" ){
                sele = {
                    operator: "OR",
                    rules: [
                        { resname: "ALA" },
                        { resname: "CYS" },
                        { resname: "GLY" },
                        { resname: "ILE" },
                        { resname: "LEU" },
                        { resname: "MET" },
                        { resname: "PHE" },
                        { resname: "PRO" },
                        { resname: "VAL" },
                        { resname: "TRP" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "HELIX" ){
                sele.keyword = "HELIX";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "SHEET" ){
                sele.keyword = "SHEET";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "TURN" ){
                sele = {
                    operator: "OR",
                    negate: true,
                    rules: [
                        { keyword: "HELIX" },
                        { keyword: "SHEET" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "BACKBONE" ){
                sele.keyword = "BACKBONE";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "SIDECHAIN" ){
                sele.keyword = "SIDECHAIN";
                pushRule( sele );
                continue;
            }

            if( c.toUpperCase() === "SIDECHAINATTACHED" ){
                sele = {
                    operator: "OR",
                    rules: [
                        {
                            operator: "AND",
                            negate: false,
                            rules: [
                                { resname: "PRO" },
                                { atomname: "N" },
                            ]
                        },
                        { keyword: "SIDECHAIN" },
                        { atomname: "CA" },
                        { atomname: "BB" }
                    ]
                };
                pushRule( sele );
                continue;
            }

            if( all.indexOf( c.toUpperCase() )!==-1 ){
                sele.keyword = "ALL";
                pushRule( sele );
                continue;
            }

            // handle atom expressions

            if( c.charAt( 0 ) === "@" ){
                var indexList = c.substr( 1 ).split( "," );
                for( var k = 0, kl = indexList.length; k < kl; ++k ){
                    indexList[ k ] = parseInt( indexList[ k ] );
                }
                indexList.sort( function( a, b ){ return a - b; } );
                sele.atomindex = indexList;
                pushRule( sele );
                continue;
            }

            if( c.charAt( 0 ) === "#" ){
                sele.element = c.substr( 1 ).toUpperCase();
                pushRule( sele );
                continue;
            }

            if( c.charAt( 0 ) === "~" ){
                sele.altloc = c.substr( 1 );
                pushRule( sele );
                continue;
            }

            if( ( c.length >= 1 && c.length <= 4 ) &&
                    c[0] !== ":" && c[0] !== "." && c[0] !== "/" &&
                    isNaN( parseInt( c ) ) ){

                sele.resname = c.toUpperCase();
                pushRule( sele );
                continue;
            }

            // there must be only one constraint per rule
            // otherwise a test quickly becomes not applicable
            // e.g. chainTest for chainname when resno is present too

            sele = {
                operator: "AND",
                rules: []
            };

            model = c.split("/");
            if( model.length > 1 && model[1] ){
                if( isNaN( parseInt( model[1] ) ) ){
                    throw new Error( "model must be an integer" );
                }
                sele.rules.push( {
                    model: parseInt( model[1] )
                } );
            }

            atomname = model[0].split(".");
            if( atomname.length > 1 && atomname[1] ){
                if( atomname[1].length > 4 ){
                    throw new Error( "atomname must be one to four characters" );
                }
                sele.rules.push( {
                    atomname: atomname[1].substring( 0, 4 ).toUpperCase()
                } );
            }

            chain = atomname[0].split(":");
            if( chain.length > 1 && chain[1] ){
                sele.rules.push( {
                    chainname: chain[1]
                } );
            }

            if( chain[0] ){
                resi = chain[0].split("-");
                if( resi.length === 1 ){
                    resi = parseInt( resi[0] );
                    if( isNaN( resi ) ){
                        throw new Error( "resi must be an integer" );
                    }
                    sele.rules.push( {
                        resno: resi
                    } );
                }else if( resi.length === 2 ){
                    sele.rules.push( {
                        resno: [ parseInt( resi[0] ), parseInt( resi[1] ) ]
                    } );
                }else{
                    throw new Error( "resi range must contain one '-'" );
                }
            }

            // round up

            if( sele.rules.length === 1 ){
                pushRule( sele.rules[ 0 ] );
            }else if( sele.rules.length > 1 ){
                pushRule( sele );
            }else{
                throw new Error( "empty selection chunk" );
            }

        }

        // cleanup

        if( this.selection.operator === undefined &&
                this.selection.rules.length === 1 &&
                this.selection.rules[ 0 ].hasOwnProperty( "operator" ) ){

            this.selection = this.selection.rules[ 0 ];

        }

    },

    _makeTest: function( fn, selection ){

        if( selection === undefined ) selection = this.selection;
        if( selection === null ) return false;
        if( selection.error ) return false;

        var n = selection.rules.length;
        if( n === 0 ) return false;

        var t = selection.negate ? false : true;
        var f = selection.negate ? true : false;

        var s, and, ret, na;

        var subTests = [];

        for( var i = 0; i < n; ++i ){

            s = selection.rules[ i ];

            if( s.hasOwnProperty( "operator" ) ){

                subTests[ i ] = this._makeTest( fn, s );

            }

        }

        return function( entity ){

            and = selection.operator === "AND";
            na = false;

            for( var i = 0; i < n; ++i ){

                s = selection.rules[ i ];

                if( s.hasOwnProperty( "operator" ) ){

                    if( subTests[ i ] ){

                        ret = subTests[ i ]( entity );

                    }else{

                        ret = -1;

                    }

                    if( ret === -1 ){

                        // return -1;
                        na = true;
                        continue;

                    }else if( ret === true){

                        if( and ){ continue; }else{ return t; }

                    }else{

                        if( and ){ return f; }else{ continue; }

                    }

                }else{

                    if( s.keyword!==undefined && s.keyword==="ALL" ){

                        if( and ){ continue; }else{ return t; }

                    }

                    ret = fn( entity, s );

                    if( ret === -1 ){

                        // return -1;
                        na = true;
                        continue;

                    }else if( ret === true){

                        if( and ){ continue; }else{ return t; }

                    }else{

                        if( and ){ return f; }else{ continue; }

                    }

                }

            }

            if( na ){

                return -1;

            }else{

                if( and ){ return t; }else{ return f; }

            }

        }

    },

    _filter: function( fn, selection ){

        if( selection === undefined ) selection = this.selection;
        if( selection.error ) return selection;

        var n = selection.rules.length;
        if( n === 0 ) return selection;

        var filtered = {
            operator: selection.operator,
            rules: []
        };
        if( selection.hasOwnProperty( "negate" ) ){
            filtered.negate = selection.negate;
        }

        for( var i = 0; i < n; ++i ){

            var s = selection.rules[ i ];

            if( s.hasOwnProperty( "operator" ) ){

                var fs = this._filter( fn, s );
                if( fs !== null ) filtered.rules.push( fs );

            }else if( !fn( s ) ){

                filtered.rules.push( s );

            }

        }

        if( filtered.rules.length > 0 ){

            // TODO maybe the filtered rules could be returned
            // in some case, but the way how tests are applied
            // e.g. when traversing a structure would also need
            // to change
            return selection;

        }else{

            return null;

        }

    },

    makeAtomTest: function( atomOnly ){

        var backboneProtein = [
            "CA", "C", "N", "O",
            "O1", "O2", "OC1", "OC2",
            "H", "H1", "H2", "H3", "HA"
        ];
        var backboneNucleic = [
            "P", "O3'", "O5'", "C5'", "C4'", "C3'", "OP1", "OP2",
            "O3*", "O5*", "C5*", "C4*", "C3*"
        ];
        var backboneCg = [
            "CA", "BB"
        ];

        var helixTypes = [
            "h", "g", "i"
        ];

        var selection;

        if( atomOnly ){

            // console.log( this.selection )

            selection = this._filter( function( s ){

                if( s.model!==undefined ) return true;
                if( s.chainname!==undefined ) return true;
                if( s.resname!==undefined ) return true;
                if( s.resno!==undefined ) return true;

                return false;

            } );

        }else{

            selection = this.selection;

        }

        var fn = function( a, s ){

            // returning -1 means the rule is not applicable

            if( s.keyword!==undefined ){

                if( s.keyword==="HETERO" && a.hetero===1 ) return true;
                if( s.keyword==="PROTEIN" && (
                        a.residue.isProtein() || a.residue.isCg()
                    )
                ) return true;
                if( s.keyword==="NUCLEIC" && a.residue.isNucleic() ) return true;
                if( s.keyword==="RNA" && a.residue.isRna() ) return true;
                if( s.keyword==="DNA" && a.residue.isDna() ) return true;
                if( s.keyword==="POLYMER" && (
                        a.residue.isProtein() ||
                        a.residue.isNucleic() ||
                        a.residue.isCg()
                    )
                ) return true;
                if( s.keyword==="WATER" && a.residue.isWater() ) return true;
                if( s.keyword==="HELIX" && helixTypes.indexOf( a.ss )!==-1 ) return true;
                if( s.keyword==="SHEET" && a.ss==="s" ) return true;
                if( s.keyword==="BACKBONE" && (
                        ( a.residue.isProtein() &&
                            backboneProtein.indexOf( a.atomname )!==-1 ) ||
                        ( a.residue.isNucleic() &&
                            backboneNucleic.indexOf( a.atomname )!==-1 ) ||
                        ( a.residue.isCg() &&
                            backboneCg.indexOf( a.atomname )!==-1 )
                    )
                ) return true;
                if( s.keyword==="SIDECHAIN" && (
                        ( a.residue.isProtein() &&
                            backboneProtein.indexOf( a.atomname )===-1 ) ||
                        ( a.residue.isNucleic() &&
                            backboneNucleic.indexOf( a.atomname )===-1 ) ||
                        ( a.residue.isCg() &&
                            backboneCg.indexOf( a.atomname )===-1 )
                    )
                ) return true;

                return false;

            }

            // TODO make replacement
            // if( s.globalindex!==undefined && s.globalindex!==a.globalindex ) return false;
            if( s.resname!==undefined && s.resname!==a.resname ) return false;
            if( s.chainname!==undefined && s.chainname!==a.chainname ) return false;
            if( s.atomname!==undefined && s.atomname!==a.atomname ) return false;
            if( s.model!==undefined && s.model!==a.residue.chain.model.index ) return false;

            if( s.resno!==undefined ){
                if( Array.isArray( s.resno ) && s.resno.length===2 ){
                    if( s.resno[0]>a.resno || s.resno[1]<a.resno ) return false;
                }else{
                    if( s.resno!==a.resno ) return false;
                }
            }

            if( s.element!==undefined && s.element!==a.element ) return false;

            if( s.altloc!==undefined && s.altloc!==a.altloc ) return false;

            if( s.atomindex!==undefined &&
                NGL.binarySearchIndexOf( s.atomindex, a.index ) < 0
            ) return false;

            return true;

        }

        return this._makeTest( fn, selection );

    },

    makeResidueTest: function( residueOnly ){

        var selection;

        if( residueOnly ){

            // console.log( this.selection )

            selection = this._filter( function( s ){

                if( s.model!==undefined ) return true;
                // TODO make replacement
                // if( s.globalindex!==undefined ) return true;
                if( s.chainname!==undefined ) return true;
                if( s.atomname!==undefined ) return true;
                if( s.element!==undefined ) return true;
                if( s.altloc!==undefined ) return true;

                return false;

            } );

        }else{

            selection = this.selection;

        }

        var fn = function( r, s ){

            // returning -1 means the rule is not applicable

            if( s.keyword!==undefined ){

                if( s.keyword==="HETERO" && r.isHetero() ) return true;
                if( s.keyword==="PROTEIN" && (
                        r.isProtein() || r.isCg() )
                ) return true;
                if( s.keyword==="NUCLEIC" && r.isNucleic() ) return true;
                if( s.keyword==="RNA" && r.isRna() ) return true;
                if( s.keyword==="DNA" && r.isDna() ) return true;
                if( s.keyword==="POLYMER" && (
                        r.isProtein() || r.isNucleic() || r.isCg() )
                ) return true;
                if( s.keyword==="WATER" && r.isWater() ) return true;

            }

            if( s.chainname===undefined && s.model===undefined &&
                    s.resname===undefined && s.resno===undefined
            ) return -1;
            if( s.chainname!==undefined && r.chain.chainname===undefined ) return -1;

            // support autoChainNames which work only on atoms
            if( s.chainname!==undefined && r.chain.chainname==="" ) return -1;

            if( s.resname!==undefined && s.resname!==r.resname ) return false;
            if( s.chainname!==undefined && s.chainname!==r.chain.chainname ) return false;
            if( s.model!==undefined && s.model!==r.chain.model.index ) return false;

            if( s.resno!==undefined ){
                if( Array.isArray( s.resno ) && s.resno.length===2 ){
                    if( s.resno[0]>r.resno || s.resno[1]<r.resno ) return false;
                }else{
                    if( s.resno!==r.resno ) return false;
                }
            }

            return true;

        }

        return this._makeTest( fn, selection );

    },

    makeChainTest: function( chainOnly ){

        var selection;

        if( chainOnly ){

            // console.log( this.selection )

            selection = this._filter( function( s ){

                if( s.model!==undefined ) return true;
                if( s.resname!==undefined ) return true;
                if( s.resno!==undefined ) return true;
                // TODO make replacement
                // if( s.globalindex!==undefined ) return true;
                if( s.atomname!==undefined ) return true;
                if( s.element!==undefined ) return true;
                if( s.altloc!==undefined ) return true;

                return false;

            } );

        }else{

            selection = this.selection;

        }

        var fn = function( c, s ){

            // returning -1 means the rule is not applicable

            if( s.chainname!==undefined && c.chainname===undefined ) return -1;
            if( s.chainname===undefined && s.model===undefined ) return -1;

            // support autoChainNames which work only on atoms
            if( s.chainname!==undefined && c.chainname==="" ) return -1;

            if( s.chainname!==undefined && s.chainname!==c.chainname ) return false;
            if( s.model!==undefined && s.model!==c.model.index ) return false;

            return true;

        }

        return this._makeTest( fn, selection );

    },

    makeModelTest: function( modelOnly ){

        var selection;

        if( modelOnly ){

            // console.log( this.selection )

            selection = this._filter( function( s ){

                if( s.chainname!==undefined ) return true;
                if( s.resname!==undefined ) return true;
                if( s.resno!==undefined ) return true;
                // TODO make replacement
                // if( s.globalindex!==undefined ) return true;
                if( s.atomname!==undefined ) return true;
                if( s.element!==undefined ) return true;
                if( s.altloc!==undefined ) return true;

                return false;

            } );

        }else{

            selection = this.selection;

        }

        var fn = function( m, s ){

            // returning -1 means the rule is not applicable

            if( s.model===undefined ) return -1;
            if( s.model!==m.index ) return false;

            return true;

        }

        return this._makeTest( fn, selection );

    }

};

// File:js/ngl/superposition.js

/**
 * @file Superposition
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


/////////
// Math

NGL.Matrix = function( columns, rows ){

    var dtype = jsfeat.F32_t | jsfeat.C1_t;

    return new jsfeat.matrix_t( columns, rows, dtype );

};


//////////////////
// Superposition

NGL.Superposition = function( atoms1, atoms2 ){

    // allocate & init data structures

    var n;
    if( typeof atoms1.eachAtom === "function" ){
        n = atoms1.atomCount;
    }else if( atoms1 instanceof Float32Array ){
        n = atoms1.length / 3;
    }

    var coords1 = new NGL.Matrix( 3, n );
    var coords2 = new NGL.Matrix( 3, n );

    this.coords1t = new NGL.Matrix( n, 3 );
    this.coords2t = new NGL.Matrix( n, 3 );

    this.A = new NGL.Matrix( 3, 3 );
    this.W = new NGL.Matrix( 1, 3 );
    this.U = new NGL.Matrix( 3, 3 );
    this.V = new NGL.Matrix( 3, 3 );
    this.VH = new NGL.Matrix( 3, 3 );
    this.R = new NGL.Matrix( 3, 3 );

    this.tmp = new NGL.Matrix( 3, 3 );
    this.c = new NGL.Matrix( 3, 3 );
    this.c.data.set([ 1, 0, 0, 0, 1, 0, 0, 0, -1 ]);

    // prep coords

    this.prepCoords( atoms1, coords1 );
    this.prepCoords( atoms2, coords2 );

    // superpose

    this._superpose( coords1, coords2 );

};

NGL.Superposition.prototype = {

    constructor: NGL.Superposition,

    _superpose: function( coords1, coords2 ){

        // NGL.time( "superpose" );

        this.mean1 = jsfeat.matmath.mean_rows( coords1 );
        this.mean2 = jsfeat.matmath.mean_rows( coords2 );

        jsfeat.matmath.sub_rows( coords1, this.mean1 );
        jsfeat.matmath.sub_rows( coords2, this.mean2 );

        jsfeat.matmath.transpose( this.coords1t, coords1 );
        jsfeat.matmath.transpose( this.coords2t, coords2 );

        jsfeat.matmath.multiply_ABt( this.A, this.coords2t, this.coords1t );

        var svd = jsfeat.linalg.svd_decompose(
            this.A, this.W, this.U, this.V
        );

        jsfeat.matmath.invert_3x3( this.V, this.VH );
        jsfeat.matmath.multiply_3x3( this.R, this.U, this.VH );

        if( jsfeat.matmath.mat3x3_determinant( this.R ) < 0.0 ){

            NGL.log( "R not a right handed system" );

            jsfeat.matmath.multiply_3x3( this.tmp, this.c, this.VH );
            jsfeat.matmath.multiply_3x3( this.R, this.U, this.tmp );

        }

        // NGL.timeEnd( "superpose" );

    },

    prepCoords: function( atoms, coords ){

        var i = 0;
        var cd = coords.data;

        if( typeof atoms.eachAtom === "function" ){

            atoms.eachAtom( function( a ){

                cd[ i + 0 ] = a.x;
                cd[ i + 1 ] = a.y;
                cd[ i + 2 ] = a.z;

                i += 3;

            } );

        }else if( atoms instanceof Float32Array ){

            cd.set( atoms );

        }else{

            NGL.warn( "prepCoords: input type unknown" );

        }

    },

    transform: function( atoms ){

        // allocate data structures

        var n;
        if( typeof atoms.eachAtom === "function" ){
            n = atoms.atomCount;
        }else if( atoms instanceof Float32Array ){
            n = atoms.length / 3;
        }

        var coords = new NGL.Matrix( 3, n );
        var tmp = new NGL.Matrix( n, 3 );

        // prep coords

        this.prepCoords( atoms, coords );

        // do transform

        jsfeat.matmath.sub_rows( coords, this.mean1 );
        jsfeat.matmath.multiply_ABt( tmp, this.R, coords );
        jsfeat.matmath.transpose( coords, tmp );
        jsfeat.matmath.add_rows( coords, this.mean2 );

        var i = 0;
        var cd = coords.data;

        if( typeof atoms.eachAtom === "function" ){

            atoms.eachAtom( function( a ){

                a.x = cd[ i + 0 ];
                a.y = cd[ i + 1 ];
                a.z = cd[ i + 2 ];

                i += 3;

            } );

        }else if( atoms instanceof Float32Array ){

            atoms.set( cd.subarray( 0, n * 3 ) );

        }else{

            NGL.warn( "transform: input type unknown" );

        }

    },

    transformMatrix4: function( _mat4 ){

        console.log( "raw", _mat4.elements )

        var mat4 = new THREE.Matrix4().fromArray( _mat4.elements );
        var v3 = new THREE.Vector3().fromArray( this.mean1 );
        var pos = new THREE.Vector3().setFromMatrixPosition( mat4 );

        pos.sub( v3 );
        mat4.setPosition( pos );

        var rd = this.R.data;
        var R = new THREE.Matrix4().set(
            rd[0], rd[1], rd[2], 0,
            rd[3], rd[4], rd[5], 0,
            rd[6], rd[7], rd[8], 0,
            0, 0, 0, 1
        );
        // mat4.transpose();
        // R.transpose();

        //mat4.multiply( R );

        v3.fromArray( this.mean2 );
        pos.setFromMatrixPosition( mat4 );
        pos.add( v3 );
        mat4.setPosition( pos );

        mat4.transpose();
        _mat4.elements.set( mat4.elements );

        console.log( "super", _mat4.elements )

    }

};


NGL.superpose = function( s1, s2, align, sele1, sele2, xsele1, xsele2 ){

    align = align || false;
    sele1 = sele1 || "";
    sele2 = sele2 || "";
    xsele1 = xsele1 || "";
    xsele2 = xsele2 || "";

    var atoms1, atoms2;

    if( align ){

        var _s1 = s1;
        var _s2 = s2;

        if( sele1 && sele2 ){
            _s1 = new NGL.StructureSubset( s1, new NGL.Selection( sele1 ) );
            _s2 = new NGL.StructureSubset( s2, new NGL.Selection( sele2 ) );
        }

        var seq1 = _s1.getSequence();
        var seq2 = _s2.getSequence();

        // NGL.log( seq1.join("") );
        // NGL.log( seq2.join("") );

        var ali = new NGL.Alignment( seq1.join(""), seq2.join("") );

        ali.calc();
        ali.trace();

        // NGL.log( "superpose alignment score", ali.score );

        // NGL.log( ali.ali1 );
        // NGL.log( ali.ali2 );

        var l, _i, _j, x, y;
        var i = 0;
        var j = 0;
        var n = ali.ali1.length;
        var aliIdx1 = [];
        var aliIdx2 = [];

        for( l = 0; l < n; ++l ){

            x = ali.ali1[ l ];
            y = ali.ali2[ l ];

            _i = 0;
            _j = 0;

            if( x === "-" ){
                aliIdx2[ j ] = false;
            }else{
                aliIdx2[ j ] = true;
                _i = 1;
            }

            if( y === "-" ){
                aliIdx1[ i ] = false;
            }else{
                aliIdx1[ i ] = true;
                _j = 1;
            }

            i += _i;
            j += _j;

        }

        // NGL.log( i, j );

        // NGL.log( aliIdx1 );
        // NGL.log( aliIdx2 );

        atoms1 = new NGL.AtomSet();
        atoms2 = new NGL.AtomSet();

        i = 0;
        _s1.eachResidue( function( r ){

            if( !r.getResname1() || !r.getAtomByName( "CA" ) ) return;

            if( aliIdx1[ i ] ){
                atoms1.addAtom( r.getAtomByName( "CA" ) );
            }
            i += 1;

        } );

        i = 0;
        _s2.eachResidue( function( r ){

            if( !r.getResname1() || !r.getAtomByName( "CA" ) ) return;

            if( aliIdx2[ i ] ){
                atoms2.addAtom( r.getAtomByName( "CA" ) );
            }
            i += 1;

        } );

    }else{

        atoms1 = new NGL.AtomSet(
            s1, new NGL.Selection( sele1 + " and .CA" )
        );
        atoms2 = new NGL.AtomSet(
            s2, new NGL.Selection( sele2 + " and .CA" )
        );

    }

    if( xsele1 && xsele2 ){

        var _atoms1 = new NGL.AtomSet();
        var _atoms2 = new NGL.AtomSet();

        var xselection1 = new NGL.Selection( xsele1 );
        var xselection2 = new NGL.Selection( xsele2 );

        var test1 = xselection1.test;
        var test2 = xselection2.test;

        var i, a1, a2;
        var n = atoms1.atomCount;

        for( i = 0; i < n; ++i ){

            a1 = atoms1.atoms[ i ];
            a2 = atoms2.atoms[ i ];

            if( test1( a1 ) && test2( a2 ) ){

                _atoms1.addAtom( a1 );
                _atoms2.addAtom( a2 );

                // NGL.log( a1.qualifiedName(), a2.qualifiedName() )

            }

        }

        atoms1 = _atoms1;
        atoms2 = _atoms2;

    }

    var superpose = new NGL.Superposition( atoms1, atoms2 );

    var atoms = new NGL.AtomSet( s1, new NGL.Selection( "*" ) );
    superpose.transform( atoms );

    // if( s1.biomolDict ){

    //     console.log( s1.biomolDict );
    //     for( var biomolName in s1.biomolDict ){

    //         if( biomolName !== "BU1" ) return;

    //         var biomol = s1.biomolDict[ biomolName ];
    //         console.log( biomol )

    //         for( var matrixName in biomol.matrixDict ){

    //             var matrix = biomol.matrixDict[ matrixName ];
    //             console.log( matrix );

    //             superpose.transformMatrix4( matrix );

    //         }

    //     }

    // }

    s1.center = s1.atomCenter();

}

// File:js/ngl/structure.js

/**
 * @file Structure
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


// from Jmol http://jmol.sourceforge.net/jscolors/ (or 0xFFFFFF)
NGL.ElementColors = {
    "H": 0xFFFFFF, "HE": 0xD9FFFF, "LI": 0xCC80FF, "BE": 0xC2FF00, "B": 0xFFB5B5,
    "C": 0x909090, "N": 0x3050F8, "O": 0xFF0D0D, "F": 0x90E050, "NE": 0xB3E3F5,
    "NA": 0xAB5CF2, "MG": 0x8AFF00, "AL": 0xBFA6A6, "SI": 0xF0C8A0, "P": 0xFF8000,
    "S": 0xFFFF30, "CL": 0x1FF01F, "AR": 0x80D1E3, "K": 0x8F40D4, "CA": 0x3DFF00,
    "SC": 0xE6E6E6, "TI": 0xBFC2C7, "V": 0xA6A6AB, "CR": 0x8A99C7, "MN": 0x9C7AC7,
    "FE": 0xE06633, "CO": 0xF090A0, "NI": 0x50D050, "CU": 0xC88033, "ZN": 0x7D80B0,
    "GA": 0xC28F8F, "GE": 0x668F8F, "AS": 0xBD80E3, "SE": 0xFFA100, "BR": 0xA62929,
    "KR": 0x5CB8D1, "RB": 0x702EB0, "SR": 0x00FF00, "Y": 0x94FFFF, "ZR": 0x94E0E0,
    "NB": 0x73C2C9, "MO": 0x54B5B5, "TC": 0x3B9E9E, "RU": 0x248F8F, "RH": 0x0A7D8C,
    "PD": 0x006985, "AG": 0xC0C0C0, "CD": 0xFFD98F, "IN": 0xA67573, "SN": 0x668080,
    "SB": 0x9E63B5, "TE": 0xD47A00, "I": 0x940094, "XE": 0x940094, "CS": 0x57178F,
    "BA": 0x00C900, "LA": 0x70D4FF, "CE": 0xFFFFC7, "PR": 0xD9FFC7, "ND": 0xC7FFC7,
    "PM": 0xA3FFC7, "SM": 0x8FFFC7, "EU": 0x61FFC7, "GD": 0x45FFC7, "TB": 0x30FFC7,
    "DY": 0x1FFFC7, "HO": 0x00FF9C, "ER": 0x00E675, "TM": 0x00D452, "YB": 0x00BF38,
    "LU": 0x00AB24, "HF": 0x4DC2FF, "TA": 0x4DA6FF, "W": 0x2194D6, "RE": 0x267DAB,
    "OS": 0x266696, "IR": 0x175487, "PT": 0xD0D0E0, "AU": 0xFFD123, "HG": 0xB8B8D0,
    "TL": 0xA6544D, "PB": 0x575961, "BI": 0x9E4FB5, "PO": 0xAB5C00, "AT": 0x754F45,
    "RN": 0x428296, "FR": 0x420066, "RA": 0x007D00, "AC": 0x70ABFA, "TH": 0x00BAFF,
    "PA": 0x00A1FF, "U": 0x008FFF, "NP": 0x0080FF, "PU": 0x006BFF, "AM": 0x545CF2,
    "CM": 0x785CE3, "BK": 0x8A4FE3, "CF": 0xA136D4, "ES": 0xB31FD4, "FM": 0xB31FBA,
    "MD": 0xB30DA6, "NO": 0xBD0D87, "LR": 0xC70066, "RF": 0xCC0059, "DB": 0xD1004F,
    "SG": 0xD90045, "BH": 0xE00038, "HS": 0xE6002E, "MT": 0xEB0026, "DS": 0xFFFFFF,
    "RG": 0xFFFFFF, "CN": 0xFFFFFF, "UUT": 0xFFFFFF, "FL": 0xFFFFFF, "UUP": 0xFFFFFF,
    "LV": 0xFFFFFF, "UUH": 0xFFFFFF,

    "D": 0xFFFFC0, "T": 0xFFFFA0,

    "": 0xFFFFFF
};


// from Jmol http://jmol.sourceforge.net/jscolors/ (protein + shapely for nucleic)
/*NGL._ResidueColors = {
    "ALA": 0xC8C8C8,
    "ARG": 0x145AFF,
    "ASN": 0x00DCDC,
    "ASP": 0xE60A0A,
    "CYS": 0xE6E600,
    "GLN": 0x00DCDC,
    "GLU": 0xE60A0A,
    "GLY": 0xEBEBEB,
    "HIS": 0x8282D2,
    "ILE": 0x0F820F,
    "LEU": 0x0F820F,
    "LYS": 0x145AFF,
    "MET": 0xE6E600,
    "PHE": 0x3232AA,
    "PRO": 0xDC9682,
    "SER": 0xFA9600,
    "THR": 0xFA9600,
    "TRP": 0xB45AB4,
    "TYR": 0x3232AA,
    "VAL": 0x0F820F,

    "ASX": 0xFF69B4,
    "GLX": 0xFF69B4,
    "ASH": 0xFF69B4,
    "GLH": 0xFF69B4,

    "A": 0xA0A0FF,
    "G": 0xFF7070,
    "I": 0x80FFFF,
    "C": 0xFF8C4B,
    "T": 0xA0FFA0,
    "U": 0xFF8080,

    "DA": 0xA0A0FF,
    "DG": 0xFF7070,
    "DI": 0x80FFFF,
    "DC": 0xFF8C4B,
    "DT": 0xA0FFA0,
    "DU": 0xFF8080,

    "": 0xBEA06E
};*/
NGL.ResidueColors = {
    "ALA": 0x8CFF8C,
    "ARG": 0x00007C,
    "ASN": 0xFF7C70,
    "ASP": 0xA00042,
    "CYS": 0xFFFF70,
    "GLN": 0xFF4C4C,
    "GLU": 0x660000,
    "GLY": 0xFFFFFF,
    "HIS": 0x7070FF,
    "ILE": 0x004C00,
    "LEU": 0x455E45,
    "LYS": 0x4747B8,
    "MET": 0xB8A042,
    "PHE": 0x534C52,
    "PRO": 0x525252,
    "SER": 0xFF7042,
    "THR": 0xB84C00,
    "TRP": 0x4F4600,
    "TYR": 0x8C704C,
    "VAL": 0xFF8CFF,

    "ASX": 0xFF00FF,
    "GLX": 0xFF00FF,
    "ASH": 0xFF00FF,
    "GLH": 0xFF00FF,

    "A": 0xA0A0FF,
    "G": 0xFF7070,
    "I": 0x80FFFF,
    "C": 0xFF8C4B,
    "T": 0xA0FFA0,
    "U": 0xFF8080,

    "DA": 0xA0A0FF,
    "DG": 0xFF7070,
    "DI": 0x80FFFF,
    "DC": 0xFF8C4B,
    "DT": 0xA0FFA0,
    "DU": 0xFF8080,

    "": 0xFF00FF
};


// from Jmol http://jmol.sourceforge.net/jscolors/ (shapely)
NGL.StructureColors = {
    "alphaHelix": 0xFF0080,
    "3_10Helix": 0xA00080,
    "piHelix": 0x600080,
    "betaStrand": 0xFFC800,
    "betaTurn": 0x6080FF,
    "coil": 0xFFFFFF,

    "dna": 0xAE00FE,
    "rna": 0xFD0162,

    "carbohydrate": 0xA6A6FA,

    "": 0x808080
}


// PDB helix record encoding
NGL.HelixTypes = {
    1: "h",  // Right-handed alpha (default)
    2: "h",  // Right-handed omega
    3: "i",  // Right-handed pi
    4: "h",  // Right-handed gamma
    5: "g",  // Right-handed 310
    6: "h",  // Left-handed alpha
    7: "h",  // Left-handed omega
    8: "h",  // Left-handed gamma
    9: "h",  // 27 ribbon/helix
    10: "h",  // Polyproline
    "": "h",
}


// http://dx.doi.org/10.1021/jp8111556 (or 2.0)
NGL.VdwRadii = {
    "H": 1.1, "HE": 1.4, "LI": 1.81, "BE": 1.53, "B": 1.92, "C": 1.7,
    "N": 1.55, "O": 1.52, "F": 1.47, "NE": 1.54, "NA": 2.27, "MG": 1.73, "AL": 1.84,
    "SI": 2.1, "P": 1.8, "S": 1.8, "CL": 1.75, "AR": 1.88, "K": 2.75, "CA": 2.31,
    "SC": 2.3, "TI": 2.15, "V": 2.05, "CR": 2.05, "MN": 2.05, "FE": 2.05, "CO": 2.0,
    "NI": 2.0, "CU": 2.0, "ZN": 2.1, "GA": 1.87, "GE": 2.11, "AS": 1.85, "SE": 1.9,
    "BR": 1.83, "KR": 2.02, "RB": 3.03, "SR": 2.49, "Y": 2.4, "ZR": 2.3, "NB": 2.15,
    "MO": 2.1, "TC": 2.05, "RU": 2.05, "RH": 2.0, "PD": 2.05, "AG": 2.1, "CD": 2.2,
    "IN": 2.2, "SN": 1.93, "SB": 2.17, "TE": 2.06, "I": 1.98, "XE": 2.16, "CS": 3.43,
    "BA": 2.68, "LA": 2.5, "CE": 2.48, "PR": 2.47, "ND": 2.45, "PM": 2.43, "SM": 2.42,
    "EU": 2.4, "GD": 2.38, "TB": 2.37, "DY": 2.35, "HO": 2.33, "ER": 2.32, "TM": 2.3,
    "YB": 2.28, "LU": 2.27, "HF": 2.25, "TA": 2.2, "W": 2.1, "RE": 2.05, "OS": 2.0,
    "IR": 2.0, "PT": 2.05, "AU": 2.1, "HG": 2.05, "TL": 1.96, "PB": 2.02, "BI": 2.07,
    "PO": 1.97, "AT": 2.02, "RN": 2.2, "FR": 3.48, "RA": 2.83, "AC": 2.0, "TH": 2.4,
    "PA": 2.0, "U": 2.3, "NP": 2.0, "PU": 2.0, "AM": 2.0, "CM": 2.0, "BK": 2.0,
    "CF": 2.0, "ES": 2.0, "FM": 2.0, "MD": 2.0, "NO": 2.0, "LR": 2.0, "RF": 2.0,
    "DB": 2.0, "SG": 2.0, "BH": 2.0, "HS": 2.0, "MT": 2.0, "DS": 2.0, "RG": 2.0,
    "CN": 2.0, "UUT": 2.0, "FL": 2.0, "UUP": 2.0, "LV": 2.0, "UUH": 2.0,

    "": 2.0
};


// http://dx.doi.org/10.1039/b801115j (or 1.6)
NGL.CovalentRadii = {
    "H": 0.31, "HE": 0.28, "LI": 1.28, "BE": 0.96, "B": 0.84, "C": 0.76,
    "N": 0.71, "O": 0.66, "F": 0.57, "NE": 0.58, "NA": 1.66, "MG": 1.41, "AL": 1.21,
    "SI": 1.11, "P": 1.07, "S": 1.05, "CL": 1.02, "AR": 1.06, "K": 2.03, "CA": 1.76,
    "SC": 1.7, "TI": 1.6, "V": 1.53, "CR": 1.39, "MN": 1.39, "FE": 1.32, "CO": 1.26,
    "NI": 1.24, "CU": 1.32, "ZN": 1.22, "GA": 1.22, "GE": 1.2, "AS": 1.19, "SE": 1.2,
    "BR": 1.2, "KR": 1.16, "RB": 2.2, "SR": 1.95, "Y": 1.9, "ZR": 1.75, "NB": 1.64,
    "MO": 1.54, "TC": 1.47, "RU": 1.46, "RH": 1.42, "PD": 1.39, "AG": 1.45, "CD": 1.44,
    "IN": 1.42, "SN": 1.39, "SB": 1.39, "TE": 1.38, "I": 1.39, "XE": 1.4, "CS": 2.44,
    "BA": 2.15, "LA": 2.07, "CE": 2.04, "PR": 2.03, "ND": 2.01, "PM": 1.99, "SM": 1.98,
    "EU": 1.98, "GD": 1.96, "TB": 1.94, "DY": 1.92, "HO": 1.92, "ER": 1.89, "TM": 1.9,
    "YB": 1.87, "LU": 1.87, "HF": 1.75, "TA": 1.7, "W": 1.62, "RE": 1.51, "OS": 1.44,
    "IR": 1.41, "PT": 1.36, "AU": 1.36, "HG": 1.32, "TL": 1.45, "PB": 1.46, "BI": 1.48,
    "PO": 1.4, "AT": 1.5, "RN": 1.5, "FR": 2.6, "RA": 2.21, "AC": 2.15, "TH": 2.06,
    "PA": 2.0, "U": 1.96, "NP": 1.9, "PU": 1.87, "AM": 1.8, "CM": 1.69, "BK": 1.6,
    "CF": 1.6, "ES": 1.6, "FM": 1.6, "MD": 1.6, "NO": 1.6, "LR": 1.6, "RF": 1.6,
    "DB": 1.6, "SG": 1.6, "BH": 1.6, "HS": 1.6, "MT": 1.6, "DS": 1.6, "RG": 1.6,
    "CN": 1.6, "UUT": 1.6, "FL": 1.6, "UUP": 1.6, "LV": 1.6, "UUH": 1.6,

    "": 1.6
};


// Peter Rose (peter.rose@rcsb.org), private communication, average accross PDB
NGL.ResidueRadii = {
    "2QY": 6.58, "CY0": 11.98, "2QZ": 2.52, "CY1": 6.59, "HHK": 5.11, "CXM": 4.69, "HHI": 4.58, "CY4": 4.57,
    "S12": 18.57, "CY3": 2.79, "C5C": 5.35, "PFX": 11.84, "2R3": 6.94, "2R1": 3.78, "ILX": 4.99, "32S": 5.68,
    "BTK": 8.59, "32T": 5.72, "FAK": 9.8, "B27": 2.78, "ILM": 3.84, "C4R": 5.63, "32L": 6.75, "SYS": 3.01,
    "1MH": 5.04, "ILE": 3.65, "YNM": 6.39, "2RX": 4.91, "B3A": 2.48, "GEE": 4.76, "7MN": 7.34, "B3E": 5.4,
    "ARG": 6.33, "200": 6.89, "HIP": 5.47, "HIA": 4.64, "B3K": 5.89, "HIC": 5.76, "B3L": 4.96, "B3M": 5.07,
    "ARM": 6.86, "ARO": 7.35, "AR4": 8.42, "PG1": 10.67, "YOF": 6.44, "IML": 3.74, "SXE": 6.65, "HIQ": 7.98,
    "PFF": 6.31, "HIS": 4.52, "0TD": 3.62, "C3Y": 5.24, "1OP": 11.55, "02Y": 4.77, "02V": 4.83, "ASB": 5.59,
    "30V": 8.53, "S2P": 4.81, "ASP": 3.55, "ASN": 3.54, "2OR": 6.91, "QMM": 6.13, "2P0": 8.52, "ASL": 5.36,
    "HFA": 5.14, "5PG": 5.69, "B3X": 4.38, "AS9": 4.1, "ARV": 7.59, "B3U": 6.06, "S2C": 7.54, "B3T": 3.34,
    "175": 5.64, "GFT": 8.18, "HG7": 6.8, "B3Q": 4.48, "ASA": 3.64, "02K": 2.94, "B3Y": 7.45, "PHD": 5.35,
    "C6C": 6.42, "BUC": 5.8, "HGL": 8.07, "PHE": 5.06, "03Y": 2.6, "PHA": 5.11, "OCY": 5.0, "4PH": 6.79,
    "5OH": 4.7, "31Q": 10.46, "BTR": 7.98, "3PX": 4.7, "1PA": 8.07, "ASX": 3.54, "IOR": 7.23, "03E": 3.38,
    "PHL": 5.17, "KWS": 5.09, "PHI": 7.12, "NAL": 7.22, "S1H": 19.21, "2ML": 3.86, "2MR": 7.35, "GHG": 4.83,
    "TYY": 6.54, "2MT": 3.67, "56A": 13.01, "SVA": 5.46, "TYX": 8.31, "TYS": 8.59, "TYR": 6.38, "TYQ": 6.43,
    "HLU": 3.99, "MYK": 19.47, "TYO": 7.71, "HLX": 4.98, "TYN": 9.87, "TYJ": 6.25, "TYI": 6.49, "LYH": 5.13,
    "LYF": 12.19, "SUN": 6.73, "LYR": 18.28, "TYB": 6.46, "11W": 14.39, "LYS": 5.54, "LYN": 4.8, "11Q": 4.85,
    "LYO": 4.71, "LYZ": 1.76, "TXY": 6.44, "MYN": 4.71, "TY5": 10.6, "HMR": 5.09, "01W": 8.55, "LYX": 13.36,
    "TY8": 7.22, "TY2": 6.49, "KYN": 6.18, "KYQ": 9.75, "CZZ": 5.14, "IIL": 3.81, "HNC": 10.41, "OIC": 4.62,
    "LVN": 2.89, "QIL": 3.84, "JJL": 8.3, "VAH": 3.88, "JJJ": 7.5, "JJK": 7.43, "VAD": 2.56, "CYW": 4.65,
    "0QL": 5.72, "143": 8.22, "SVX": 7.04, "CYJ": 11.64, "SVY": 7.1, "SVZ": 6.6, "CYG": 8.03, "CYF": 13.54,
    "SVV": 5.09, "GL3": 2.72, "8SP": 14.26, "CYS": 2.78, "004": 4.33, "CYR": 10.33, "PLJ": 3.71, "EXY": 7.37,
    "HL2": 3.75, "A5N": 5.21, "CYQ": 5.67, "CZ2": 5.16, "LWY": 4.12, "PM3": 8.78, "OHS": 6.98, "OHI": 5.35,
    "3TY": 8.42, "CYD": 8.55, "DYS": 7.87, "DAH": 6.47, "4IK": 11.81, "3EG": 3.66, "AYA": 3.65, "4IN": 6.31,
    "DAB": 3.48, "4HT": 6.03, "RGL": 7.03, "DAM": 2.49, "NFA": 5.04, "WFP": 6.07, "2JC": 2.97, "HAR": 7.55,
    "2JG": 5.67, "MH6": 1.72, "2JF": 9.13, "3FG": 4.96, "MGN": 4.84, "AZH": 5.36, "AZK": 6.03, "ZBZ": 7.79,
    "TBG": 2.58, "VAL": 2.51, "MGG": 7.34, "AZS": 5.61, "FHL": 9.75, "2JH": 4.56, "IEL": 7.07, "FHO": 6.75,
    "DA2": 7.79, "FH7": 6.99, "ME0": 4.52, "3GL": 4.84, "MDO": 5.03, "AZY": 7.37, "A8E": 3.76, "ZCL": 6.71,
    "MDH": 2.58, "LA2": 14.07, "4FW": 6.1, "YCM": 5.32, "MDF": 4.95, "YCP": 3.01, "TEF": 8.63, "FGP": 4.34,
    "UF0": 19.72, "XCN": 4.57, "FGL": 2.56, "MF3": 6.37, "MEQ": 5.13, "LAA": 3.23, "IGL": 5.52, "MET": 4.49,
    "NIY": 6.81, "QCS": 5.18, "TCQ": 8.56, "MEN": 4.33, "4HL": 8.79, "MEA": 4.95, "EFC": 5.28, "LAL": 2.41,
    "2HF": 5.52, "KBE": 5.64, "OCS": 3.94, "CAF": 5.46, "NC1": 11.4, "NBQ": 9.82, "CAB": 4.19, "MBQ": 9.55,
    "193": 7.38, "192": 2.44, "0WZ": 7.61, "CAS": 5.35, "NB8": 11.98, "OBS": 11.71, "1AC": 2.42, "PCA": 3.48,
    "MCL": 9.73, "LBY": 7.75, "GAU": 4.67, "PBF": 9.75, "MCG": 6.46, "DDE": 6.86, "19W": 3.94, "MD5": 9.33,
    "MD6": 6.44, "MD3": 8.41, "MCS": 7.56, "OBF": 3.64, "UAL": 4.68, "PAT": 6.05, "IAM": 8.88, "PAQ": 8.77,
    "FDL": 9.49, "NCB": 3.45, "LCK": 9.81, "DDZ": 2.52, "2FM": 5.54, "IAR": 6.77, "OAS": 4.8, "HBN": 8.8,
    "TA4": 5.55, "1C3": 7.43, "ECX": 5.51, "PF5": 6.28, "RE3": 5.29, "FCL": 6.25, "ECC": 4.79, "LDH": 7.06,
    "NCY": 2.91, "CCS": 4.58, "PEC": 6.54, "2CO": 4.45, "LE1": 2.72, "HCM": 5.53, "07O": 8.05, "HCL": 4.96,
    "NEP": 6.94, "PE1": 8.01, "LEF": 4.37, "FC0": 5.18, "LED": 4.34, "HCS": 4.09, "DBU": 2.49, "RE0": 5.53,
    "LEN": 3.82, "1E3": 8.71, "BB9": 2.56, "BB8": 5.14, "PCS": 5.05, "BB7": 4.56, "BB6": 2.62, "LEU": 3.83,
    "DBZ": 7.08, "LET": 11.29, "DBY": 6.46, "ICY": 7.76, "MAA": 2.4, "CGA": 7.91, "5CS": 8.34, "UGY": 3.7,
    "LGY": 11.71, "N10": 8.96, "AAR": 6.39, "FT6": 7.5, "MOD": 12.62, "5CW": 7.21, "PVH": 4.58, "BBC": 6.42,
    "YYA": 7.3, "O12": 14.08, "NOT": 7.15, "KGC": 9.88, "MP4": 5.86, "0CS": 4.07, "MP8": 3.75, "VLL": 2.54,
    "VLM": 2.51, "BCS": 8.03, "MNL": 4.9, "AA4": 4.47, "SAC": 3.49, "BCX": 2.99, "3CF": 6.47, "SAH": 11.7,
    "NNH": 6.86, "CGU": 4.71, "SIB": 12.41, "TLY": 8.78, "SIC": 4.81, "VMS": 8.82, "TMD": 6.76, "MMO": 6.53,
    "PXU": 2.46, "4AW": 6.22, "OTH": 3.6, "DLS": 6.84, "MME": 4.99, "DM0": 6.99, "0FL": 2.76, "SBL": 8.96,
    "CDV": 3.72, "OTY": 6.51, "PYA": 7.75, "2AS": 3.57, "DMH": 4.92, "ELY": 7.42, "GVL": 9.6, "FVA": 2.9,
    "SAR": 2.48, "4BF": 6.92, "EME": 4.69, "CDE": 2.51, "3AR": 7.86, "3AH": 9.11, "AC5": 2.44, "FTR": 6.08,
    "MLL": 3.76, "NPH": 11.66, "NPI": 6.9, "DMT": 6.67, "PYX": 11.3, "MLE": 3.87, "PYL": 9.67, "ZZU": 6.94,
    "H5M": 3.61, "SCH": 4.46, "DMK": 3.52, "FTY": 9.07, "2AG": 3.7, "ABA": 2.55, "ZZJ": 2.44, "MLZ": 6.8,
    "MLY": 6.88, "KCX": 7.28, "ZZD": 8.16, "3A5": 5.37, "LHC": 7.75, "9AT": 2.47, "OZT": 3.4, "THO": 2.62,
    "THR": 2.5, "DFI": 3.93, "MKD": 6.42, "4CY": 4.6, "SDP": 6.07, "DFO": 3.94, "0A0": 3.45, "4DB": 9.73,
    "ML3": 6.26, "BG1": 8.02, "SD4": 4.57, "THC": 3.8, "SCS": 5.48, "TH5": 4.65, "BFD": 5.33, "AEI": 6.34,
    "TH6": 2.85, "SCY": 4.53, "TIS": 4.81, "SEE": 4.53, "BHD": 3.48, "SEB": 8.18, "SEC": 2.96, "SEP": 4.8,
    "CLH": 7.13, "TIH": 5.02, "CLG": 13.62, "SEN": 6.43, "XXA": 7.34, "SEL": 2.46, "SE7": 4.19, "4CF": 7.72,
    "G8M": 3.57, "BH2": 3.51, "UN2": 3.22, "VR0": 10.51, "MK8": 4.76, "DHA": 2.32, "LMQ": 4.69, "SFE": 5.01,
    "AHB": 3.47, "OXX": 7.05, "BIF": 9.63, "IZO": 4.47, "NMM": 8.25, "0BN": 7.0, "HZP": 3.12, "NMC": 4.23,
    "DHL": 2.69, "9DS": 9.29, "SER": 2.41, "CHG": 4.2, "MIR": 6.54, "AGQ": 7.79, "SET": 2.46, "MIS": 6.32,
    "4FB": 3.08, "0AR": 8.46, "LME": 3.99, "FZN": 24.42, "AGT": 9.04, "IYR": 6.46, "9DN": 9.31, "CHP": 5.75,
    "UNK": 1.64, "XX1": 9.92, "AGM": 6.57, "0AH": 5.78, "LLP": 10.22, "0AF": 6.72, "4DP": 9.28, "HYP": 2.25,
    "DIR": 5.8, "LLY": 8.71, "0AK": 6.11, "NLE": 4.67, "OYL": 6.42, "WVL": 4.69, "0A8": 8.1, "NLY": 6.37,
    "MHO": 4.89, "VOL": 2.55, "0A1": 7.1, "MHL": 3.92, "NLP": 4.81, "NLQ": 4.65, "MHW": 2.74, "BIL": 4.7,
    "NLO": 4.8, "MHU": 7.51, "XW1": 9.36, "LLO": 10.13, "SGB": 6.88, "MHV": 3.6, "MHS": 4.51, "0A9": 5.17,
    "0LF": 9.96, "HT7": 6.82, "X2W": 6.6, "YPZ": 9.38, "I58": 6.73, "FLA": 2.4, "M0H": 4.83, "HSL": 2.46,
    "FLE": 6.17, "KOR": 10.1, "1VR": 3.89, "HSO": 4.56, "TTS": 9.41, "RVX": 7.01, "TTQ": 7.71, "H14": 5.27,
    "HTI": 7.8, "ONH": 6.14, "LP6": 8.58, "ONL": 4.83, "AHH": 5.06, "HS8": 7.4, "HS9": 4.71, "BL2": 5.82,
    "AHP": 5.26, "6HN": 7.34, "HRP": 5.46, "POM": 3.6, "WPA": 5.11, "2ZC": 4.29, "CPC": 2.65, "AIB": 2.4,
    "XSN": 3.47, "M2S": 5.28, "GND": 6.67, "GNC": 4.6, "MVA": 2.56, "OLZ": 5.32, "M2L": 6.15, "TRF": 6.69,
    "NZH": 7.66, "SRZ": 5.27, "OLD": 10.47, "CME": 5.86, "CMH": 5.3, "ALA": 2.38, "TRQ": 7.36, "PPN": 7.24,
    "TRP": 6.07, "TRO": 5.82, "TRN": 5.95, "NYS": 8.1, "ALC": 5.26, "U3X": 11.7, "HVA": 2.58, "TS9": 3.92,
    "TRX": 7.27, "TRW": 11.8, "LPL": 7.51, "GMA": 4.4, "OMT": 5.07, "CMT": 3.54, "GME": 4.66, "NYB": 6.07,
    "PR3": 5.12, "LPD": 2.48, "GLU": 4.49, "1X6": 6.84, "LPG": 2.39, "GLX": 4.52, "PR4": 4.52, "CML": 6.16,
    "FME": 4.52, "HTR": 6.48, "PR7": 4.66, "Z3E": 7.2, "GLZ": 2.39, "BMT": 6.37, "WRP": 8.16, "GLY": 2.37,
    "OMY": 6.11, "MTY": 5.46, "OMX": 6.15, "GLN": 4.46, "2XA": 8.25, "28X": 7.84, "7JA": 9.46, "FLT": 9.65,
    "GLJ": 3.7, "OMH": 5.26, "TSY": 4.26, "PRV": 4.28, "CS4": 11.21, "DOA": 12.33, "23P": 5.42, "CS3": 8.24,
    "6CL": 6.47, "PRR": 5.58, "KST": 11.58, "CS1": 7.23, "PRS": 2.63, "ZYJ": 11.4, "IT1": 9.75, "UU5": 4.98,
    "ESB": 6.69, "UU4": 2.49, "ESC": 5.65, "LSO": 10.58, "ZYK": 11.45, "9NV": 8.99, "23F": 5.27, "ORN": 4.25,
    "HOX": 6.61, "CSD": 3.95, "FP9": 3.03, "DO2": 4.44, "SLL": 11.53, "P3Q": 9.54, "ORQ": 6.04, "MSL": 5.21,
    "DNP": 2.45, "CSB": 3.51, "WLU": 4.24, "CSA": 5.7, "MT2": 5.51, "CSO": 3.53, "TPO": 4.73, "MSP": 13.11,
    "23S": 6.09, "MSO": 4.96, "PRO": 2.41, "TPL": 5.41, "DNS": 8.79, "CSK": 3.91, "Z70": 7.4, "CSJ": 7.51,
    "DNW": 7.97, "PRK": 9.15, "GSU": 11.81, "LTA": 6.57, "HPE": 6.63, "TPQ": 6.48, "PRJ": 5.26, "PSW": 4.65,
    "L3O": 3.89, "CSU": 4.89, "ALY": 7.38, "M3L": 7.12, "CSW": 3.68, "XPR": 7.68, "D4P": 5.66, "FOE": 8.17,
    "SLZ": 5.69, "CSP": 5.26, "TQI": 7.68, "ALT": 2.72, "CSR": 5.42, "CSS": 3.61, "M3R": 7.18, "ALO": 2.57,
    "R4K": 4.67, "SMF": 9.0, "MSA": 2.73, "SMC": 3.39, "CSX": 3.47, "SME": 4.8, "ETA": 2.4, "CSZ": 3.6,
    "22G": 8.8, "MSE": 4.62, "ALN": 6.16, "PSH": 7.26, "CTE": 7.27, "DON": 6.72, "CTH": 3.45, "U2X": 11.54,
    "6CW": 7.56, "TQZ": 6.97, "3YM": 6.52, "OSE": 4.49, "2VA": 9.82, "TQQ": 7.76, "NRG": 8.35, "BPE": 7.24,
    "F2F": 6.25, "1TQ": 8.58, "I2M": 3.13, "NVA": 3.76, "R1A": 8.2, "QPA": 6.95, "C1X": 11.63, "FRD": 5.05,
    "HR7": 6.98, "SNC": 3.93, "QPH": 5.15, "26B": 8.39, "DPQ": 6.54, "DPP": 2.51, "2TY": 8.65, "TNR": 6.88,
    "PTH": 8.35, "DPL": 3.58, "APK": 8.79, "1TY": 8.84, "HRG": 7.36, "PTM": 8.74, "1U8": 3.62, "PTR": 8.64,
    "LVG": 3.01, "6FL": 4.85, "SOC": 4.05, "KPI": 9.79, "IPG": 2.91, "P2Y": 2.51, "N2C": 3.55, "T0I": 7.34,
    "MPH": 5.29, "R2T": 4.71, "TOX": 6.78, "P2Q": 9.8, "GPL": 10.77, "MPJ": 5.07, "F2Y": 6.2, "T11": 8.58,
    "9NR": 9.33, "FPR": 8.85, "9NF": 8.93, "KPY": 10.17, "9NE": 9.77, "TOQ": 7.5, "MPQ": 4.2, "FPK": 3.08,
    "HQA": 7.25, "SOY": 10.94,

    "": 5.0
};


// http://blanco.biomol.uci.edu/Whole_residue_HFscales.txt
NGL.ResidueHydrophobicity = {
    // AA  DGwif   DGwoct  Oct-IF
    "ALA": [  0.17,  0.50,  0.33 ],
    "ARG": [  0.81,  1.81,  1.00 ],
    "ASN": [  0.42,  0.85,  0.43 ],
    "ASP": [  1.23,  3.64,  2.41 ],
    "ASH": [ -0.07,  0.43,  0.50 ],
    "CYS": [ -0.24, -0.02,  0.22 ],
    "GLN": [  0.58,  0.77,  0.19 ],
    "GLU": [  2.02,  3.63,  1.61 ],
    "GLH": [ -0.01,  0.11,  0.12 ],
    "GLY": [  0.01,  1.15,  1.14 ],
    // "His+": [  0.96,  2.33,  1.37 ],
    "HIS": [  0.17,  0.11, -0.06 ],
    "ILE": [ -0.31, -1.12, -0.81 ],
    "LEU": [ -0.56, -1.25, -0.69 ],
    "LYS": [  0.99,  2.80,  1.81 ],
    "MET": [ -0.23, -0.67, -0.44 ],
    "PHE": [ -1.13, -1.71, -0.58 ],
    "PRO": [  0.45,  0.14, -0.31 ],
    "SER": [  0.13,  0.46,  0.33 ],
    "THR": [  0.14,  0.25,  0.11 ],
    "TRP": [ -1.85, -2.09, -0.24 ],
    "TYR": [ -0.94, -0.71,  0.23 ],
    "VAL": [  0.07, -0.46, -0.53 ],

    "": [ 0.00, 0.00, 0.00 ]
};


NGL.guessElement = function(){

    var elm1 = [ "H", "C", "O", "N", "S", "P" ];
    var elm2 = [ "NA", "CL" ];

    return function( atomName ){

        var at = atomName.trim().toUpperCase();
        if( parseInt( at.charAt( 0 ) ) ) at = at.substr( 1 );
        // parse again to check for a second integer
        if( parseInt( at.charAt( 0 ) ) ) at = at.substr( 1 );
        var n = at.length;

        if( n===0 ) return "";

        if( n===1 ) return at;

        if( n===2 ){

            if( elm2.indexOf( at )!==-1 ) return at;

            if( elm1.indexOf( at[0] )!==-1 ) return at[0];

        }

        if( n>=3 ){

            if( elm1.indexOf( at[0] )!==-1 ) return at[0];

        }

        return "";

    };

}();


// molecule types
NGL.UnknownType = 0;
NGL.CgType = 1;
NGL.ProteinType = 2;
NGL.ProteinBackboneType = 3;
NGL.NucleicType = 4;
NGL.RnaBackboneType = 5;
NGL.DnaBackboneType = 6;
NGL.WaterType = 7;


NGL.AA1 = {
    'HIS': 'H',
    'ARG': 'R',
    'LYS': 'K',
    'ILE': 'I',
    'PHE': 'F',
    'LEU': 'L',
    'TRP': 'W',
    'ALA': 'A',
    'MET': 'M',
    'PRO': 'P',
    'CYS': 'C',
    'ASN': 'N',
    'VAL': 'V',
    'GLY': 'G',
    'SER': 'S',
    'GLN': 'Q',
    'TYR': 'Y',
    'ASP': 'D',
    'GLU': 'E',
    'THR': 'T',

    'ASH': 'D',
    'GLH': 'E',

    'UNK': '',
};


////////////
// GidPool

NGL.GidPool = {

    // REMEMBER not synced with worker

    nextGid: 1,

    objectList: [],

    rangeList: [],

    addObject: function( object ){

        NGL.GidPool.objectList.push( object );

        NGL.GidPool.rangeList.push( NGL.GidPool.allocateGidRange( object ) );

        return NGL.GidPool;

    },

    removeObject: function( object ){

        var idx = NGL.GidPool.objectList.indexOf( object );

        if( idx !== -1 ){

            NGL.GidPool.objectList.splice( idx, 1 );
            NGL.GidPool.rangeList.splice( idx, 1 );

            if( NGL.GidPool.objectList.length === 0 ){
                NGL.GidPool.nextGid = 1;
            }

        }

        return NGL.GidPool;

    },

    updateObject: function( object, silent ){

        var idx = NGL.GidPool.objectList.indexOf( object );

        if( idx !== -1 ){

            var range = NGL.GidPool.rangeList[ idx ];

            if( range[1] === NGL.GidPool.nextGid ){

                var count = NGL.GidPool.getGidCount( object );
                NGL.GidPool.nextGid += count - ( range[1] - range[0] );
                range[ 1 ] = NGL.GidPool.nextGid;

            }else{

                NGL.GidPool.rangeList[ idx ] = NGL.GidPool.allocateGidRange( object );

            }

        }else{

            if( !silent ){

                NGL.warn( "NGL.GidPool.updateObject: object not found." );

            }

        }

        return NGL.GidPool;

    },

    getGidCount: function( object ){

        var count = 0;

        if( object instanceof NGL.Structure ){

            count = object.atomCount;

        }else if( object instanceof NGL.BondSet ){

            count = object.bondCount;

        }else if( object instanceof NGL.Volume ){

            count = object.__data.length;

        }

        return count;

    },

    allocateGidRange: function( object ){

        var firstGid = NGL.GidPool.nextGid;

        NGL.GidPool.nextGid += NGL.GidPool.getGidCount( object );

        if( NGL.GidPool.nextGid > Math.pow( 2, 24 ) ){
            NGL.error( "GidPool overflown" );
        }

        return [ firstGid, NGL.GidPool.nextGid ];

    },

    freeGidRange: function( object ){

        // TODO

    },

    getNextGid: function(){

        return NGL.GidPool.nextGid++;

    },

    getGid: function( object, offset ){

        offset = offset || 0;

        var gid = 0;
        var idx = NGL.GidPool.objectList.indexOf( object );

        if( idx !== -1 ){

            var range = NGL.GidPool.rangeList[ idx ];
            var first = range[ 0 ];

            gid = first + offset;

        }else{

            NGL.warn( "NGL.GidPool.getGid: object not found." );

        }

        return gid;

    },

    getByGid: function( gid ){

        // TODO
        // - early exit
        // - binary search

        var entity;

        NGL.GidPool.objectList.forEach( function( o, i ){

            if( o instanceof NGL.Structure ){

                o.eachAtom( function( a ){

                    if( NGL.GidPool.getGid( o, a.index ) === gid ){
                        entity = a;
                    }

                } );

            }else if( o instanceof NGL.BondSet ){

                o.eachBond( function( b ){

                    if( NGL.GidPool.getGid( o, b.index ) === gid ){
                        entity = b;
                    }

                } );

            }else if( o instanceof NGL.Volume ){

                var range = NGL.GidPool.rangeList[ i ];

                if( gid >= range[ 0 ] && gid < range[ 1 ] ){

                    var offset = gid - range[ 0 ];

                    entity = {
                        volume: o,
                        index: offset,
                        value: o.data[ offset ],
                        x: o.dataPosition[ offset * 3 ],
                        y: o.dataPosition[ offset * 3 + 1 ],
                        z: o.dataPosition[ offset * 3 + 2 ],
                    };

                }

            }

        } );

        return entity;

    }

}


///////////////
// ColorMaker

NGL.ColorMakerRegistry = {

    signals: {

        // typesChanged: new signals.Signal(),

    },

    scales: {

        "": "",

        // Sequential
        "OrRd": "[S] Orange-Red",
        "PuBu": "[S] Purple-Blue",
        "BuPu": "[S] Blue-Purple",
        "Oranges": "[S] Oranges",
        "BuGn": "[S] Blue-Green",
        "YlOrBr": "[S] Yellow-Orange-Brown",
        "YlGn": "[S] Yellow-Green",
        "Reds": "[S] Reds",
        "RdPu": "[S] Red-Purple",
        "Greens": "[S] Greens",
        "YlGnBu": "[S] Yellow-Green-Blue",
        "Purples": "[S] Purples",
        "GnBu": "[S] Green-Blue",
        "Greys": "[S] Greys",
        "YlOrRd": "[S] Yellow-Orange-Red",
        "PuRd": "[S] Purple-Red",
        "Blues": "[S] Blues",
        "PuBuGn": "[S] Purple-Blue-Green",

        // Diverging
        "Spectral": "[D] Spectral",
        "RdYlGn": "[D] Red-Yellow-Green",
        "RdBu": "[D] Red-Blue",
        "PiYG": "[D] Pink-Yellowgreen",
        "PRGn": "[D] Purplered-Green",
        "RdYlBu": "[D] Red-Yellow-Blue",
        "BrBG": "[D] Brown-Bluegreen",
        "RdGy": "[D] Red-Grey",
        "PuOr": "[D] Purple-Orange",

        // Qualitative
        "Set1": "[Q] Set1",
        "Set2": "[Q] Set2",
        "Set3": "[Q] Set3",
        "Dark2": "[Q] Dark2",
        "Paired": "[Q] Paired",
        "Pastel1": "[Q] Pastel1",
        "Pastel2": "[Q] Pastel2",
        "Accent": "[Q] Accent",

        // Other
        "roygb": "[?] Rainbow",
        "rwb": "[?] Red-White-Blue",

    },

    modes: {

        "": "",

        "rgb": "Red Green Blue",
        "hsv": "Hue Saturation Value",
        "hsl": "Hue Saturation Lightness",
        "hsi": "Hue Saturation Intensity",
        "lab": "CIE L*a*b*",
        "hcl": "Hue Chroma Lightness"

    },

    types: {},

    userSchemes: {},

    getScheme: function( params ){

        var p = params || {};

        var id = p.scheme || "";

        var schemeClass;

        if( id in NGL.ColorMakerRegistry.types ){

            schemeClass = NGL.ColorMakerRegistry.types[ id ];

        }else if( id in NGL.ColorMakerRegistry.userSchemes ){

            schemeClass = NGL.ColorMakerRegistry.userSchemes[ id ];

        }else{

            schemeClass = NGL.ColorMaker;

        }

        return new schemeClass( params );

    },

    getPickingScheme: function( params ){

        var p = Object.assign( params || {} );
        p.scheme = "picking";

        return NGL.ColorMakerRegistry.getScheme( p );

    },

    getTypes: function(){

        var types = {};

        Object.keys( NGL.ColorMakerRegistry.types ).forEach( function( k ){
            // NGL.ColorMakerRegistry.types[ k ]
            types[ k ] = k;
        } );

        Object.keys( NGL.ColorMakerRegistry.userSchemes ).forEach( function( k ){
            types[ k ] = k.split( "|" )[ 1 ];
        } );

        return types;

    },

    getScales: function(){

        return NGL.ColorMakerRegistry.scales;

    },

    getModes: function(){

        return NGL.ColorMakerRegistry.modes;

    },

    addScheme: function( scheme, label ){

        if( !( scheme instanceof NGL.ColorMaker ) ){

            scheme = NGL.ColorMakerRegistry.createScheme( scheme, label );

        }

        label = label || "";
        var id = "" + THREE.Math.generateUUID() + "|" + label;

        NGL.ColorMakerRegistry.userSchemes[ id ] = scheme;
        // NGL.ColorMakerRegistry.signals.typesChanged.dispatch();

        return id;

    },

    removeScheme: function( id ){

        delete NGL.ColorMakerRegistry.userSchemes[ id ];
        // NGL.ColorMakerRegistry.signals.typesChanged.dispatch();

    },

    createScheme: function( constructor, label ){

        var ColorMaker = function( params ){

            NGL.ColorMaker.call( this, params );

            this.label = label || "";

            constructor.call( this, params );

        }

        ColorMaker.prototype = NGL.ColorMaker.prototype;

        ColorMaker.prototype.constructor = ColorMaker;

        return ColorMaker;

    },

    addSelectionScheme: function( pairList, label ){

        return NGL.ColorMakerRegistry.addScheme( function( params ){

            var colorList = [];
            var selectionList = [];

            pairList.forEach( function( pair ){

                colorList.push( new THREE.Color( pair[ 0 ] ).getHex() );
                selectionList.push( new NGL.Selection( pair[ 1 ] ) );

            } );

            var n = pairList.length;

            this.atomColor = function( a ){

                for( var i = 0; i < n; ++i ){

                    if( selectionList[ i ].test( a ) ){

                        return colorList[ i ];

                    }

                }

                return 0xFFFFFF;

            };

        }, label );

    }

}


NGL.ColorMaker = function( params ){

    var p = params || {};

    this.scale = p.scale || "uniform";
    this.mode = p.mode || "hcl";
    this.domain = p.domain || [ 0, 1 ];
    this.value = new THREE.Color( p.value || 0xFFFFFF ).getHex();

    this.structure = p.structure;
    this.bondSet = p.bondSet;
    this.volume = p.volume;
    this.surface = p.surface;

};

NGL.ColorMaker.prototype = {

    constructor: NGL.ColorMaker,

    getScale: function( params ){

        var p = params || {};

        var scale = p.scale || this.scale;
        if( scale === "rainbow" || scale === "roygb" ){
            scale = [ "red", "orange", "yellow", "green", "blue" ];
        }else if( scale === "rwb" ){
            scale = [ "red", "white", "blue" ];
        }

        return chroma
            .scale( scale )
            .mode( p.mode || this.mode )
            .domain( p.domain || this.domain )
            .out( "num" );

    },

    atomColor: function( a ){

        return 0xFFFFFF;

    },

    atomColorToArray: function( a, array, offset ){

        var c = this.atomColor( a );

        if( array === undefined ) array = [];
        if( offset === undefined ) offset = 0;

        array[ offset + 0 ] = ( c >> 16 & 255 ) / 255;
        array[ offset + 1 ] = ( c >> 8 & 255 ) / 255;
        array[ offset + 2 ] = ( c & 255 ) / 255;

        return array;

    },

    bondColor: function( b, fromTo ){

        return this.atomColor( fromTo ? b.atom1 : b.atom2 );

    },

    bondColorToArray: function( b, fromTo, array, offset ){

        var c = this.bondColor( b, fromTo );

        if( array === undefined ) array = [];
        if( offset === undefined ) offset = 0;

        array[ offset + 0 ] = ( c >> 16 & 255 ) / 255;
        array[ offset + 1 ] = ( c >> 8 & 255 ) / 255;
        array[ offset + 2 ] = ( c & 255 ) / 255;

        return array;

    },

    volumeColor: function( i ){

        return 0xFFFFFF;

    },

    volumeColorToArray: function( i, array, offset ){

        var c = this.volumeColor( i );

        if( array === undefined ) array = [];
        if( offset === undefined ) offset = 0;

        array[ offset + 0 ] = ( c >> 16 & 255 ) / 255;
        array[ offset + 1 ] = ( c >> 8 & 255 ) / 255;
        array[ offset + 2 ] = ( c & 255 ) / 255;

        return array;

    }

};


NGL.ValueColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    var valueScale = this.getScale();

    this.volumeColor = function( i ){

        return valueScale( this.volume.data[ i ] );

    };

};

NGL.ValueColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.ValueColorMaker.prototype.constructor = NGL.ValueColorMaker;


NGL.PickingColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    this.atomColor = function( a ){

        return NGL.GidPool.getGid( this.structure, a.index );

    };

    this.bondColor = function( b, fromTo ){

        return NGL.GidPool.getGid( this.bondSet, b.index );

    };

    this.volumeColor = function( i ){

        return NGL.GidPool.getGid( this.volume, i );

    };

};

NGL.PickingColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.PickingColorMaker.prototype.constructor = NGL.PickingColorMaker;


NGL.RandomColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    this.atomColor = function( a ){

        return Math.random() * 0xFFFFFF;

    };

};

NGL.RandomColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.RandomColorMaker.prototype.constructor = NGL.RandomColorMaker;


NGL.UniformColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    var color = this.value;

    this.atomColor = function(){

        return color;

    };

    this.bondColor = function(){

        return color;

    };

    this.valueColor = function(){

        return color;

    };

};

NGL.UniformColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.UniformColorMaker.prototype.constructor = NGL.UniformColorMaker;


NGL.AtomindexColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    if( !params.scale ){
        this.scale = "roygb";
    }

    if( !params.domain ){
        this.domain = [ 0, this.structure.atomCount ];
    }

    var atomindexScale = this.getScale();

    this.atomColor = function( a ){

        return atomindexScale( a.index );

    };

};

NGL.AtomindexColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.AtomindexColorMaker.prototype.constructor = NGL.AtomindexColorMaker;


NGL.ResidueindexColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    if( !params.scale ){
        this.scale = "roygb";
    }

    if( !params.domain ){
        this.domain = [ 0, this.structure.residueCount ];
    }

    var residueindexScale = this.getScale();

    this.atomColor = function( a ){

        return residueindexScale( a.residue.index );

    };

};

NGL.ResidueindexColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.ResidueindexColorMaker.prototype.constructor = NGL.ResidueindexColorMaker;


NGL.ChainindexColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    if( !params.scale ){
        this.scale = "Spectral";
    }

    if( !params.domain ){
        this.domain = [ 0, this.structure.chainCount ];
    }

    var chainindexScale = this.getScale();

    var chainNames = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                      "abcdefghijklmnopqrstuvwxyz" +
                      "0123456789";

    var chainnameScale = this.getScale( { domain: [ 0, 26 ] } );

    this.atomColor = function( a ){

        if( a.residue.chain.chainname === "" ){
            return chainnameScale(
                chainNames.indexOf( a.chainname ) * 10
            );
        }else{
            return chainindexScale( a.residue.chain.index );
        }

    };

};

NGL.ChainindexColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.ChainindexColorMaker.prototype.constructor = NGL.ChainindexColorMaker;


NGL.ModelindexColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    if( !params.scale ){
        this.scale = "roygb";
    }

    if( !params.domain ){
        this.domain = [ 0, this.structure.modelCount ];
    }

    var modelindexScale = this.getScale();

    this.atomColor = function( a ){

        return modelindexScale( a.residue.chain.model.index );

    };

};

NGL.ModelindexColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.ModelindexColorMaker.prototype.constructor = NGL.ModelindexColorMaker;


NGL.SstrucColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    var strucColors = NGL.StructureColors;
    var defaultStrucColor = NGL.StructureColors[""];

    this.atomColor = function( a ){

        if( a.ss === "h" ){
            return strucColors[ "alphaHelix" ];
        }else if( a.ss === "g" ){
            return strucColors[ "3_10Helix" ];
        }else if( a.ss === "i" ){
            return strucColors[ "piHelix" ];
        }else if( a.ss === "s" ){
            return strucColors[ "betaStrand" ];
        }else if( a.residue.isNucleic() ){
            return strucColors[ "dna" ];
        }else if( a.residue.isProtein() || a.ss === "c" ){
            return strucColors[ "coil" ];
        }else{
            return defaultStrucColor;
        }

    };

};

NGL.SstrucColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.SstrucColorMaker.prototype.constructor = NGL.SstrucColorMaker;


NGL.ElementColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    var elemColors = NGL.ElementColors;
    var defaultElemColor = NGL.ElementColors[""];
    var colorValue = this.value;
    if( params.value === undefined ){
        colorValue = NGL.ElementColors[ "C" ];
    }

    this.atomColor = function( a ){

        var element = a.element;

        if( element === "C" ){
            return colorValue;
        }else{
            return elemColors[ element ] || defaultElemColor;
        }

    };

};

NGL.ElementColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.ElementColorMaker.prototype.constructor = NGL.ElementColorMaker;


NGL.ResnameColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    var resColors = NGL.ResidueColors;
    var defaultResColor = NGL.ResidueColors[""];

    this.atomColor = function( a ){

        return resColors[ a.resname ] || defaultResColor;

    };

};

NGL.ResnameColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.ResnameColorMaker.prototype.constructor = NGL.ResnameColorMaker;


NGL.BfactorColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    if( !params.scale ){
        this.scale = "OrRd";
    }

    if( !params.domain ){

        var bfactor;
        var min = Infinity;
        var max = -Infinity;

        if( params.sele ){

            var selection = new NGL.Selection( params.sele );

            this.structure.eachAtom( function( a ){

                bfactor = a.bfactor;
                min = Math.min( min, bfactor );
                max = Math.max( max, bfactor );

            }, selection );

        }else{

            var atoms = this.structure.atoms;
            var n = atoms.length;

            for( var i = 0; i < n; ++i ){

                bfactor = atoms[ i ].bfactor;
                min = Math.min( min, bfactor );
                max = Math.max( max, bfactor );

            }

        }

        this.domain = [ min, max ];

    }

    var bfactorScale = this.getScale();

    this.atomColor = function( a ){

        return bfactorScale( a.bfactor );

    };

};

NGL.BfactorColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.BfactorColorMaker.prototype.constructor = NGL.BfactorColorMaker;


NGL.HydrophobicityColorMaker = function( params ){

    NGL.ColorMaker.call( this, params );

    if( !params.scale ){
        this.scale = "RdYlGn";
    }

    var idx = 0;  // 0: DGwif, 1: DGwoct, 2: Oct-IF

    var resHF = {};
    for( var name in NGL.ResidueHydrophobicity ){
        resHF[ name ] = NGL.ResidueHydrophobicity[ name ][ idx ];
    }
    var defaultResHF = resHF[""];

    if( !params.domain ){

        var val;
        var min = Infinity;
        var max = -Infinity;

        for( var name in resHF ){

            val = resHF[ name ];
            min = Math.min( min, val );
            max = Math.max( max, val );

        }

        this.domain = [ min, 0, max ];

    }

    var hfScale = this.getScale();

    this.atomColor = function( a ){

        return hfScale( resHF[ a.resname ] || defaultResHF );

    };

};

NGL.HydrophobicityColorMaker.prototype = NGL.ColorMaker.prototype;

NGL.HydrophobicityColorMaker.prototype.constructor = NGL.HydrophobicityColorMaker;


NGL.ColorMakerRegistry.types = {

    "": NGL.ColorMaker,
    "picking": NGL.PickingColorMaker,
    "random": NGL.RandomColorMaker,
    "uniform": NGL.UniformColorMaker,
    "atomindex": NGL.AtomindexColorMaker,
    "residueindex": NGL.ResidueindexColorMaker,
    "chainindex": NGL.ChainindexColorMaker,
    "modelindex": NGL.ModelindexColorMaker,
    "sstruc": NGL.SstrucColorMaker,
    "element": NGL.ElementColorMaker,
    "resname": NGL.ResnameColorMaker,
    "bfactor": NGL.BfactorColorMaker,
    "hydrophobicity": NGL.HydrophobicityColorMaker,
    "value": NGL.ValueColorMaker,

};


////////////
// Factory

NGL.RadiusFactory = function( type, scale ){

    this.type = type;
    this.scale = scale || 1.0;

    this.max = 10;

};

NGL.RadiusFactory.types = {

    "": "",
    "vdw": "by vdW radius",
    "covalent": "by covalent radius",
    "sstruc": "by secondary structure",
    "bfactor": "by bfactor",
    "size": "size"

};

NGL.RadiusFactory.prototype = {

    constructor: NGL.RadiusFactory,

    atomRadius: function( a ){

        var type = this.type;
        var scale = this.scale;
        var vdwRadii = NGL.VdwRadii;
        var covalentRadii = NGL.CovalentRadii;

        var defaultVdwRadius = NGL.VdwRadii[""];
        var defaultCovalentRadius = NGL.CovalentRadii[""];
        var defaultBfactor = 1;

        var nucleic = [ "C3'", "C3*", "C4'", "C4*", "P" ];

        var r;

        switch( type ){

            case "vdw":

                r = vdwRadii[ a.element ] || defaultVdwRadius;
                break;

            case "covalent":

                r = covalentRadii[ a.element ] || defaultCovalentRadius;
                break;

            case "bfactor":

                r = a.bfactor || defaultBfactor;
                break;

            case "sstruc":

                if( a.ss === "h" ){
                    r = 0.25;
                }else if( a.ss === "g" ){
                    r = 0.25;
                }else if( a.ss === "i" ){
                    r = 0.25;
                }else if( a.ss === "s" ){
                    r = 0.25;
                // }else if( a.atomname === "P" ){
                }else if( nucleic.indexOf( a.atomname ) !== -1 ){
                    r = 0.4;
                }else{
                    r = 0.1;
                }
                break;

            default:

                r = type || 1.0;
                break;

        }

        return Math.min( r * scale, this.max );

    }

};


NGL.LabelFactory = function( type, text ){

    this.type = type;
    this.text = text || {};

};

NGL.LabelFactory.types = {

    "": "",
    "atomname": "atom name",
    "atomindex": "atom index",
    "atom": "atom name + index",
    "resname": "residue name",
    "resno": "residue no",
    "res": "residue name + no",
    "text": "text"

};

NGL.LabelFactory.prototype = {

    constructor: NGL.LabelFactory,

    atomLabel: function( a ){

        var type = this.type;

        var l;

        switch( type ){

            case "atomname":

                l = a.atomname;
                break;

            case "atomindex":

                l = "" + a.index;
                break;

            case "atom":

                l = a.atomname + "|" + a.index;
                break;

            case "resname":

                l = a.resname;
                break;

            case "resno":

                l = "" + a.resno;
                break;

            case "res":

                l = ( NGL.AA1[ a.resname.toUpperCase() ] || '' ) + a.resno;
                break;

            case "text":

                // TODO
                l = this.text[ a.globalindex ];
                break;

            default:

                l = a.qualifiedName();
                break;

        }

        return l === undefined ? '' : l;

    }

};


////////
// Set

NGL.AtomSet = function( structure, selection ){

    this.atoms = [];
    this.bonds = [];

    this.atomCount = 0;

    if( structure ){

        this.fromStructure( structure, selection );

    }

};

NGL.AtomSet.prototype = {

    constructor: NGL.AtomSet,

    apply: function( object ){

        object.getAtoms = NGL.AtomSet.prototype.getAtoms;

        object.getBoundingBox = NGL.AtomSet.prototype.getBoundingBox;

        object.atomPosition = NGL.AtomSet.prototype.atomPosition;
        object.atomColor = NGL.AtomSet.prototype.atomColor;
        object.atomRadius = NGL.AtomSet.prototype.atomRadius;
        object.atomCenter = NGL.AtomSet.prototype.atomCenter;
        object.atomIndex = NGL.AtomSet.prototype.atomIndex;

    },

    getAtoms: function( selection, first ){

        var atoms;

        if( selection ){

            atoms = [];

            this.eachAtom( function( a ){

                atoms.push( a );

            }, selection );

        }else{

            atoms = this.atoms;

        }

        if( first ){

            // TODO early exit after first atom is found
            return atoms[ 0 ];

        }else{

            return atoms;

        }

    },

    addAtom: function( atom ){

        this.atoms.push( atom );

        this.atomCount = this.atoms.length;

    },

    fromStructure: function( structure, selection ){

        var scope = this;

        this.structure = structure;

        this.selection = selection;

        this.selection.signals.stringChanged.add( function( string ){

            scope.applySelection();

        } );

        this.applySelection();

    },

    applySelection: function(){

        // atoms

        NGL.time( "NGL.AtomSet.applySelection#atoms" );

        this.atoms.length = 0;
        var atoms = this.atoms;

        this.structure.eachAtom( function( a ){

            atoms.push( a );

        }, this.selection );

        this.atomCount = this.atoms.length;
        this.center = this.atomCenter();

        this._atomPosition = undefined;

        NGL.timeEnd( "NGL.AtomSet.applySelection#atoms" );

        // bonds

        NGL.time( "NGL.AtomSet.applySelection#bonds" );

        this.bonds.length = 0;
        var bonds = this.bonds;

        if( this.selection ){

            var idxDict = {};

            this.eachAtom( function( a ){

                var ab = a.bonds;
                var n = ab.length;

                idxDict[ a.index ] = true;

                for( var i = 0; i < n; ++i ){

                    var b = ab[ i ];

                    if( idxDict[ b.atom1.index ] && idxDict[ b.atom2.index ] ){

                        bonds.push( b );

                    }

                }

            } );

        }else{

            this.eachAtom( function( a ){

                var ab = a.bonds;
                var n = ab.length;

                for( var i = 0; i < n; ++i ){

                    bonds.push( ab[ i ] );

                }

            } );

        }

        this.bondCount = this.bonds.length;

        this._bondPositionFrom = undefined;
        this._bondPositionTo = undefined;

        NGL.timeEnd( "NGL.AtomSet.applySelection#bonds" );

    },

    getBoundingBox: function( selection ){

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        var a;
        var i = 0;
        var n = this.atoms.length;

        if( selection ){

            var test = selection.test;

            for( i = 0; i < n; ++i ){

                a = this.atoms[ i ];

                if( test( a ) ){

                    vector.copy( a );
                    box.expandByPoint( vector );

                }

            };

        }else{

            for( i = 0; i < n; ++i ){

                vector.copy( this.atoms[ i ] );
                box.expandByPoint( vector );

            };

        }

        return box;

    },

    eachAtom: function( callback, selection ){

        if( selection ){

            var test = selection.test;

            this.atoms.forEach( function( a ){

                if( test( a ) ) callback( a );

            } );

        }else{

            this.atoms.forEach( callback );

        }

    },

    atomPosition: function( selection ){

        var j, position, a;

        var i = 0;
        var n = this.atomCount;

        if( selection ){

            position = [];

            this.eachAtom( function( a ){

                position[ i + 0 ] = a.x;
                position[ i + 1 ] = a.y;
                position[ i + 2 ] = a.z;

                i += 3;

            }, selection );

            position = new Float32Array( position );

        }else{

            if( this._atomPosition ){

                position = this._atomPosition;

            }else{

                position = new Float32Array( this.atomCount * 3 );

            }

            for( j = 0; j < n; ++j ){

                a = this.atoms[ j ];

                position[ i + 0 ] = a.x;
                position[ i + 1 ] = a.y;
                position[ i + 2 ] = a.z;

                i += 3;

            };

            this._atomPosition = position;

        }

        return position;

    },

    getColorMaker: function( params ){

        var p = params || {};
        p.structure = this.structure;
        p.bondSet = this.structure.bondSet;

        return NGL.ColorMakerRegistry.getScheme( p );

    },

    atomColor: function( selection, params ){

        // NGL.time( "atomColor" );

        // TODO cache
        var c, color;
        var colorMaker = this.getColorMaker( params );

        if( selection ){
            color = [];
        }else{
            color = new Float32Array( this.atomCount * 3 );
        }

        var i = 0;

        this.eachAtom( function( a ){

            colorMaker.atomColorToArray( a, color, i );
            i += 3;

        }, selection );

        if( selection ) color = new Float32Array( color );

        // NGL.timeEnd( "atomColor" );

        return color;

    },

    atomPickingColor: function( selection, params ){

        var p = Object.assign( params || {} );
        p.scheme = "picking";

        return this.atomColor( selection, p );

    },

    atomRadius: function( selection, type, scale ){

        // TODO cache
        var i, radius;
        var radiusFactory = new NGL.RadiusFactory( type, scale );

        if( selection ){
            radius = [];
        }else{
            radius = new Float32Array( this.atomCount );
        }

        i = 0;

        this.eachAtom( function( a ){

            radius[ i ] = radiusFactory.atomRadius( a );

            i += 1;

        }, selection );

        if( selection ) radius = new Float32Array( radius );

        return radius;

    },

    atomIndex: function( selection ){

        var index = [];

        this.eachAtom( function( a ){

            index.push( a.index );

        }, selection );

        return index;

    },

    atomCenter: function(){

        var box = new THREE.Box3();
        var vector = new THREE.Vector3();

        return function( selection ){

            // NGL.time( "NGL.AtomSet.atomCenter" );

            var a;
            var i = 0;
            var n = this.atoms.length;

            box.makeEmpty();

            if( selection ){

                var test = selection.test;

                for( i = 0; i < n; ++i ){

                    a = this.atoms[ i ];

                    if( test( a ) ){

                        vector.copy( a );
                        box.expandByPoint( vector );

                    }

                };

            }else{

                for( i = 0; i < n; ++i ){

                    vector.copy( this.atoms[ i ] );
                    box.expandByPoint( vector );

                };

            }

            // NGL.timeEnd( "NGL.AtomSet.atomCenter" );

            return box.center();

        };

    }(),

    eachBond: function( callback, selection ){

        selection = selection || this.selection;

        if( selection && selection.test ){

            var test = selection.test;

            this.bonds.forEach( function( b ){

                if( test( b.atom1 ) && test( b.atom2 ) ){

                    callback( b );

                }

            } );

        }else{

            var bonds = this.bonds;
            var n = bonds.length;

            for( var i = 0; i < n; ++i ){

                callback( bonds[ i ] );

            }

        }

    },

    /*eachBondBAK: function( callback, selection ){

        selection = selection || this.selection;

        if( selection ){

            var test = selection.test;

            this.atoms.forEach( function( a ){

                if( test( a ) ){

                    a.bonds.forEach( function( b ){

                        // if( b.atom1 === a && test( b.atom2 ) ){

                        //     callback( b );

                        // }else if( b.atom2 === a && test( b.atom2 ) ){

                        //     callback( b );

                        // }

                        if( test( b.atom1 ) && test( b.atom2 ) ){

                            callback( b );

                        }

                    } );

                }

            } );

        }else{

            this.atoms.forEach( function( a ){

                a.bonds.forEach( function( b ){

                    callback( b );

                } );

            } );

        }

    },*/

    bondPosition: function( selection, fromTo ){

        // NGL.time( "NGL.AtomSet.bondPosition" );

        var j, position, b;

        var i = 0;
        var n = this.bondCount;

        if( selection ){

            position = [];

            this.eachBond( function( b ){

                if( fromTo ){

                    position[ i + 0 ] = b.atom1.x;
                    position[ i + 1 ] = b.atom1.y;
                    position[ i + 2 ] = b.atom1.z;

                }else{

                    position[ i + 0 ] = b.atom2.x;
                    position[ i + 1 ] = b.atom2.y;
                    position[ i + 2 ] = b.atom2.z;

                }

                i += 3;

            }, selection );

            position = new Float32Array( position );

        }else{

            position = [];

            if( fromTo ){

                if( this._bondPositionFrom ){
                    position = this._bondPositionFrom;
                }

            }else{

                if( this._bondPositionTo ){
                    position = this._bondPositionTo;
                }

            }

            for( j = 0; j < n; ++j ){

                b = this.bonds[ j ];

                if( fromTo ){

                    position[ i + 0 ] = b.atom1.x;
                    position[ i + 1 ] = b.atom1.y;
                    position[ i + 2 ] = b.atom1.z;

                }else{

                    position[ i + 0 ] = b.atom2.x;
                    position[ i + 1 ] = b.atom2.y;
                    position[ i + 2 ] = b.atom2.z;

                }

                i += 3;

            };

            if( fromTo ){

                if( !this._bondPositionFrom ){
                    this._bondPositionFrom = new Float32Array( position );
                }

            }else{

                if( !this._bondPositionTo ){
                    this._bondPositionTo = new Float32Array( position );
                }

            }

        }

        // NGL.timeEnd( "NGL.AtomSet.bondPosition" );

        return position;

    },

    bondColor: function( selection, fromTo, params ){

        // NGL.time( "NGL.AtomSet.bondColor" );

        var i = 0;
        var color = [];

        var c;
        var colorMaker = this.getColorMaker( params );

        if( selection ){

            this.eachBond( function( b ){

                colorMaker.bondColorToArray( b, fromTo, color, i );
                i += 3;

            }, selection );

        }else{

            var bonds = this.bonds;
            var n = bonds.length;

            for( var j = 0; j < n; ++j ){

                colorMaker.bondColorToArray( bonds[ j ], fromTo, color, i );
                i += 3;

            }

        }

        // NGL.timeEnd( "NGL.AtomSet.bondColor" );

        return new Float32Array( color );

    },

    bondPickingColor: function( selection, fromTo, params ){

        var p = Object.assign( {}, params );
        p.scheme = "picking";

        return this.bondColor( selection, fromTo, p );

    },

    bondRadius: function( selection, fromTo, type, scale ){

        // NGL.time( "NGL.AtomSet.bondRadius" );

        var i = 0;
        var radius = [];
        var radiusFactory = new NGL.RadiusFactory( type, scale );

        if( selection ){

            this.eachBond( function( b ){

                radius[ i ] = radiusFactory.atomRadius(
                    fromTo ? b.atom1 : b.atom2
                );

                i += 1;

            }, selection );

        }else{

            var bonds = this.bonds;
            var n = bonds.length;

            for( i = 0; i < n; ++i ){

                var b = bonds[ i ];

                radius[ i ] = radiusFactory.atomRadius(
                    fromTo ? b.atom1 : b.atom2
                );

            }

        }

        // NGL.timeEnd( "NGL.AtomSet.bondRadius" );

        return new Float32Array( radius );

    },

    toJSON: function(){

        var output = {

            metadata: {
                version: 0.1,
                type: 'AtomSet',
                generator: 'AtomSetExporter'
            },

            atomCount: this.atomCount

        };

        var atoms = this.atoms;
        var n = atoms.length;
        var atomArray = new NGL.AtomArray( n );
        var pa = new NGL.ProxyAtom( atomArray );

        for( var i = 0; i < n; ++i ){

            pa.copy( atoms[ i ], i );

        }

        output.atomArray = atomArray.toJSON();

        return output;

    },

    fromJSON: function( input ){

        this.atomCount = input.atomCount;

        var atoms = this.atoms;
        var atomArray = new NGL.AtomArray( input.atomArray );
        var n = atomArray.length;

        for( var i = 0; i < n; ++i ){

            atoms.push(
                new NGL.ProxyAtom( atomArray, i )
            );

        }

        return this;

    },

    dispose: function(){

        this.atoms.length = 0;
        this.bonds.length = 0;

        delete this.structure;

    }

};


NGL.BondSet = function(){

    this.bonds = [];
    this.bondCount = 0;

    NGL.GidPool.addObject( this );

};

NGL.BondSet.prototype = {

    constructor: NGL.BondSet,

    addBond: function( atom1, atom2, notToAtoms, bondOrder ){

        var b = new NGL.Bond( atom1, atom2, bondOrder );
        b.index = this.bondCount;

        if( !notToAtoms ){
            atom1.bonds.push( b );
            atom2.bonds.push( b );
        }
        this.bonds.push( b );

        this.bondCount += 1;

        NGL.GidPool.updateObject( this );

    },

    addBondIfConnected: function( atom1, atom2, notToAtoms, bondOrder ){

        if( atom1.connectedTo( atom2 ) ){

            this.addBond( atom1, atom2, notToAtoms, bondOrder );

            return true;

        }

        return false;

    },

    eachBond: function( callback, selection ){

        var bonds = this.bonds;
        var n = bonds.length;

        if( selection && selection.test ){

            var test = selection.test;

            for( var i = 0; i < n; ++i ){

                var b = bonds[ i ];

                if( test( b.atom1 ) && test( b.atom2 ) ){

                    callback( b );

                }

            }

            // this.bonds.forEach( function( b ){

            //     if( test( b.atom1 ) && test( b.atom2 ) ){

            //         callback( b );

            //     }

            // } );

        }else{

            for( var i = 0; i < n; ++i ){

                callback( bonds[ i ] );

            }

        }

    },

    getColorMaker: function( params ){

        var p = params || {};
        p.structure = this.structure;
        p.bondSet = this;

        return NGL.ColorMakerRegistry.getScheme( p );

    },

    bondPosition: NGL.AtomSet.prototype.bondPosition,

    bondColor: NGL.AtomSet.prototype.bondColor,

    bondPickingColor: NGL.AtomSet.prototype.bondPickingColor,

    bondRadius: NGL.AtomSet.prototype.bondRadius,

    toJSON: function(){

        var output = {

            metadata: {
                version: 0.1,
                type: 'BondSet',
                generator: 'BondSetExporter'
            },

            bondCount: this.bondCount

        };

        var bonds = this.bonds;
        var n = bonds.length;
        var bondArray = new Uint32Array( 3 * n );
        var j, b;

        for( var i = 0; i < n; ++i ){

            j = i * 3;
            b = bonds[ i ];

            bondArray[ j     ] = b.atom1.index;
            bondArray[ j + 1 ] = b.atom2.index;
            bondArray[ j + 2 ] = b.bondOrder;

        }

        output.bondArray = bondArray;

        return output;

    },

    fromJSON: function( input, atoms ){

        this.bondCount = input.bondCount;

        var bonds = this.bonds;
        var bondArray = input.bondArray;
        var n = bondArray.length;

        for( var i = 0; i < n; i += 3 ){

            var b = new NGL.Bond(
                atoms[ bondArray[ i ] ],
                atoms[ bondArray[ i + 1 ] ],
                bondArray[ i + 2 ]
            );

            b.index = i / 3;

            bonds.push( b );

        }

        NGL.GidPool.updateObject( this );

        return this;

    },

    clear: function(){

        this.bonds.length = 0;
        this.bondCount = 0;

        if( !this.__disposed ){
            NGL.GidPool.updateObject( this );
        }

    },

    dispose: function(){

        this.__disposed = true;

        this.clear();

        NGL.GidPool.removeObject( this );

    }

};


/////////
// Bond

NGL.Bond = function( atomA, atomB, bondOrder ){

    if( atomA.index < atomB.index ){
        this.atom1 = atomA;
        this.atom2 = atomB;
    }else{
        this.atom1 = atomB;
        this.atom2 = atomA;
    }

    this.bondOrder = bondOrder || 1;

};

NGL.Bond.prototype = {

    constructor: NGL.Bond,

    atom1: undefined,
    atom2: undefined,
    bondOrder: undefined,

    index: undefined,

    qualifiedName: function(){

        return this.atom1.index + "=" + this.atom2.index;

    },

    toJSON: function(){

        return {

            atom1: this.atom1.toJSON(),
            atom2: this.atom2.toJSON(),
            bondOrder: this.bondOrder,

            index: this.index

        }

    }

};


//////////////
// Structure

NGL.Structure = function( name, path ){

    this.name = name;
    this.path = path;
    this.title = "";
    this.id = "";

    this.atoms = [];
    this.models = [];

    this.biomolDict = {};
    this.defaultAssembly = "BU1";
    this.helices = [];
    this.sheets = [];

    this.frames = [];
    this.boxes = [];

    this.reset();

    NGL.GidPool.addObject( this );

};

NGL.Structure.prototype = {

    constructor: NGL.Structure,

    atomArray: undefined,

    reset: function(){

        this.atomCount = 0;
        this.residueCount = 0;
        this.chainCount = 0;
        this.modelCount = 0;

        this.atoms.length = 0;
        this.models.length = 0;

        if( this.bondSet ){
            this.bondSet.clear();
        }else{
             this.bondSet = new NGL.BondSet();
        }

        this.biomolDict = {};
        this.helices.length = 0;
        this.sheets.length = 0;
        this.unitcell = new NGL.Unitcell();

        this.frames.length = 0;
        this.boxes.length = 0;

        this.center = new THREE.Vector3();
        this.boundingBox = new THREE.Box3();

        NGL.GidPool.updateObject( this, true );

    },

    setDefaultAssembly: function( value ){

        this.defaultAssembly = value;

    },

    postProcess: function( callback ){

        var self = this;

        async.series( [

            function( wcallback ){

                if( !self._dontAutoBond ){
                    self.autoBond();
                }
                wcallback();

            },

            function( wcallback ){

                if( self._doAutoSS ){
                    self.autoSS();
                }
                wcallback();

            },

            function( wcallback ){

                if( self._doAutoChainName ){
                    self.autoChainName();
                }
                wcallback();

            },

            function( wcallback ){

                self.center = self.atomCenter();
                self.boundingBox = self.getBoundingBox();
                wcallback();

            }

        ], function(){

            NGL.GidPool.updateObject( self );

            callback();

        } );

    },

    nextAtomIndex: function(){

        return this.atomCount++;

    },

    nextResidueIndex: function(){

        return this.residueCount++;

    },

    nextChainIndex: function(){

        return this.chainCount++;

    },

    nextModelIndex: function(){

        return this.modelCount++;

    },

    addModel: function( m ){

        if( !m ){
            m = new NGL.Model( this );
        }else{
            m.structure = this;
        }
        m.index = this.nextModelIndex();
        this.models.push( m );
        return m;

    },

    eachAtom: function( callback, selection ){

        if( selection && selection.modelOnlyTest ){

            // NGL.log( "structure.eachAtom#model", selection.selection )

            var test = selection.modelOnlyTest;

            this.models.forEach( function( m ){

                if( test( m ) ) m.eachAtom( callback, selection );

            } );

        }else if( selection ){

            this.models.forEach( function( m ){

                m.eachAtom( callback, selection );

            } );

        }else{

            var atoms = this.atoms;
            var n = this.atomCount;

            for( var i = 0; i < n; ++i ){

                callback( atoms[ i ] );

            }

        }

    },

    eachResidue: function( callback, selection ){

        if( selection && selection.modelOnlyTest ){

            var test = selection.modelOnlyTest;

            this.models.forEach( function( m ){

                if( test( m ) ) m.eachResidue( callback, selection );

            } );

        }else{

            this.models.forEach( function( m ){

                m.eachResidue( callback, selection );

            } );

        }

    },

    eachResidueN: function( n, callback ){

        this.models.forEach( function( m ){
            m.eachResidueN( n, callback );
        } );

    },

    eachFiber: function( callback, selection, padded ){

        if( selection && selection.modelOnlyTest ){

            var test = selection.modelOnlyTest;

            this.models.forEach( function( m ){

                if( test( m ) ) m.eachFiber( callback, selection, padded );

            } );

        }else{

            this.models.forEach( function( m ){

                m.eachFiber( callback, selection, padded );

            } );

        }

    },

    eachChain: function( callback, selection ){

        if( selection && selection.modelOnlyTest ){

            var test = selection.modelOnlyTest;

            this.models.forEach( function( m ){

                if( test( m ) ) m.eachChain( callback, selection );

            } );

        }else{

            this.models.forEach( function( m ){

                m.eachChain( callback, selection );

            } );

        }

    },

    eachModel: function( callback, selection ){

        if( selection && selection.modelOnlyTest ){

            var test = selection.modelOnlyTest;

            this.models.forEach( function( m ){

                if( test( m ) ) callback( m );

            } );

        }else{

            this.models.forEach( callback );

        }

    },

    getSequence: function(){

        var seq = [];

        // FIXME nucleic support

        this.eachResidue( function( r ){

            if( r.getAtomByName( "CA" ) ){
                seq.push( r.getResname1() );
            }

        } );

        return seq;

    },

    autoBond: function(){

        NGL.time( "NGL.Structure.autoBond" );

        var bondSet = this.bondSet;

        var i, j, n, n1, m, ra, a1, a2;
        var kdtree, nearestAtoms, radius, maxd;
        var resname, atomnameList, bonding, equalAtomnames;

        var bondingDict = {};

        NGL.time( "NGL.Structure.autoBond within" );

        this.eachResidue( function( r ){

            ra = r.atoms;
            n = r.atomCount;
            n1 = n - 1;

            if( n > 500 ){
                NGL.warn( "more than 500 atoms, skip residue for auto-bonding" );
                return;
            }

            resname = r.resname;
            equalAtomnames = false;

            if( bondingDict[ resname ] ){

                atomnameList = bondingDict[ resname ].atomnameList;

                if( n === atomnameList.length ){

                    equalAtomnames = true;

                    for( i = 0; i < n; ++i ){

                        if( ra[ i ].atomname !== atomnameList[ i ] ){

                            equalAtomnames = false;
                            break;

                        }

                    }

                }

            }

            if( equalAtomnames ){

                var atomIndices1 = bondingDict[ resname ].atomIndices1;
                var atomIndices2 = bondingDict[ resname ].atomIndices2;
                var nn = atomIndices1.length;

                for( i = 0; i < nn; ++i ){

                    bondSet.addBond(
                        ra[ atomIndices1[ i ] ], ra[ atomIndices2[ i ] ]
                    );

                }

            }else{

                var atomIndices1 = [];
                var atomIndices2 = [];

                if( n > 20 ){

                    kdtree = new NGL.Kdtree( ra, true );
                    radius = r.hasBackbone() ? 1.2 : 2.3;

                    for( i = 0; i <= n1; ++i ){

                        a1 = ra[ i ];

                        maxd = a1.covalent + radius + 0.3;
                        nearestAtoms = kdtree.nearest(
                            a1, Infinity, maxd * maxd
                        );
                        m = nearestAtoms.length;

                        for( j = 0; j < m; ++j ){

                            a2 = nearestAtoms[ j ].atom;

                            if( a1.index < a2.index ){

                                if( bondSet.addBondIfConnected( a1, a2 ) ){

                                    atomIndices1.push( i );
                                    atomIndices2.push( ra.indexOf( a2 ) );

                                };

                            }

                        }

                    }

                }else{

                    for( i = 0; i < n1; ++i ){

                        a1 = ra[ i ];

                        for( j = i + 1; j <= n1; ++j ){

                            a2 = ra[ j ];

                            if( bondSet.addBondIfConnected( a1, a2 ) ){

                                atomIndices1.push( i );
                                atomIndices2.push( j );

                            };

                        }

                    }

                }

                bondingDict[ resname ] = {

                    atomnameList: r.getAtomnameList(),
                    atomIndices1: atomIndices1,
                    atomIndices2: atomIndices2

                };

            }

        } );

        NGL.timeEnd( "NGL.Structure.autoBond within" );

        // bonds between residues

        NGL.time( "NGL.Structure.autoBond between" );

        this.eachResidueN( 2, function( r1, r2 ){

            var bbType1 = r1.getBackboneType();
            var bbType2 = r2.getBackboneType();

            if( bbType1 !== NGL.UnknownType && bbType1 === bbType2 ){

                bondSet.addBondIfConnected(
                    r1.getBackboneAtomStart(),
                    r2.getBackboneAtomEnd()
                );

            }

        } );

        NGL.timeEnd( "NGL.Structure.autoBond between" );

        NGL.timeEnd( "NGL.Structure.autoBond" );

    },

    autoSS: function(){

        // Implementation for proteins based on "pv"
        //
        // assigns secondary structure information based on a simple and very fast
        // algorithm published by Zhang and Skolnick in their TM-align paper.
        // Reference:
        //
        // TM-align: a protein structure alignment algorithm based on the Tm-score
        // (2005) NAR, 33(7) 2302-2309

        var zhangSkolnickSS = function(){

            var d;

            var ca1 = new THREE.Vector3();
            var ca2 = new THREE.Vector3();

            return function( fiber, i, distances, delta ){

                for( var j = Math.max( 0, i - 2 ); j <= i; ++j ){

                    for( var k = 2;  k < 5; ++k ){

                        if( j + k >= fiber.residueCount ){
                            continue;
                        }

                        ca1.copy( fiber.residues[ j ].getTraceAtom() );
                        ca2.copy( fiber.residues[ j + k ].getTraceAtom() );

                        d = ca1.distanceTo( ca2 );
                        // NGL.log( d )

                        if( Math.abs( d - distances[ k - 2 ] ) > delta ){
                            return false;
                        }

                    }

                }

                return true;

            };

        }();

        var isHelical = function( fiber, i ){

            var helixDistances = [ 5.45, 5.18, 6.37 ];
            var helixDelta = 2.1;

            return zhangSkolnickSS( fiber, i, helixDistances, helixDelta );

        };

        var isSheet = function( fiber, i ){

            var sheetDistances = [ 6.1, 10.4, 13.0 ];
            var sheetDelta = 1.42;

            return zhangSkolnickSS( fiber, i, sheetDistances, sheetDelta );

        };

        var proteinFiber = function( f ){

            var i;

            var n = f.residueCount;

            for( i = 0; i < n; ++i ){

                if( isHelical( f, i ) ){

                    f.residues[ i ].ss = "h";

                }else if( isSheet( f, i ) ){

                    f.residues[ i ].ss = "s";

                }else{

                    f.residues[ i ].ss = "c";

                }

            }

        }

        var cgFiber = function( f ){

            var localAngle = 20;
            var centerDist = 2.0;

            var helixbundle = new NGL.Helixbundle( f );

            var pos = helixbundle.position;
            var res = helixbundle.fiber.residues;

            var n = helixbundle.size;

            var c = new THREE.Vector3();
            var c2 = new THREE.Vector3();

            var i, d, r, r2;

            for( i = 0; i < n - 1; ++i ){

                r = res[ i ];
                r2 = res[ i + 1 ];

                c.fromArray( pos.center, i * 3 );
                c2.fromArray( pos.center, i * 3 + 3 );

                d = c.distanceTo( c2 );

                // NGL.log( r.ss, r2.ss, c.distanceTo( c2 ), pos.bending[ i ] )

                if( d < centerDist && d > 1.0 &&
                        pos.bending[ i ] < localAngle ){

                    r.ss = "h";
                    r2.ss = "h";

                }

            }

        }

        return function(){

            NGL.time( "NGL.Structure.autoSS" );

            // assign secondary structure

            this.eachFiber( function( f ){

                if( f.residueCount < 4 ) return;

                if( f.isProtein() ){

                    proteinFiber( f );

                }else if( f.isCg() ){

                    cgFiber( f );

                }

            } );

            // set lone secondary structure assignments to "c"

            this.eachFiber( function( f ){

                if( !f.isProtein() && !f.isCg ) return;

                var r;
                var ssType = undefined;
                var ssCount = 0;

                f.eachResidueN( 2, function( r1, r2 ){

                    if( r1.ss===r2.ss ){

                        ssCount += 1;

                    }else{

                        if( ssCount===1 ){

                            r1.ss = "c";

                        }

                        ssCount = 1;

                    }

                    r = r2;

                } );

                if( ssCount===1 ){

                    r.ss = "c";

                }

            } );

            NGL.timeEnd( "NGL.Structure.autoSS" );

        }

    }(),

    autoChainName: function(){

        var names = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
                    "abcdefghijklmnopqrstuvwxyz" +
                    "0123456789";
        var n = names.length;

        return function(){

            NGL.time( "NGL.Structure.autoChainName" );

            var i, name;

            this.eachModel( function( m ){

                i = 0;

                m.eachFiber( function( f ){

                    name = names[ i ];

                    f.eachAtom( function( a ){

                        a.chainname = name;

                    } );

                    i += 1;

                    if( i === n ){

                        NGL.warn( "out of chain names" );

                        i = 0;

                    }

                } )

            } );

            NGL.timeEnd( "NGL.Structure.autoChainName" );

        }

    }(),

    updatePosition: function( position ){

        // uses the atoms array directly as its
        // 1) faster, and
        // 2) ensures that atoms are traversed in order

        var i, i3, a;
        var atoms = this.atoms;
        var n = this.atomCount;

        for( i = 0; i < n; ++i ){

            a = atoms[ i ];
            i3 = i * 3;

            a.x = position[ i3     ];
            a.y = position[ i3 + 1 ];
            a.z = position[ i3 + 2 ];

        }

    },

    copy: function( s ){

        // no properties to copy

    },

    clone: function(){

        NGL.time( "NGL.Structure.clone" );

        var s = new NGL.Structure();

        s.name = this.name;
        s.path = this.path;

        s.title = this.title;
        s.id = this.id;

        if( this.biomolDict ) s.biomolDict = this.biomolDict;

        // s.center = this.center.clone();
        // s.boundingBox = this.boundingBox.clone();

        // clone atomArray

        if( this.atomArray ){

            s.atomArray = this.atomArray.clone();

        }

        // clone entities

        this.eachModel( function( m ){

            var sm = m.clone( s );
            s.addModel( sm );

            sm.eachAtom( function( a ){

                s.atoms.push( a );

            } );

        } );

        // clone trajectory

        // FIXME clone?
        s.frames = this.frames;
        s.boxes = this.boxes;

        // clone bonds

        this.bondSet.eachBond( function( b ){

            s.bondSet.addBond(

                s.atoms[ b.atom1.index ],
                s.atoms[ b.atom2.index ]

            );

        } );

        NGL.timeEnd( "NGL.Structure.clone" );

        if( NGL.debug ) NGL.log( s );

        return s;

    },

    toJSON: function(){

        NGL.time( "NGL.Structure.toJSON" );

        var output = {

            metadata: {
                version: 0.1,
                type: 'Structure',
                generator: 'StructureExporter'
            },

            name: this.name,
            path: this.path,
            title: this.title,
            id: this.id,

            biomolDict: this.biomolDict,
            helices: this.helices,
            sheets: this.sheets,
            unitcell: this.unitcell.toJSON(),

            frames: this.frames,
            boxes: this.boxes,

            center: this.center.toArray(),
            boundingBox: [
                this.boundingBox.min.toArray(),
                this.boundingBox.max.toArray()
            ],

            atoms: [],
            // models: [],

        };

        if( this.atomArray ){

            output.atomArray = this.atomArray.toJSON();

        }else{

            var atoms = this.atoms;
            var n = atoms.length;

            for( var i = 0; i < n; ++i ){

                output.atoms.push( atoms[ i ].toJSON() );

            };

        }

        // this.eachModel( function( m ){

        //     output.models.push( m.toJSON() );

        // } );

        output.bondSet = this.bondSet.toJSON();

        NGL.timeEnd( "NGL.Structure.toJSON" );

        return output;

    },

    fromJSON: function( input ){

        NGL.time( "NGL.Structure.fromJSON" );

        this.reset();

        this.name = input.name;
        this.path = input.path;
        this.title = input.title;
        this.id = input.id;

        this.biomolDict = input.biomolDict;
        this.helices = input.helices;
        this.sheets = input.sheets;
        this.unitcell = new NGL.Unitcell().fromJSON( input.unitcell );

        this.frames = input.frames;
        this.boxes = input.boxes;

        this.center = new THREE.Vector3().fromArray( input.center );
        this.boundingBox = new THREE.Box3(
            new THREE.Vector3().fromArray( input.boundingBox[ 0 ] ),
            new THREE.Vector3().fromArray( input.boundingBox[ 1 ] )
        );

        var atoms = this.atoms;

        if( input.atomArray ){

            this.atomArray = new NGL.AtomArray( input.atomArray );

            var atomArray = this.atomArray;
            var n = atomArray.usedLength;

            for( var i = 0; i < n; ++i ){

                atoms.push( new NGL.ProxyAtom( atomArray, i ) );

            }

        }else{

            var inputAtoms = input.atoms;
            var n = input.atoms.length;

            for( var i = 0; i < n; ++i ){

                var a = new NGL.Atom().fromJSON( inputAtoms[ i ] );
                a.index = i;
                atoms.push( a );

            }

        }

        // input.models.forEach( function( m ){

        //     this.addModel( new NGL.Model( this ).fromJSON( m ) );

        // }.bind( this ) );

        this.bondSet.fromJSON( input.bondSet, this.atoms );

        this.bondSet.eachBond( function( b ){

            atoms[ b.atom1.index ].bonds.push( b );
            atoms[ b.atom2.index ].bonds.push( b );

        } );

        NGL.GidPool.updateObject( this );

        NGL.timeEnd( "NGL.Structure.fromJSON" );

        return this;

    },

    getTransferable: function(){

        var transferable = [];

        if( this.atomArray ){

            transferable.concat( this.atomArray.getTransferable() );

        }

        if( this.frames ){

            var frames = this.frames;
            var n = this.frames.length;

            for( var i = 0; i < n; ++i ){

                transferable.push( frames[ i ].buffer );

            }

        }

        if( this.boxes ){

            var boxes = this.boxes;
            var n = this.boxes.length;

            for( var i = 0; i < n; ++i ){

                transferable.push( boxes[ i ].buffer );

            }

        }

        return transferable;

    },

    dispose: function(){

        this.atomCount = 0;
        this.residueCount = 0;
        this.chainCount = 0;
        this.modelCount = 0;

        this.atoms.length = 0;
        this.models.length = 0;

        if( this.cif ) delete this.cif;

        if( this.frames ) this.frames.length = 0;
        if( this.boxes ) this.boxes.length = 0;

        this.bondSet.dispose();

        if( this.atomArray ) this.atomArray.dispose();

        NGL.GidPool.removeObject( this );

    }

};

NGL.AtomSet.prototype.apply( NGL.Structure.prototype );


NGL.Model = function( structure ){

    this.structure = structure;
    this.chains = [];

    this.atomCount = 0;
    this.residueCount = 0;
    this.chainCount = 0;

};

NGL.Model.prototype = {

    constructor: NGL.Model,

    modelno: undefined,

    nextAtomIndex: function(){

        this.atomCount += 1;
        return this.structure.nextAtomIndex();

    },

    nextResidueIndex: function(){

        this.residueCount += 1;
        return this.structure.nextResidueIndex();

    },

    nextChainIndex: function(){

        this.chainCount += 1;
        return this.structure.nextChainIndex();

    },

    addChain: function( c ){

        if( !c ){
            c = new NGL.Chain( this );
        }else{
            c.model = this;
        }
        c.index = this.nextChainIndex();
        this.chains.push( c );
        return c;

    },

    eachAtom: function( callback, selection ){

        if( selection && selection.chainOnlyTest ){

            var test = selection.chainOnlyTest;

            this.chains.forEach( function( c ){

                // NGL.log( "model.eachAtom#chain", c.chainname, selection.selection )

                if( test( c ) ){
                    c.eachAtom( callback, selection );
                }/*else{
                    NGL.log( "chain", c.chainname );
                }*/

            } );

        }else{

            this.chains.forEach( function( c ){

                c.eachAtom( callback, selection );

            } );

        }

    },

    eachResidue: function( callback, selection ){

        var i, j, o, c, r;
        var n = this.chainCount;

        if( selection && selection.chainOnlyTest ){

            var test = selection.chainOnlyTest;

            for( i = 0; i < n; ++i ){

                c = this.chains[ i ];
                if( test( c ) ) c.eachResidue( callback, selection );

                // if( !test( c ) ) continue;

                // o = c.residueCount;

                // var residueTest = selection.residueTest;

                // for( j = 0; j < o; ++j ){

                //     r = c.residues[ j ];
                //     if( residueTest( r ) ) callback( r );

                // }

            }

        }else{

            for( i = 0; i < n; ++i ){

                c = this.chains[ i ];
                c.eachResidue( callback, selection );

                // o = c.residueCount;

                // for( j = 0; j < o; ++j ){

                //     callback( c.residues[ j ] );

                // }

            }

        }

    },

    eachResidueN: function( n, callback ){

        this.chains.forEach( function( c ){
            c.eachResidueN( n, callback );
        } );

    },

    eachFiber: function( callback, selection, padded ){

        if( selection && selection.chainOnlyTest ){

            var test = selection.chainOnlyTest;

            this.chains.forEach( function( c ){

                if( test( c ) ) c.eachFiber( callback, selection, padded );

            } );

        }else{

            this.chains.forEach( function( c ){

                c.eachFiber( callback, selection, padded );

            } );

        }

    },

    eachChain: function( callback, selection ){

        var i, c;
        var n = this.chainCount;

        if( selection && selection.chainOnlyTest ){

            var test = selection.chainOnlyTest;

            for( i = 0; i < n; ++i ){

                c = this.chains[ i ];
                if( test( c ) ) callback( c );

            }

        }else{

            for( i = 0; i < n; ++i ){

                callback( this.chains[ i ] );

            }

        }

    },

    copy: function( m ){

        // no properties to copy

    },

    clone: function( s ){

        var m = new NGL.Model( s );

        m.modelno = this.modelno;

        this.eachChain( function( c ){

            m.addChain( c.clone( m ) );

        } );

        return m;

    },

    toJSON: function(){

        var output = {

            modelno: this.modelno,

        };

        output.chains = [];

        this.eachChain( function( c ){

            output.chains.push( c.toJSON() );

        } );

        return output;

    },

    fromJSON: function( input ){

        this.modelno = input.modelno;

        input.chains.forEach( function( c ){

            this.addChain( new NGL.Chain( this ).fromJSON( c ) );

        }.bind( this ) );

        return this;

    }

};

NGL.AtomSet.prototype.apply( NGL.Model.prototype );


NGL.Chain = function( model ){

    this.model = model;
    this.residues = [];

    this.atomCount = 0;
    this.residueCount = 0;

};

NGL.Chain.prototype = {

    constructor: NGL.Chain,

    chainname: undefined,

    nextAtomIndex: function(){

        this.atomCount += 1;
        return this.model.nextAtomIndex();

    },

    nextResidueIndex: function(){

        this.residueCount += 1;
        return this.model.nextResidueIndex();

    },

    addResidue: function( r ){

        if( !r ){
            r = new NGL.Residue( this );
        }else{
            r.chain = this;
        }
        r.index = this.nextResidueIndex();
        this.residues.push( r );
        return r;

    },

    eachAtom: function( callback, selection ){

        var i, j, o, r, a;
        var n = this.residueCount;

        if( selection && selection.residueOnlyTest ){

            // NGL.log( "chain.eachAtom#residue", selection.selection )

            var test = selection.residueOnlyTest;

            for( i = 0; i < n; ++i ){

                r = this.residues[ i ];
                if( test( r ) ) r.eachAtom( callback, selection );

            }

            // for( i = 0; i < n; ++i ){

            //     r = this.residues[ i ];

            //     if( !test( r ) ) continue;

            //     o = r.atomCount;

            //     var atomTest = selection.atomOnlyTest;

            //     for( j = 0; j < o; ++j ){

            //         a = r.atoms[ j ];
            //         if( atomTest( a ) ) callback( a );

            //     }

            // }

        }else if( selection && (
                selection.atomOnlyTest ||
                ( this.chainname === "" && selection.test )
            )
        ){

            for( i = 0; i < n; ++i ){

                r = this.residues[ i ];
                r.eachAtom( callback, selection );

            }

        }else{

            // console.log( "moin" )

            for( i = 0; i < n; ++i ){

                r = this.residues[ i ];
                o = r.atomCount;

                for( j = 0; j < o; ++j ){

                    callback( r.atoms[ j ] );

                }

            }

        }

    },

    eachResidue: function( callback, selection ){

        var i, r;
        var n = this.residueCount;

        if( selection && selection.residueOnlyTest ){

            var test = selection.residueOnlyTest;

            for( i = 0; i < n; ++i ){

                r = this.residues[ i ];
                if( test( r ) ) callback( r );

            }

        }else{

            for( i = 0; i < n; ++i ){

                callback( this.residues[ i ] );

            }

        }

    },

    eachResidueN: function( n, callback ){

        if( this.residues.length < n ) return;

        var residues = this.residues;
        var array = new Array( n );
        var len = residues.length;
        var i;

        for( i = 0; i < n; i++ ){

            array[ i ] = residues[ i ];

        }

        callback.apply( this, array );

        for( i = n; i < len; i++ ){

            array.shift();
            array.push( residues[ i ] );

            callback.apply( this, array );

        }

    },

    getFiber: function( i, j, padded ){

        // NGL.log( i, j, this.residueCount );

        var n = this.residueCount;
        var n1 = n - 1;
        var residues = this.residues.slice( i, j );

        if( padded ){

            var rPrev = this.residues[ i - 1 ];
            var rStart = this.residues[ i ];
            var rEnd = this.residues[ j - 1 ];
            var rNext = this.residues[ j ];

            if( i === 0 ||
                rPrev.getBackboneType( -1 ) !== rStart.getBackboneType( 1 ) ||
                !rPrev.connectedTo( rStart )
            ){

                residues.unshift( rStart );

            }else{

                residues.unshift( rPrev );

            }

            if( j === n ||
                rNext.getBackboneType( 1 ) !== rStart.getBackboneType( -1 ) ||
                !rEnd.connectedTo( rNext )
            ){

                residues.push( rEnd );

            }else{

                residues.push( rNext );

            }

        }

        // NGL.log( i, j, padded, residues );

        return new NGL.Fiber( residues, this.model.structure );

    },

    eachFiber: function( callback, selection, padded ){

        var scope = this;

        var i = 0;
        var j = 1;
        var residues = this.residues;
        var test = selection ? selection.test : undefined;

        var a1, a2;
        var bbType1, bbType2

        this.eachResidueN( 2, function( r1, r2 ){

            bbType1 = r1.getBackboneType( i === j - 1 ? -1 : undefined );
            bbType2 = r2.getBackboneType();

            if( bbType1 !== NGL.UnknownType && bbType1 === bbType2 ){

                a1 = r1.getBackboneAtomStart();
                a2 = r2.getBackboneAtomEnd();

            }else{

                if( bbType1 !== NGL.UnknownType ){

                    callback( scope.getFiber( i, j, padded ) );

                }

                i = j;
                ++j;

                return;

            }

            if( !a1 || !a2 || !a1.connectedTo( a2 ) ||
                ( test && ( !test( a1 ) || !test( a2 ) ) ) ){

                callback( scope.getFiber( i, j, padded ) );
                i = j;

            }

            ++j;

        } );

        if( residues[ i ].hasBackbone( -1 ) ){

            callback( scope.getFiber( i, j, padded ) );

        }

    },

    copy: function( c ){

        this.chainname = c.chainname;

    },

    clone: function( m ){

        var c = new NGL.Chain( m );

        c.chainname = this.chainname;

        this.eachResidue( function( r ){

            c.addResidue( r.clone( c ) );

        } );

        return c;

    },

    toJSON: function(){

        var output = {

            chainname: this.chainname,

        };

        output.residues = [];

        this.eachResidue( function( r ){

            output.residues.push( r.toJSON() );

        } );

        return output;

    },

    fromJSON: function( input ){

        this.chainname = input.chainname;

        input.residues.forEach( function( r ){

            this.addResidue( new NGL.Residue( this ).fromJSON( r ) );

        }.bind( this ) );

        return this;

    }

};

NGL.AtomSet.prototype.apply( NGL.Chain.prototype );


NGL.Fiber = function( residues, structure ){

    this.structure = structure;

    this.residues = residues;
    this.residueCount = residues.length;

    if( !this.isProtein() &&
        !this.isNucleic() &&
        !this.isCg()
    ){

        NGL.error( "NGL.fiber: could not determine molecule type" );

    }

    this.computedAtoms = {};

};

NGL.Fiber.prototype = {

    constructor: NGL.Fiber,

    eachAtom: NGL.Chain.prototype.eachAtom,

    eachResidue: NGL.Chain.prototype.eachResidue,

    eachResidueN: NGL.Chain.prototype.eachResidueN,

    isProtein: function(){

        return this.residues[ 0 ].isProtein();

    },

    isCg: function(){

        return this.residues[ 0 ].isCg();

    },

    isNucleic: function(){

        return this.residues[ 0 ].isNucleic();

    },

    getType: function(){

        return this.residues[ 0 ].getType();

    },

    getBackboneType: function( position ){

        return this.residues[ 0 ].getBackboneType( position );

    },

    computeAtom: function( type ){

        var getAtomFn;

        switch( type ){

            case "trace":

                getAtomFn = function( r ){
                    return r.getTraceAtom();
                }
                break;

            case "direction1":

                getAtomFn = function( r ){
                    return r.getDirectionAtom1();
                }
                break;

            case "direction2":

                getAtomFn = function( r ){
                    return r.getDirectionAtom2();
                }
                break;

            default:

                getAtomFn = function( r ){
                    return r.getAtomByName( type );
                }
                return;

        }

        var n = this.residueCount;

        if( !this.computedAtoms[ type ] ){

            this.computedAtoms[ type ] = new Array( n );

        }

        var ca = this.computedAtoms[ type ];

        for( var i = 0, r; i < n; ++i ){

            ca[ i ] = getAtomFn( this.residues[ i ] );

        }

    },

    eachAtomN: function( n, callback, type ){

        if( this.residues.length < n ) return;

        if( !this.computedAtoms[ type ] ) this.computeAtom( type );

        var atoms = this.computedAtoms[ type ];
        var array = new Array( n );
        var len = atoms.length;
        var i;

        for( i = 0; i < n; i++ ){

            array[ i ] = atoms[ i ];

        }

        callback.apply( this, array );

        for( i = n; i < len; i++ ){

            array.shift();
            array.push( atoms[ i ] );

            callback.apply( this, array );

        }

    }

};


NGL.Residue = function( chain ){

    this.chain = chain;
    this.atoms = [];

    this.atomCount = 0;

};

NGL.Residue.atomnames = function(){;

    var atomnames = {};

    atomnames[ NGL.ProteinBackboneType ] = {
        trace: "CA",
        direction1: "C",
        direction2: [ "O", "OC1", "O1" ],
        backboneStart: "C",
        backboneEnd: "N",
    };

    atomnames[ NGL.RnaBackboneType ] = {
        trace: [ "C4'", "C4*" ],
        direction1: [ "C1'", "C1*" ],
        direction2: [ "C3'", "C3*" ],
        backboneStart: [ "O3'", "O3*" ],
        backboneEnd: "P",
    };

    atomnames[ NGL.DnaBackboneType ] = {
        trace: [ "C3'", "C3*" ],
        direction1: [ "C2'", "C2*" ],
        direction2: [ "O4'", "O4*" ],
        backboneStart: [ "O3'", "O3*" ],
        backboneEnd: "P",
    };

    atomnames[ NGL.CgType ] = {
        trace: [ "CA", "BB" ],
        direction1: null,
        direction2: null,
        backboneStart: [ "CA", "BB" ],
        backboneEnd: [ "CA", "BB" ],
    };

    // workaround for missing CA only type
    atomnames[ NGL.UnknownType ] = {
        trace: "CA",
        direction1: null,
        direction2: null,
        backboneStart: "CA",
        backboneEnd: "CA",
    };

    return atomnames;

}();

NGL.Residue.makeHasBackboneFn = function( typeFn, atomnames ){

    return function( position ){

        if( position === -1 ){

            return typeFn.call( this ) &&
                this.hasAtomWithName(
                    atomnames.backboneStart,
                    atomnames.direction1,
                    atomnames.direction2
                );

        }else if( position === 0 ){

            return typeFn.call( this ) &&
                this.hasAtomWithName(
                    atomnames.direction1,
                    atomnames.direction2
                );

        }else if( position === 1 ){

            return typeFn.call( this ) &&
                this.hasAtomWithName(
                    atomnames.backboneEnd,
                    atomnames.direction1,
                    atomnames.direction2
                );

        }else{

            return typeFn.call( this ) &&
                this.hasAtomWithName(
                    atomnames.backboneStart,
                    atomnames.backboneEnd,
                    atomnames.direction1,
                    atomnames.direction2
                );

        }

    }

};

NGL.Residue.prototype = {

    constructor: NGL.Residue,

    index: undefined,
    chain: undefined,
    atoms: undefined,
    atomCount: undefined,

    resno: undefined,
    resname: undefined,

    _ss: undefined,
    get ss () {
        return this._ss;
    },
    set ss ( value ) {

        this._ss = value;

        var i;
        var n = this.atomCount;
        var atoms = this.atoms;

        for( i = 0; i < n; ++i ){

            atoms[ i ].ss = value;

        }

    },

    isProtein: function(){

        return this.hasAtomWithName( "CA", "C", "N" );

    },

    isCg: function(){

        var AA3 = Object.keys( NGL.AA1 );

        return function(){

            return this._cg = !this.isProtein() &&
                this.hasAtomWithName([ "CA", "BB" ]) &&
                this.atomCount <= 5 &&
                AA3.indexOf( this.resname ) !== -1;

        }

    }(),

    isNucleic: function(){

        var bases = [
            "A", "C", "T", "G", "U",
            "DA", "DC", "DT", "DG", "DU"
        ];

        return function(){

            return bases.indexOf( this.resname ) !== -1;

        }

    }(),

    isRna: function(){

        var bases = [ "A", "C", "T", "G", "U" ];

        return function(){

            return bases.indexOf( this.resname ) !== -1;

        }

    }(),

    isDna: function(){

        var bases = [ "DA", "DC", "DT", "DG", "DU" ];

        return function(){

            return bases.indexOf( this.resname ) !== -1;

        }

    }(),

    isHetero: function(){

        return this.atoms.length && this.atoms[0].hetero === 1;

    },

    isWater: function(){

        var water = [ "SOL", "WAT", "HOH", "H2O", "W" ];

        return function(){

            return water.indexOf( this.resname ) !== -1;

        }

    }(),

    hasProteinBackbone: function(){

        return NGL.Residue.makeHasBackboneFn(
            function(){
                return this.isProtein();
            },
            NGL.Residue.atomnames[ NGL.ProteinBackboneType ]
        );

    }(),

    hasRnaBackbone: function(){

        var resnames = [ "A", "C", "T", "G", "U" ];

        return NGL.Residue.makeHasBackboneFn(
            function(){
                return resnames.indexOf( this.resname ) !== -1;
            },
            NGL.Residue.atomnames[ NGL.RnaBackboneType ]
        );

    }(),

    hasDnaBackbone: function(){

        var resnames = [ "DA", "DC", "DT", "DG", "DU" ];

        return NGL.Residue.makeHasBackboneFn(
            function(){
                return resnames.indexOf( this.resname ) !== -1;
            },
            NGL.Residue.atomnames[ NGL.DnaBackboneType ]
        );

    }(),

    hasCgBackbone: function(){

        return this.isCg();

    },

    hasBackbone: function( position ){

        return this.hasProteinBackbone( position ) ||
            this.hasCgBackbone() ||
            this.hasRnaBackbone( position ) ||
            this.hasDnaBackbone( position );

    },

    getResname1: function(){

        return NGL.AA1[ this.resname.toUpperCase() ] || '?';

    },

    getType: function(){

        if( this.isProtein() ){

            return NGL.ProteinType;

        }else if( this.isNucleic() ){

            return NGL.NucleicType;

        }else if( this.isCg() ){

            return NGL.CgType;

        }else if( this.isWater() ){

            return NGL.WaterType;

        }else{

            return NGL.UnknownType;

        }

    },

    getBackboneType: function( position ){

        if( this.hasProteinBackbone( position ) ){

            return NGL.ProteinBackboneType;

        }else if( this.hasRnaBackbone( position ) ){

            return NGL.RnaBackboneType;

        }else if( this.hasDnaBackbone( position ) ){

            return NGL.DnaBackboneType;

        }else if( this.isCg() ){

            return NGL.CgType;

        }else{

            return NGL.UnknownType;

        }

    },

    nextAtomIndex: function(){

        this.atomCount += 1;
        return this.chain.nextAtomIndex();

    },

    addAtom: function( a ){

        if( !a ){
            a = new NGL.Atom( this );
        }else{
            a.residue = this;
        }
        a.index = this.nextAtomIndex();
        this.atoms.push( a );
        return a;

    },

    addProxyAtom: function( atomArray ){

        var a = new NGL.ProxyAtom( atomArray, this.nextAtomIndex() );
        a.residue = this;
        this.atoms.push( a );
        return a;

    },

    eachAtom: function( callback, selection ){

        var i, a;
        var n = this.atomCount;

        if( selection && (
                selection.atomOnlyTest ||
                ( this.chain.chainname === "" && selection.test )
            )
        ){

            // NGL.log( "residue.eachAtom#atom", selection.selection )

            var test;
            if( this.chain.chainname === "" ){
                test = selection.test;
            }else{
                test = selection.atomOnlyTest;
            }

            for( i = 0; i < n; ++i ){

                a = this.atoms[ i ];
                if( test( a ) ) callback( a );

            }

        }else{

            for( i = 0; i < n; ++i ){

                callback( this.atoms[ i ] );

            }

        }

    },

    getAtomByName: function( atomname ){

        var i, a;
        var atom = undefined;
        var n = this.atomCount;

        if( Array.isArray( atomname ) ){

            for( i = 0; i < n; ++i ){

                a = this.atoms[ i ];

                if( atomname.indexOf( a.atomname ) !== -1 ){

                    atom = a;
                    break

                }

            }

        }else{

            for( i = 0; i < n; ++i ){

                a = this.atoms[ i ];

                if( atomname === a.atomname ){

                    atom = a;
                    break

                }

            }

        }

        return atom;

    },

    hasAtomWithName: function( atomname ){

        var n = arguments.length;

        for( var i = 0; i < n; ++i ){

            if( this.getAtomByName( arguments[ i ] ) === undefined ){

                return false;

            }

        }

        return true;

    },

    getAtomnameList: function(){

        var n = this.atoms.length;
        var list = [];

        for( var i = 0; i < n; ++i ){

            list.push( this.atoms[ i ].atomname );

        }

        return list;

    },

    getTraceAtom: function(){

        return this.getAtomByName(
            NGL.Residue.atomnames[ this.getBackboneType( 0 ) ].trace
        );

    },

    getDirectionAtom1: function(){

        return this.getAtomByName(
            NGL.Residue.atomnames[ this.getBackboneType( 0 ) ].direction1
        );

    },

    getDirectionAtom2: function(){

        return this.getAtomByName(
            NGL.Residue.atomnames[ this.getBackboneType( 0 ) ].direction2
        );

    },

    getBackboneAtomStart: function(){

        return this.getAtomByName(
            NGL.Residue.atomnames[ this.getBackboneType( -1 ) ].backboneStart
        );

    },

    getBackboneAtomEnd: function(){

        return this.getAtomByName(
            NGL.Residue.atomnames[ this.getBackboneType( 1 ) ].backboneEnd
        );

    },

    connectedTo: function( rNext ){

        return this.getBackboneAtomStart().connectedTo(
            rNext.getBackboneAtomEnd()
        );

    },

    getNextConnectedResidue: function(){

        var chainResidues = this.chain.residues;
        var idx = chainResidues.indexOf( this );

        if( idx !== -1 && idx < chainResidues.length ){

            var nextResidue = chainResidues[ idx + 1 ];

            if( this.connectedTo( nextResidue ) ){

                return nextResidue;

            }

        }

        return undefined;

    },

    getPreviousConnectedResidue: function(){

        var chainResidues = this.chain.residues;
        var idx = chainResidues.indexOf( this );

        if( idx !== -1 && idx > 0 ){

            var prevResidue = chainResidues[ idx - 1 ];

            if( prevResidue.connectedTo( this ) ){

                return prevResidue;

            }

        }

        return undefined;

    },

    qualifiedName: function( noResname ){

        var name = "";

        if( this.resname && !noResname ) name += "[" + this.resname + "]";
        if( this.resno ) name += this.resno;
        if( this.chain ) name += ":" + this.chain.chainname;

        if( this.chain && this.chain.model ){
            name += "/" + this.chain.model.index;
        }

        return name;

    },

    copy: function( r ){

        this.resno = r.resno;
        this.resname = r.resname;
        this.ss = r.ss;

    },

    clone: function( c ){

        var r = new NGL.Residue( c );

        r.resno = this.resno;
        r.resname = this.resname;

        this.eachAtom( function( a ){

            r.addAtom( a.clone( r ) );

        } );

        return r;

    },

    toJSON: function(){

        var output = {

            resno: this.resno,
            resname: this.resname,
            _ss: this._ss,

        };

        output.atoms = [];

        if( this.chain.model.structure.atomArray ){

            this.eachAtom( function( a ){

                output.atoms.push( a.index );

            } );

        }else{

            this.eachAtom( function( a ){

                output.atoms.push( a.toJSON() );

            } );

        }

        return output;

    },

    fromJSON: function( input ){

        this.resno = input.resno;
        this.resname = input.resname;
        this._ss = input._ss;

        if( this.chain.model.structure.atomArray ){

            var atomArray = this.chain.model.structure.atomArray;

            input.atoms.forEach( function( i ){

                this.addAtom( new NGL.ProxyAtom( atomArray, i ) );

            }.bind( this ) );

        }else{

            input.atoms.forEach( function( a ){

                this.addAtom( new NGL.Atom( this ).fromJSON( a ) );

            }.bind( this ) );

        }

        return this;

    }

};

NGL.AtomSet.prototype.apply( NGL.Residue.prototype );


NGL.Atom = function( residue ){

    this.residue = residue;

    this.bonds = [];

}

NGL.Atom.prototype = {

    constructor: NGL.Atom,

    index: undefined,
    atomno: undefined,
    resname: undefined,
    x: undefined,
    y: undefined,
    z: undefined,
    element: undefined,
    chainname: undefined,
    resno: undefined,
    serial: undefined,
    ss: undefined,
    vdw: undefined,
    covalent: undefined,
    hetero: undefined,
    bfactor: undefined,
    altloc: undefined,
    atomname: undefined,
    modelindex: undefined,

    residue: undefined,
    bonds: undefined,

    distanceTo: function( atom ){

        var x = this.x - atom.x;
        var y = this.y - atom.y;
        var z = this.z - atom.z;

        var distSquared = x * x + y * y + z * z;

        return Math.sqrt( distSquared );

    },

    connectedTo: function( atom ){

        if( !( this.altloc === '' || atom.altloc === '' ||
                ( this.altloc === atom.altloc ) ) ) return false;

        var x = this.x - atom.x;
        var y = this.y - atom.y;
        var z = this.z - atom.z;

        var distSquared = x * x + y * y + z * z;

        // NGL.log( distSquared );
        if( distSquared < 28.0 && this.residue.isCg() ) return true;

        if( isNaN( distSquared ) ) return false;

        var d = this.covalent + atom.covalent;
        var d1 = d + 0.3;
        var d2 = d - 0.5;

        return distSquared < ( d1 * d1 ) && distSquared > ( d2 * d2 );

    },

    qualifiedName: function( noResname ){

        var name = "";

        if( this.resname && !noResname ) name += "[" + this.resname + "]";
        if( this.resno ) name += this.resno;
        if( this.chainname ) name += ":" + this.chainname;
        if( this.atomname ) name += "." + this.atomname;
        if( this.residue && this.residue.chain &&
                this.residue.chain.model ){
            name += "/" + this.residue.chain.model.index;
        }

        return name;

    },

    positionFromArray: function( array, offset ){

        if( offset === undefined ) offset = 0;

        this.x = array[ offset + 0 ];
        this.y = array[ offset + 1 ];
        this.z = array[ offset + 2 ];

        return this;

    },

    positionToArray: function( array, offset ){

        if( array === undefined ) array = [];
        if( offset === undefined ) offset = 0;

        array[ offset + 0 ] = this.x;
        array[ offset + 1 ] = this.y;
        array[ offset + 2 ] = this.z;

        return array;

    },

    positionToVector3: function( v ){

        if( v === undefined ) v = new THREE.Vector3();

        v.x = this.x;
        v.y = this.y;
        v.z = this.z;

        return v;

    },

    positionFromVector3: function( v ){

        this.x = v.x;
        this.y = v.y;
        this.z = v.z;

        return this;

    },

    copy: function( atom ){

        // this.index = atom.index;
        this.atomno = atom.atomno;
        this.resname = atom.resname;
        this.x = atom.x;
        this.y = atom.y;
        this.z = atom.z;
        this.element = atom.element;
        this.chainname = atom.chainname;
        this.resno = atom.resno;
        this.serial = atom.serial;
        this.ss = atom.ss;
        this.vdw = atom.vdw;
        this.covalent = atom.covalent;
        this.hetero = atom.hetero;
        this.bfactor = atom.bfactor;
        this.bonds = atom.bonds;
        this.altloc = atom.altloc;
        this.atomname = atom.atomname;
        this.modelindex = atom.modelindex;

        this.residue = atom.residue;

        return this;

    },

    clone: function( r ){

        var a = new NGL.Atom( r );

        // a.index = this.index;
        a.atomno = this.atomno;
        a.resname = this.resname;
        a.x = this.x;
        a.y = this.y;
        a.z = this.z;
        a.element = this.element;
        a.chainname = this.chainname;
        a.resno = this.resno;
        a.serial = this.serial;
        a.ss = this.ss;
        a.vdw = this.vdw;
        a.covalent = this.covalent;
        a.hetero = this.hetero;
        a.bfactor = this.bfactor;
        // a.bonds = this.bonds;  // cloned in structure.clone()
        a.altloc = this.altloc;
        a.atomname = this.atomname;
        a.modelindex = this.modelindex;

        return a;

    },

    toJSON: function(){

        var output = {

            index: this.index,
            atomno: this.atomno,
            resname: this.resname,
            x: this.x,
            y: this.y,
            z: this.z,
            element: this.element,
            chainname: this.chainname,
            resno: this.resno,
            serial: this.serial,
            ss: this.ss,
            vdw: this.vdw,
            covalent: this.covalent,
            hetero: this.hetero,
            bfactor: this.bfactor,
            // bonds: this.bonds,  // exported in structure.toJSON()
            altloc: this.altloc,
            atomname: this.atomname,
            modelindex: this.modelindex,

        };

        return output;

    },

    fromJSON: function( input ){

        // this.index = input.index;
        this.atomno = input.atomno;
        this.resname = input.resname;
        this.x = input.x;
        this.y = input.y;
        this.z = input.z;
        this.element = input.element;
        this.chainname = input.chainname;
        this.resno = input.resno;
        this.serial = input.serial;
        this.ss = input.ss;
        this.vdw = input.vdw;
        this.covalent = input.covalent;
        this.hetero = input.hetero;
        this.bfactor = input.bfactor;
        // a.bonds = input.bonds;  // imported in structure.fromJSON()
        this.altloc = input.altloc;
        this.atomname = input.atomname;
        this.modelindex = input.modelindex;

        return this;

    }

}


NGL.AtomArray = function( sizeOrObject ){

    this.useBuffer = false;

    if( Number.isInteger( sizeOrObject ) ){

        this.init( sizeOrObject );

    }else{

        this.fromJSON( sizeOrObject );

    }

};

NGL.AtomArray.prototype = {

    constructor: NGL.AtomArray,

    init: function( size ){

        this.length = size;
        this.usedLength = 0;

        if( this.useBuffer ){

            this.makeOffsetAndSize();
            this.buffer = new ArrayBuffer( this.byteLength );
            this.makeTypedArrays();

        }else{

            this.atomno = new Int32Array( size );
            this.resname = new Uint8Array( 5 * size );
            this.x = new Float32Array( size );
            this.y = new Float32Array( size );
            this.z = new Float32Array( size );
            this.element = new Uint8Array( 3 * size );
            this.chainname = new Uint8Array( 4 * size );
            this.resno = new Int32Array( size );
            this.serial = new Int32Array( size );
            this.ss = new Uint8Array( size );
            this.vdw = new Float32Array( size );
            this.covalent = new Float32Array( size );
            this.hetero = new Uint8Array( size );
            this.bfactor = new Float32Array( size );
            this.altloc = new Uint8Array( size );
            this.atomname = new Uint8Array( 4 * size );
            this.modelindex = new Int32Array( size );

        }

        this.makeBonds();
        this.makeResidue();

    },

    getTransferable: function(){

        if( this.useBuffer ){

            return [ this.buffer ];

        }else{

            return [
                this.atomno.buffer,
                this.resname.buffer,
                this.x.buffer,
                this.y.buffer,
                this.z.buffer,
                this.element.buffer,
                this.chainname.buffer,
                this.resno.buffer,
                this.serial.buffer,
                this.ss.buffer,
                this.vdw.buffer,
                this.covalent.buffer,
                this.hetero.buffer,
                this.bfactor.buffer,
                this.altloc.buffer,
                this.atomname.buffer,
                this.modelindex.buffer
            ];

        }

    },

    makeOffsetAndSize: function(){

        var size = this.length;

        // align the offset to multiple of 4 when necessary
        // (offset + 3) & ~0x3 == (offset + 3) / 4 * 4;

        // Int32

        this.atomnoOffset = 0;
        this.atomnoSize = 4 * size;

        this.resnoOffset = this.atomnoOffset + this.atomnoSize;
        this.resnoSize = 4 * size;

        this.serialOffset = this.resnoOffset + this.resnoSize;
        this.serialSize = 4 * size;

        this.modelindexOffset = this.serialOffset + this.serialSize;
        this.modelindexSize = 4 * size;

        // Float32

        this.xOffset = this.modelindexOffset + this.modelindexSize;
        this.xSize = 4 * size;

        this.yOffset = this.xOffset + this.xSize;
        this.ySize = 4 * size;

        this.zOffset = this.yOffset + this.ySize;
        this.zSize = 4 * size;

        this.vdwOffset = this.zOffset + this.zSize;
        this.vdwSize = 4 * size;

        this.covalentOffset = this.vdwOffset + this.vdwSize;
        this.covalentSize = 4 * size;

        this.bfactorOffset = this.covalentOffset + this.covalentSize;
        this.bfactorSize = 4 * size;

        // Uint8

        this.atomnameOffset = this.bfactorOffset + this.bfactorSize;
        this.atomnameSize = 4 * size;

        this.chainnameOffset = this.atomnameOffset + this.atomnameSize;
        this.chainnameSize = 4 * size;

        this.elementOffset = this.chainnameOffset + this.chainnameSize;
        this.elementSize = 3 * size;

        this.resnameOffset = this.elementOffset + this.elementSize;
        this.resnameSize =  5 * size;

        this.ssOffset = this.resnameOffset + this.resnameSize;
        this.ssSize = size;

        this.heteroOffset = this.ssOffset + this.ssSize;
        this.heteroSize = size;

        this.altlocOffset = this.heteroOffset + this.heteroSize;
        this.altlocSize = size;

        this.byteLength = this.altlocOffset + this.altlocSize;

    },

    makeTypedArrays: function(){

        var size = this.length;

        this.atomno = new Int32Array( this.buffer, this.atomnoOffset, this.atomnoSize / 4 );
        this.resname = new Uint8Array( this.buffer, this.resnameOffset, this.resnameSize );
        this.x = new Float32Array( this.buffer, this.xOffset, this.xSize / 4 );
        this.y = new Float32Array( this.buffer, this.yOffset, this.ySize / 4 );
        this.z = new Float32Array( this.buffer, this.zOffset, this.zSize / 4 );
        this.element = new Uint8Array( this.buffer, this.elementOffset, this.elementSize );
        this.chainname = new Uint8Array( this.buffer, this.chainnameOffset, this.chainnameSize );
        this.resno = new Int32Array( this.buffer, this.resnoOffset, this.resnoSize / 4 );
        this.serial = new Int32Array( this.buffer, this.serialOffset, this.serialSize / 4 );
        this.ss = new Uint8Array( this.buffer, this.ssOffset, this.ssSize );
        this.vdw = new Float32Array( this.buffer, this.vdwOffset, this.vdwSize / 4 );
        this.covalent = new Float32Array( this.buffer, this.covalentOffset, this.covalentSize / 4 );
        this.hetero = new Uint8Array( this.buffer, this.heteroOffset, this.heteroSize );
        this.bfactor = new Float32Array( this.buffer, this.bfactorOffset, this.bfactorSize / 4 );
        this.altloc = new Uint8Array( this.buffer, this.altlocOffset, this.altlocSize );
        this.atomname = new Uint8Array( this.buffer, this.atomnameOffset, this.atomnameSize );
        this.modelindex = new Int32Array( this.buffer, this.modelindexOffset, this.modelindexSize / 4 );

    },

    makeResidue: function(){

        this.residue = new Array( this.length );

    },

    makeBonds: function(){

        var size = this.length;

        this.bonds = new Array( size );

        for( var i = 0; i < size; ++i ){
            this.bonds[ i ] = [];
        }

    },

    setResname: function( i, str ){

        var j = 5 * i;
        this.resname[ j ] = str.charCodeAt( 0 );
        this.resname[ j + 1 ] = str.charCodeAt( 1 );
        this.resname[ j + 2 ] = str.charCodeAt( 2 );
        this.resname[ j + 3 ] = str.charCodeAt( 3 );
        this.resname[ j + 4 ] = str.charCodeAt( 4 );

    },

    getResname: function( i ){

        var code;
        var resname = "";
        var j = 5 * i;
        for( var k = 0; k < 5; ++k ){
            code = this.resname[ j + k ];
            if( code ){
                resname += String.fromCharCode( code );
            }else{
                break;
            }
        }
        return resname;

    },

    setElement: function( i, str ){

        var j = 3 * i;
        this.element[ j ] = str.charCodeAt( 0 );
        this.element[ j + 1 ] = str.charCodeAt( 1 );
        this.element[ j + 2 ] = str.charCodeAt( 2 );

    },

    getElement: function( i ){

        var code;
        var element = "";
        var j = 3 * i;
        for( var k = 0; k < 3; ++k ){
            code = this.element[ j + k ];
            if( code ){
                element += String.fromCharCode( code );
            }else{
                break;
            }
        }
        return element;

    },

    setChainname: function( i, str ){

        var j = 4 * i;
        this.chainname[ j ] = str.charCodeAt( 0 );
        this.chainname[ j + 1 ] = str.charCodeAt( 1 );
        this.chainname[ j + 2 ] = str.charCodeAt( 2 );
        this.chainname[ j + 3 ] = str.charCodeAt( 3 );

    },

    getChainname: function( i ){

        var code;
        var chainname = "";
        var j = 4 * i;
        for( var k = 0; k < 4; ++k ){
            code = this.chainname[ j + k ];
            if( code ){
                chainname += String.fromCharCode( code );
            }else{
                break;
            }
        }
        return chainname;

    },

    setSS: function( i, str ){

        this.ss[ i ] = str.charCodeAt( 0 );

    },

    getSS: function( i ){

        var code = this.ss[ i ];
        return code ? String.fromCharCode( code ) : "";

    },

    setAltloc: function( i, str ){

        this.altloc[ i ] = str.charCodeAt( 0 );

    },

    getAltloc: function( i ){

        var code = this.altloc[ i ];
        return code ? String.fromCharCode( code ) : "";

    },

    setAtomname: function( i, str ){

        var j = 4 * i;
        this.atomname[ j ] = str.charCodeAt( 0 );
        this.atomname[ j + 1 ] = str.charCodeAt( 1 );
        this.atomname[ j + 2 ] = str.charCodeAt( 2 );
        this.atomname[ j + 3 ] = str.charCodeAt( 3 );

    },

    getAtomname: function( i ){

        var code;
        var atomname = "";
        var j = 4 * i;
        for( var k = 0; k < 4; ++k ){
            code = this.atomname[ j + k ];
            if( code ){
                atomname += String.fromCharCode( code );
            }else{
                break;
            }
        }
        return atomname;

    },

    clone: function(){

        // FIXME take useBuffer into account

        var aa = new NGL.AtomArray( this.length );

        aa.atomno.set( this.atomno );
        aa.resname.set( this.resname );
        aa.x.set( this.x );
        aa.y.set( this.y );
        aa.z.set( this.z );
        aa.element.set( this.element );
        aa.chainname.set( this.chainname );
        aa.resno.set( this.resno );
        aa.serial.set( this.serial );
        aa.ss.set( this.ss );
        aa.vdw.set( this.vdw );
        aa.covalent.set( this.covalent );
        aa.hetero.set( this.hetero );
        aa.bfactor.set( this.bfactor );
        aa.altloc.set( this.altloc );
        aa.atomname.set( this.atomname );
        aa.modelindex.set( this.modelindex );

        aa.usedLength = this.usedLength;

        return aa;

    },

    toJSON: function(){

        if( this.useBuffer ){

            return {
                length: this.length,
                usedLength: this.usedLength,

                buffer: this.buffer,

                // bonds: this.bonds,
                // residue: this.residue
            };

        }else{

            return {
                length: this.length,
                usedLength: this.usedLength,

                atomno: this.atomno,
                resname: this.resname,
                x: this.x,
                y: this.y,
                z: this.z,
                element: this.element,
                chainname: this.chainname,
                resno: this.resno,
                serial: this.serial,
                ss: this.ss,
                vdw: this.vdw,
                covalent: this.covalent,
                hetero: this.hetero,
                bfactor: this.bfactor,
                altloc: this.altloc,
                atomname: this.atomname,
                modelindex: this.modelindex,

                // bonds: this.bonds,
                // residue: this.residue
            };

        }

    },

    fromJSON: function( input ){

        this.length = input.length;
        this.usedLength = input.usedLength;

        if( this.useBuffer ){

            this.makeOffsetAndSize();
            this.buffer = input.buffer;
            this.makeTypedArrays();

        }else{

            this.atomno = input.atomno;
            this.resname = input.resname;
            this.x = input.x;
            this.y = input.y;
            this.z = input.z;
            this.element = input.element;
            this.chainname = input.chainname;
            this.resno = input.resno;
            this.serial = input.serial;
            this.ss = input.ss;
            this.vdw = input.vdw;
            this.covalent = input.covalent;
            this.hetero = input.hetero;
            this.bfactor = input.bfactor;
            this.altloc = input.altloc;
            this.atomname = input.atomname;
            this.modelindex = input.modelindex;

        }

        if( input.bonds ){
            this.bonds = input.bonds;
        }else{
            this.makeBonds();
        }

        if( input.residue ){
            this.residue = input.residue;
        }else{
            this.makeResidue();
        }

    },

    dispose: function(){

        if( this.useBuffer ){

            delete this.buffer;

        }

        delete this.atomno;
        delete this.resname;
        delete this.x;
        delete this.y;
        delete this.z;
        delete this.element;
        delete this.chainname;
        delete this.resno;
        delete this.serial;
        delete this.ss;
        delete this.vdw;
        delete this.covalent;
        delete this.hetero;
        delete this.bfactor;
        delete this.altloc;
        delete this.atomname;
        delete this.modelindex;

        delete this.bonds;
        delete this.residue;

        this.length = 0;
        this.usedLength = 0;

    }

};


NGL.ProxyAtom = function( atomArray, index ){

    this.atomArray = atomArray;
    this.index = index;

};

NGL.ProxyAtom.prototype = {

    constructor: NGL.ProxyAtom,

    atomArray: undefined,
    index: undefined,

    get atomno () {
        return this.atomArray.atomno[ this.index ];
    },
    set atomno ( value ) {
        this.atomArray.atomno[ this.index ] = value;
    },

    get resname () {
        return this.atomArray.getResname( this.index );
    },
    set resname ( value ) {
        this.atomArray.setResname( this.index, value );
    },

    get x () {
        return this.atomArray.x[ this.index ];
    },
    set x ( value ) {
        this.atomArray.x[ this.index ] = value;
    },

    get y () {
        return this.atomArray.y[ this.index ];
    },
    set y ( value ) {
        this.atomArray.y[ this.index ] = value;
    },

    get z () {
        return this.atomArray.z[ this.index ];
    },
    set z ( value ) {
        this.atomArray.z[ this.index ] = value;
    },

    get element () {
        return this.atomArray.getElement( this.index );
    },
    set element ( value ) {
        this.atomArray.setElement( this.index, value );
    },

    get chainname () {
        return this.atomArray.getChainname( this.index );
    },
    set chainname ( value ) {
        this.atomArray.setChainname( this.index, value );
    },

    get resno () {
        return this.atomArray.resno[ this.index ];
    },
    set resno ( value ) {
        this.atomArray.resno[ this.index ] = value;
    },

    get serial () {
        return this.atomArray.serial[ this.index ];
    },
    set serial ( value ) {
        this.atomArray.serial[ this.index ] = value;
    },

    get ss () {
        return this.atomArray.getSS( this.index );
    },
    set ss ( value ) {
        this.atomArray.setSS( this.index, value );
    },

    get vdw () {
        return this.atomArray.vdw[ this.index ];
    },
    set vdw ( value ) {
        this.atomArray.vdw[ this.index ] = value;
    },

    get covalent () {
        return this.atomArray.covalent[ this.index ];
    },
    set covalent ( value ) {
        this.atomArray.covalent[ this.index ] = value;
    },

    get hetero () {
        return this.atomArray.hetero[ this.index ];
    },
    set hetero ( value ) {
        this.atomArray.hetero[ this.index ] = value;
    },

    get bfactor () {
        return this.atomArray.bfactor[ this.index ];
    },
    set bfactor ( value ) {
        this.atomArray.bfactor[ this.index ] = value;
    },

    get bonds () {
        return this.atomArray.bonds[ this.index ];
    },
    set bonds ( value ) {
        this.atomArray.bonds[ this.index ] = value;
    },

    get altloc () {
        return this.atomArray.getAltloc( this.index );
    },
    set altloc ( value ) {
        this.atomArray.setAltloc( this.index, value );
    },

    get atomname () {
        return this.atomArray.getAtomname( this.index );
    },
    set atomname ( value ) {
        this.atomArray.setAtomname( this.index, value );
    },

    get residue () {
        return this.atomArray.residue[ this.index ];
    },
    set residue ( value ) {
        this.atomArray.residue[ this.index ] = value;
    },

    get modelindex () {
        return this.atomArray.modelindex[ this.index ];
    },
    set modelindex ( value ) {
        this.atomArray.modelindex[ this.index ] = value;
    },

    // distanceTo: NGL.Atom.prototype.distanceTo,

    distanceTo: function( atom ){

        var taa = this.atomArray;
        var aaa = atom.atomArray;
        var ti = this.index;
        var ai = atom.index;

        var x = taa.x[ ti ] - aaa.x[ ai ];
        var y = taa.y[ ti ] - aaa.y[ ai ];
        var z = taa.z[ ti ] - aaa.z[ ai ];

        var distSquared = x * x + y * y + z * z;

        return Math.sqrt( distSquared );

    },

    // connectedTo: NGL.Atom.prototype.connectedTo,

    connectedTo: function( atom ){

        var taa = this.atomArray;
        var aaa = atom.atomArray;
        var ti = this.index;
        var ai = atom.index;
        var ta = taa.altloc[ ti ];  // use Uint8 value to compare
        var aa = aaa.altloc[ ai ];  // no need to convert to char

        if( !( ta === 0 || aa === 0 || ( ta === aa ) ) ) return false;

        var x = taa.x[ ti ] - aaa.x[ ai ];
        var y = taa.y[ ti ] - aaa.y[ ai ];
        var z = taa.z[ ti ] - aaa.z[ ai ];

        var distSquared = x * x + y * y + z * z;

        // NGL.log( distSquared );
        if( distSquared < 28.0 && taa.residue[ ti ].isCg() ) return true;

        if( isNaN( distSquared ) ) return false;

        var d = taa.covalent[ ti ] + aaa.covalent[ ai ];
        var d1 = d + 0.3;
        var d2 = d - 0.5;

        return distSquared < ( d1 * d1 ) && distSquared > ( d2 * d2 );

    },

    qualifiedName: NGL.Atom.prototype.qualifiedName,

    positionFromArray: NGL.Atom.prototype.positionFromArray,

    positionToArray: NGL.Atom.prototype.positionToArray,

    positionFromVector3: NGL.Atom.prototype.positionFromVector3,

    positionToVector3: NGL.Atom.prototype.positionToVector3,

    // copy: NGL.Atom.prototype.copy,

    copy: function( atom, index ){

        if( index !== undefined ){
            this.index = index;
        }else if( this.index === undefined ){
            NGL.warn( "NGL.ProxyAtom.copy no index set" );
        }

        this.atomno = atom.atomno;
        this.resname = atom.resname;
        this.x = atom.x;
        this.y = atom.y;
        this.z = atom.z;
        this.element = atom.element;
        this.chainname = atom.chainname;
        this.resno = atom.resno;
        this.serial = atom.serial;
        this.ss = atom.ss;
        this.vdw = atom.vdw;
        this.covalent = atom.covalent;
        this.hetero = atom.hetero;
        this.bfactor = atom.bfactor;
        this.bonds = atom.bonds;
        this.altloc = atom.altloc;
        this.atomname = atom.atomname;
        this.modelindex = atom.modelindex;

        this.residue = atom.residue;

        return this;

    },

    clone: function( r ){

        var atomArray = r.chain.model.structure.atomArray;

        var a = new NGL.ProxyAtom( atomArray, this.index );

        return a;

    },

    toJSON: NGL.Atom.prototype.toJSON,

    fromJSON: function( input ){

        return this;

    }

}


NGL.StructureSubset = function( structure, selection ){

    NGL.Structure.call( this, structure.name, structure.path );

    this.structure = structure;
    this.selection = selection;

    this._build();

};

NGL.StructureSubset.prototype = Object.create( NGL.Structure.prototype );

NGL.StructureSubset.prototype.constructor = NGL.StructureSubset;

NGL.StructureSubset.prototype.setDefaultAssembly = function( value ){

    this.defaultAssembly = value;
    this.structure.setDefaultAssembly( value );

};

NGL.StructureSubset.prototype._build = function(){

    NGL.time( "NGL.StructureSubset._build" );

    var structure = this.structure;
    var selection = this.selection;
    var atoms = this.atoms;
    var bondSet = this.bondSet;

    var _s = this;
    var _m, _c, _r, _a;

    var atomIndexDict = {};

    _s.copy( structure );

    structure.eachModel( function( m ){

        _m = _s.addModel();
        _m.copy( m );

        m.eachChain( function( c ){

            _c = _m.addChain();
            _c.copy( c );

            c.eachResidue( function( r ){

                _r = _c.addResidue();
                _r.copy( r );

                r.eachAtom( function( a ){

                    // TODO by reference? index? bonds? residue?

                    _a = _r.addAtom();
                    _a.copy( a );
                    _a.bonds.length = 0;
                    _a.index = atoms.length;

                    atomIndexDict[ a.index ] = _a;
                    atoms.push( _a );

                }, selection );

                if( _r.atoms.length === 0 ){
                    _c.residues.pop();
                    --_c.residueCount;
                    --_m.residueCount;
                    --_s.residueCount;
                }

            }, selection );

            if( _c.residues.length === 0 ){
                _m.chains.pop();
                --_m.chainCount;
                --_s.chainCount;
            }

        }, selection );

        if( _m.chains.length === 0 ){
            _s.models.pop();
            --_s.modelCount;
        }

    }, selection );

    structure.bondSet.eachBond( function( b ){

        _s.bondSet.addBond(
            atomIndexDict[ b.atom1.index ],
            atomIndexDict[ b.atom2.index ]
        );

    }, selection );

    _s.title = structure.title;
    _s.id = structure.id;

    _s.center = _s.atomCenter();
    _s.boundingBox = _s.getBoundingBox();

    _s.frames = structure.frames;
    _s.boxes = structure.boxes;
    _s.helices = structure.helices;
    _s.sheets = structure.sheets;

    _s.biomolDict = structure.biomolDict;
    _s.defaultAssembly = structure.defaultAssembly;

    NGL.GidPool.updateObject( this );

    NGL.timeEnd( "NGL.StructureSubset._build" );

};

// File:js/ngl/trajectory.js

/**
 * @file Trajectory
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */



NGL.makeTrajectory = function( trajSrc, structure, sele ){

    var traj;

    if( trajSrc instanceof NGL.Frames || trajSrc instanceof Promise ){

        traj = new NGL.FramesTrajectory( trajSrc, structure, sele );

    }else if( !trajSrc && structure.frames ){

        traj = new NGL.StructureTrajectory( trajSrc, structure, sele );

    }else{

        traj = new NGL.RemoteTrajectory( trajSrc, structure, sele );

    }

    return traj;

};


///////////
// Frames

NGL.Frames = function( name, path ){

    this.name = name;
    this.path = path;

    this.coordinates = [];
    this.boxes = [];

};

NGL.Frames.prototype = {

    constructor: NGL.Frames,

    toJSON: function(){

        var output = {

            metadata: {
                version: 0.1,
                type: 'Frames',
                generator: 'FramesExporter'
            },

            name: this.name,
            path: this.path,

            coordinates: this.coordinates,
            boxes: this.boxes

        };

        return output;

    },

    fromJSON: function( input ){

        this.name = input.name;
        this.path = input.path;

        this.coordinates = input.coordinates;
        this.boxes = input.boxes;

    },

    getTransferable: function(){

        var transferable = [];

        var coordinates = this.coordinates;
        var n = coordinates.length;

        for( var i = 0; i < n; ++i ){

            transferable.push( coordinates[ i ].buffer );

        }

        return transferable;

    }

};


///////////////
// Trajectory

// TODO params handling in constructor and getParameters method
NGL.Trajectory = function( trajPath, structure, selectionString ){

    var scope = this;

    var SIGNALS = signals;

    this.signals = {

        gotNumframes: new SIGNALS.Signal(),
        frameChanged: new SIGNALS.Signal(),
        selectionChanged: new SIGNALS.Signal(),
        playerChanged: new SIGNALS.Signal(),

    };

    this.params = {
        centerPbc: true,
        removePbc: true,
        superpose: true
    };

    this.name = trajPath.replace( /^.*[\\\/]/, '' );

    this.selection = new NGL.Selection(
        selectionString || "backbone and not hydrogen"
    );

    this.selection.signals.stringChanged.add( function( string ){

        scope.makeIndices();
        scope.resetCache();

    } );

    // should come after this.selection is set
    this.setStructure( structure );

    this.trajPath = trajPath;

    this.numframes = undefined;
    this.getNumframes();

};

NGL.Trajectory.prototype = {

    constructor: NGL.Trajectory,

    setStructure: function( structure ){

        this.structure = structure;
        this.atomCount = structure.atomCount;

        this.makeAtomIndices();

        this.saveInitialStructure();

        this.backboneIndices = this.structure.atomIndex(
            new NGL.Selection( "backbone and not hydrogen" )
        );
        this.makeIndices();

        this.frameCache = [];
        this.boxCache = [];
        this.pathCache = [];
        this.frameCacheSize = 0;
        this.currentFrame = -1;

    },

    saveInitialStructure: function(){

        var i = 0;
        var initialStructure = new Float32Array( 3 * this.atomCount );

        this.structure.eachAtom( function( a ){

            initialStructure[ i + 0 ] = a.x;
            initialStructure[ i + 1 ] = a.y;
            initialStructure[ i + 2 ] = a.z;

            i += 3;

        } );

        this.initialStructure = initialStructure;

    },

    setSelection: function( string ){

        this.selection.setString( string );

        return this;

    },

    makeIndices: function(){

        this.indices = this.structure.atomIndex( this.selection );

        var i, j;
        var n = this.indices.length * 3;

        this.coords1 = new Float32Array( n );
        this.coords2 = new Float32Array( n );

        var y = this.initialStructure;
        var coords2 = this.coords2;

        for( i = 0; i < n; i += 3 ){

            j = this.indices[ i / 3 ] * 3;

            coords2[ i + 0 ] = y[ j + 0 ];
            coords2[ i + 1 ] = y[ j + 1 ];
            coords2[ i + 2 ] = y[ j + 2 ];

        }

    },

    makeAtomIndices: function(){

        NGL.error( "Trajectory.makeAtomIndices not implemented" );

    },

    getNumframes: function(){

        NGL.error( "Trajectory.loadFrame not implemented" );

    },

    resetCache: function(){

        this.frameCache = [];
        this.boxCache = [];
        this.pathCache = [];
        this.frameCacheSize = 0;
        this.setFrame( this.currentFrame );

        return this;

    },

    setParameters: function( params ){

        var p = params;
        var tp = this.params;
        var resetCache = false;

        if( p.centerPbc !== undefined && p.centerPbc !== tp.centerPbc ){

            tp.centerPbc = p.centerPbc;
            resetCache = true;

        }

        if( p.removePbc !== undefined && p.removePbc !== tp.removePbc ){

            tp.removePbc = p.removePbc;
            resetCache = true;

        }

        if( p.superpose !== undefined && p.superpose !== tp.superpose ){

            tp.superpose = p.superpose;
            resetCache = true;

        }

        if( resetCache ) this.resetCache();

    },

    setFrame: function( i, callback ){

        if( i === undefined ) return this;

        this.inProgress = true;

        i = parseInt( i );

        if( i === -1 || this.frameCache[ i ] ){

            this.updateStructure( i, callback );

        }else{

            this.loadFrame( i, function(){

                this.updateStructure( i, callback );

            }.bind( this ) );

        }

        return this;

    },

    interpolate: function(){

        var spline = function( p0, p1, p2, p3, t, tension ) {

            var v0 = ( p2 - p0 ) * tension;
            var v1 = ( p3 - p1 ) * tension;
            var t2 = t * t;
            var t3 = t * t2;

            return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 +
                   ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 +
                   v0 * t + p1;

        }

        var lerp = function( a, b, t ) {

            return a + ( b - a ) * t;

        }

        return function( i, ip, ipp, ippp, t, type, callback ){

            var fc = this.frameCache;

            var c = fc[ i ];
            var cp = fc[ ip ];
            var cpp = fc[ ipp ];
            var cppp = fc[ ippp ];

            var m = c.length;
            var coords = new Float32Array( m );

            if( type === "spline" ){

                for( var j = 0; j < m; j += 3 ){

                    coords[ j + 0 ] = spline(
                        cppp[ j + 0 ], cpp[ j + 0 ], cp[ j + 0 ], c[ j + 0 ], t, 1
                    );
                    coords[ j + 1 ] = spline(
                        cppp[ j + 1 ], cpp[ j + 1 ], cp[ j + 1 ], c[ j + 1 ], t, 1
                    );
                    coords[ j + 2 ] = spline(
                        cppp[ j + 2 ], cpp[ j + 2 ], cp[ j + 2 ], c[ j + 2 ], t, 1
                    );

                }

            }else{

                for( var j = 0; j < m; j += 3 ){

                    coords[ j + 0 ] = lerp( cp[ j + 0 ], c[ j + 0 ], t );
                    coords[ j + 1 ] = lerp( cp[ j + 1 ], c[ j + 1 ], t );
                    coords[ j + 2 ] = lerp( cp[ j + 2 ], c[ j + 2 ], t );

                }

            }

            this.structure.updatePosition( coords );
            this.currentFrame = i;
            this.signals.frameChanged.dispatch( i );

            if( typeof callback === "function" ){

                callback();

            }

        }

    }(),

    setFrameInterpolated: function( i, ip, ipp, ippp, t, type, callback ){

        if( i === undefined ) return this;

        var fc = this.frameCache;

        var iList = [];

        if( !fc[ ippp ] ) iList.push( ippp );
        if( !fc[ ipp ] ) iList.push( ipp );
        if( !fc[ ip ] ) iList.push( ip );
        if( !fc[ i ] ) iList.push( i );

        if( iList.length ){

            this.loadFrame( iList, function(){

                this.interpolate( i, ip, ipp, ippp, t, type, callback );

            }.bind( this ) );

        }else{

            this.interpolate( i, ip, ipp, ippp, t, type, callback );

        }

        return this;

    },

    loadFrame: function( i, callback ){

        if( Array.isArray( i ) ){

            var scope = this;

            async.eachLimit(

                i, 4,

                function( j, wcallback ){

                    scope._loadFrame( j, wcallback );

                },

                function( error ){

                    if( typeof callback === "function" ){

                        callback();

                    }

                }

            );

        }else{

            this._loadFrame( i, callback );

        }

    },

    _loadFrame: function( i, callback ){

        NGL.error( "Trajectory._loadFrame not implemented" );

    },

    updateStructure: function( i, callback ){

        if( this._disposed ) return;

        if( i === -1 ){

            this.structure.updatePosition( this.initialStructure );

        }else{

            this.structure.updatePosition( this.frameCache[ i ] );

        }

        this.structure.trajectory = {
            name: this.trajPath,
            frame: i
        };

        if( typeof callback === "function" ){

            callback();

        }

        this.currentFrame = i;

        this.inProgress = false;

        this.signals.frameChanged.dispatch( i );

    },

    getCircularMean: function( indices, coords, box ){

        // NGL.time( "NGL.Trajectory.getCircularMean" );

        var mean = [

            NGL.Utils.circularMean( coords, box[ 0 ], 3, 0, indices ),
            NGL.Utils.circularMean( coords, box[ 1 ], 3, 1, indices ),
            NGL.Utils.circularMean( coords, box[ 2 ], 3, 2, indices )

        ];

        // NGL.timeEnd( "NGL.Trajectory.getCircularMean" );

        return mean;

    },

    centerPbc: function( coords, mean, box ){

        // NGL.time( "NGL.Trajectory.centerPbc" );

        if( box[ 0 ]===0 || box[ 8 ]===0 || box[ 4 ]===0 ){
            return;
        }

        var i;
        var n = coords.length;

        var bx = box[ 0 ], by = box[ 1 ], bz = box[ 2 ];
        var mx = mean[ 0 ], my = mean[ 1 ], mz = mean[ 2 ];

        var fx = - mx + bx + bx / 2;
        var fy = - my + by + by / 2;
        var fz = - mz + bz + bz / 2;

        for( i = 0; i < n; i += 3 ){

            coords[ i + 0 ] = ( coords[ i + 0 ] + fx ) % bx;
            coords[ i + 1 ] = ( coords[ i + 1 ] + fy ) % by;
            coords[ i + 2 ] = ( coords[ i + 2 ] + fz ) % bz;

        }

        // NGL.timeEnd( "NGL.Trajectory.centerPbc" );

    },

    removePbc: function( x, box ){

        // NGL.time( "NGL.Trajectory.removePbc" );

        if( box[ 0 ]===0 || box[ 8 ]===0 || box[ 4 ]===0 ){
            return;
        }

        // ported from GROMACS src/gmxlib/rmpbc.c:rm_gropbc()
        // in-place

        var i, j, d, dist;
        var n = x.length;

        for( i = 3; i < n; i += 3 ){

            for( j = 0; j < 3; ++j ){

                dist = x[ i + j ] - x[ i - 3 + j ];

                if( Math.abs( dist ) > 0.9 * box[ j * 3 + j ] ){

                    if( dist > 0 ){

                        for( d = 0; d < 3; ++d ){
                            x[ i + d ] -= box[ j * 3 + d ];
                        }

                    }else{

                        for( d = 0; d < 3; ++d ){
                            x[ i + d ] += box[ j * 3 + d ];
                        }

                    }
                }

            }

        }

        // NGL.timeEnd( "NGL.Trajectory.removePbc" );

        return x;

    },

    superpose: function( x ){

        // NGL.time( "NGL.Trajectory.superpose" );

        var i, j;
        var n = this.indices.length * 3;

        var coords1 = this.coords1;
        var coords2 = this.coords2;

        for( i = 0; i < n; i += 3 ){

            j = this.indices[ i / 3 ] * 3;

            coords1[ i + 0 ] = x[ j + 0 ];
            coords1[ i + 1 ] = x[ j + 1 ];
            coords1[ i + 2 ] = x[ j + 2 ];

        }

        // TODO re-use superposition object
        var sp = new NGL.Superposition( coords1, coords2 );
        sp.transform( x );

        // NGL.timeEnd( "NGL.Trajectory.superpose" );

    },

    process: function( i, box, coords, numframes ){

        this.setNumframes( numframes );

        if( box ){

            if( this.backboneIndices.length > 0 && this.params.centerPbc ){
                var box2 = [ box[ 0 ], box[ 4 ], box[ 8 ] ];
                var mean = this.getCircularMean(
                    this.backboneIndices, coords, box2
                );
                this.centerPbc( coords, mean, box2 );
            }

            if( this.params.removePbc ){
                this.removePbc( coords, box );
            }

        }

        if( this.indices.length > 0 && this.params.superpose ){
            this.superpose( coords );
        }

        this.frameCache[ i ] = coords;
        this.boxCache[ i ] = box;
        this.frameCacheSize += 1;

    },

    setNumframes: function( n ){

        if( n !== this.numframes ){

            this.numframes = n;
            this.signals.gotNumframes.dispatch( n );

        }

    },

    dispose: function(){

        this.frameCache = [];  // aid GC
        this._disposed = true;
        if( this.player ) this.player.stop();

    },

    setPlayer: function( player ){

        this.player = player;
        this.signals.playerChanged.dispatch( player );

    },

    getPath: function( index, callback ){

        NGL.error( "Trajectory.getPath not implemented" );

    },

    download: function( step ){

        // TODO format needs to include the number of atoms
        // TODO lower precision, e.g. 20 bit integers
        // TODO don't process, use raw data

        var scope = this;

        var n = this.numframes;
        var k = step;

        var m = Math.ceil( n / k );
        var u = 0;

        var bbt = new Float32Array( m * ( 9 + 3 * this.atomCount ) );

        function getData( j, v ){

            var l = v * ( 9 + 3 * scope.atomCount );

            bbt.set( scope.boxCache[ j ], l );
            bbt.set( scope.frameCache[ j ], l + 9 );

            if( v === m - 1 ){

                var blob = new Blob(
                    [ bbt ], { type: 'application/octet-binary' }
                );

                NGL.download( blob, "traj.bbt" );

            }

        }

        for( var i = 0; i < n; i += k ){

            this.loadFrame( i, function(){

                getData( i, u );

            } );

            u += 1;

        }

    }

};


NGL.RemoteTrajectory = function( trajPath, structure, selectionString ){

    NGL.Trajectory.call( this, trajPath, structure, selectionString );

};

NGL.RemoteTrajectory.prototype = NGL.createObject(

    NGL.Trajectory.prototype, {

    constructor: NGL.RemoteTrajectory,

    type: "remote",

    makeAtomIndices: function(){

        var structure = this.structure;
        var atomIndices = [];

        if( structure instanceof NGL.StructureSubset ){

            var indices = structure.structure.atomIndex( structure.selection );

            var i, r;
            var p = indices[ 0 ];
            var q = indices[ 0 ];
            var n = indices.length;

            for( i = 1; i < n; ++i ){

                r = indices[ i ];

                if( q + 1 < r ){

                    atomIndices.push( [ p, q + 1 ] );
                    p = r;

                }

                q = r;

            }

            atomIndices.push( [ p, q + 1 ] );

        }else{

            atomIndices.push( [ 0, this.atomCount ] );

        }

        this.atomIndices = atomIndices;

    },

    _loadFrame: function( i, callback ){

        // TODO implement max frameCache size, re-use arrays

        // NGL.time( "NGL.RemoteTrajectory._loadFrame" );

        var request = new XMLHttpRequest();

        var ds = NGL.DatasourceRegistry.trajectory;
        var url = ds.getFrameUrl( this.trajPath, i );
        var params = ds.getFrameParams( this.trajPath, this.atomIndices );

        request.open( "POST", url, true );
        request.responseType = "arraybuffer";
        request.setRequestHeader(
            "Content-type", "application/x-www-form-urlencoded"
        );

        request.addEventListener( 'load', function( event ){

            // NGL.timeEnd( "NGL.RemoteTrajectory._loadFrame" );

            var arrayBuffer = request.response;
            if( !arrayBuffer ){
                NGL.error( "empty arrayBuffer for '" + url + "'" );
                return;
            }

            var numframes = new Int32Array( arrayBuffer, 0, 1 )[ 0 ];
            var time = new Float32Array( arrayBuffer, 1 * 4, 1 )[ 0 ];
            var box = new Float32Array( arrayBuffer, 2 * 4, 9 );
            var coords = new Float32Array( arrayBuffer, 11 * 4 );

            this.process( i, box, coords, numframes );
            if( typeof callback === "function" ){
                callback();
            }

        }.bind( this ), false );

        request.send( params );

    },

    getNumframes: function(){

        var loader = new THREE.XHRLoader();
        var ds = NGL.DatasourceRegistry.trajectory;
        var url = ds.getNumframesUrl( this.trajPath );

        loader.load( url, function( n ){
            this.setNumframes( parseInt( n ) );
        }.bind( this ) );

    },

    getPath: function( index, callback ){

        if( this.pathCache[ index ] ){
            callback( this.pathCache[ index ] );
            return;
        }

        NGL.time( "loadPath" );

        var request = new XMLHttpRequest();

        var ds = NGL.DatasourceRegistry.trajectory;
        var url = ds.getPathUrl( this.trajPath, index );
        var params = "";

        request.open( "POST", url, true );
        request.responseType = "arraybuffer";
        request.setRequestHeader(
            "Content-type", "application/x-www-form-urlencoded"
        );

        request.addEventListener( 'load', function( event ){

            NGL.timeEnd( "loadPath" );

            var arrayBuffer = request.response;
            if( !arrayBuffer ){
                NGL.error( "empty arrayBuffer for '" + url + "'" );
                return;
            }

            var path = new Float32Array( arrayBuffer );
            // NGL.log( path )
            this.pathCache[ index ] = path;
            callback( path );

        }.bind( this ), false );

        request.send( params );

    }

} );


NGL.StructureTrajectory = function( trajPath, structure, selectionString ){

    // if( !trajPath ) trajPath = structure.path;
    trajPath = "";

    NGL.Trajectory.call( this, trajPath, structure, selectionString );

};

NGL.StructureTrajectory.prototype = NGL.createObject(

    NGL.Trajectory.prototype, {

    constructor: NGL.StructureTrajectory,

    type: "structure",

    makeAtomIndices: function(){

        var structure = this.structure;

        if( structure instanceof NGL.StructureSubset ){

            this.atomIndices = structure.structure.atomIndex(
                structure.selection
            );

        }else{

            this.atomIndices = null;

        }

    },

    _loadFrame: function( i, callback ){

        var coords;
        var structure = this.structure;
        var frame = this.structure.frames[ i ];

        if( this.atomIndices ){

            var indices = this.atomIndices;
            var m = indices.length;

            coords = new Float32Array( m * 3 );

            for( var j = 0; j < m; ++j ){

                var j3 = j * 3;
                var idx3 = indices[ j ] * 3;

                coords[ j3 + 0 ] = frame[ idx3 + 0 ];
                coords[ j3 + 1 ] = frame[ idx3 + 1 ];
                coords[ j3 + 2 ] = frame[ idx3 + 2 ];

            }

        }else{

            coords = new Float32Array( frame );

        }

        var box = this.structure.boxes[ i ];
        var numframes = this.structure.frames.length;

        this.process( i, box, coords, numframes );

        if( typeof callback === "function" ){

            callback();

        }

    },

    getNumframes: function(){

        this.setNumframes( this.structure.frames.length );

    },

    getPath: function( index, callback ){

        var i, j, f;
        var n = this.numframes;
        var k = index * 3;

        var path = new Float32Array( n * 3 );

        for( i = 0; i < n; ++i ){

            j = 3 * i;
            f = this.structure.frames[ i ];

            path[ j + 0 ] = f[ k + 0 ];
            path[ j + 1 ] = f[ k + 1 ];
            path[ j + 2 ] = f[ k + 2 ];

        }

        callback( path );

    }

} );


NGL.FramesTrajectory = function( frames, structure, selectionString ){

    if( frames instanceof Promise ){

        frames.then( function( _frames ){

            this.setFrames( _frames );
            this.getNumframes();

        }.bind( this ) );

    }else{

        this.setFrames( frames );

    }

    NGL.Trajectory.call( this, "", structure, selectionString );

};

NGL.FramesTrajectory.prototype = NGL.createObject(

    NGL.Trajectory.prototype, {

    constructor: NGL.FramesTrajectory,

    type: "frames",

    setFrames: function( frames ){

        this.name = frames.name;
        this.path = frames.path;

        this.frames = frames.coordinates;
        this.boxes = frames.boxes;

    },

    makeAtomIndices:  function(){

        var structure = this.structure;

        if( structure instanceof NGL.StructureSubset ){

            this.atomIndices = structure.structure.atomIndex(
                structure.selection
            );

        }else{

            this.atomIndices = null;

        }

    },

    _loadFrame: function( i, callback ){

        var coords;
        var structure = this.structure;
        var frame = this.frames[ i ];

        if( this.atomIndices ){

            var indices = this.atomIndices;
            var m = indices.length;

            coords = new Float32Array( m * 3 );

            for( var j = 0; j < m; ++j ){

                var j3 = j * 3;
                var idx3 = indices[ j ] * 3;

                coords[ j3 + 0 ] = frame[ idx3 + 0 ];
                coords[ j3 + 1 ] = frame[ idx3 + 1 ];
                coords[ j3 + 2 ] = frame[ idx3 + 2 ];

            }

        }else{

            coords = new Float32Array( frame );

        }

        var box = this.boxes[ i ];
        var numframes = this.frames.length;

        this.process( i, box, coords, numframes );

        if( typeof callback === "function" ){

            callback();

        }

    },

    getNumframes: function(){

        if( this.frames ){

            this.setNumframes( this.frames.length );

        }

    },

    getPath: function( index, callback ){

        var i, j, f;
        var n = this.numframes;
        var k = index * 3;

        var path = new Float32Array( n * 3 );

        for( i = 0; i < n; ++i ){

            j = 3 * i;
            f = this.frames[ i ];

            path[ j + 0 ] = f[ k + 0 ];
            path[ j + 1 ] = f[ k + 1 ];
            path[ j + 2 ] = f[ k + 2 ];

        }

        callback( path );

    }

} );


///////////
// Player

NGL.TrajectoryPlayer = function( traj, step, timeout, start, end ){

    var SIGNALS = signals;

    this.signals = {

        startedRunning: new SIGNALS.Signal(),
        haltedRunning: new SIGNALS.Signal(),

    };

    var scope = this;

    traj.signals.playerChanged.add( function( player ){
        if( player !== scope ){
            scope.pause();
        }
    } );

    this.traj = traj;
    this.step = step || Math.ceil( ( traj.numframes + 1 ) / 100 );
    this.timeout = timeout || 50;
    this.start = start || 0;
    this.end = end || traj.numframes - 1;
    this.end = Math.min( this.end, traj.numframes - 1 );
    this.interpolateType = "";
    this.interpolateStep = 5;

    this.mode = "loop"; // loop, once
    this.direction = "forward"; // forward, backward

    this._stopFlag = false;
    this._running = false;

};

NGL.TrajectoryPlayer.prototype = {

    constructor: NGL.TrajectoryPlayer,

    _animate: function(){

        var i;
        this._running = true;

        if( !this.traj.inProgress && !this._stopFlag ){

            if( this.direction === "forward" ){
                i = this.traj.currentFrame + this.step;
            }else{
                i = this.traj.currentFrame - this.step;
            }

            if( i >= this.end || i < this.start ){

                if( this.mode === "once" ){

                    this.pause();

                    if( this.direction === "forward" ){
                        i = this.end;
                    }else{
                        i = this.start;
                    }

                }else{

                    if( this.direction === "forward" ){
                        i = this.start;
                    }else{
                        i = this.end;
                    }

                }

            }

            if( !this.interpolateType ){

                this.traj.setFrame( i );

            }

        }

        if( !this._stopFlag ){

            if( !this.traj.inProgress && this.interpolateType ){

                var ip, ipp, ippp;

                if( this.direction === "forward" ){

                    ip = Math.max( this.start, i - this.step );
                    ipp = Math.max( this.start, i - 2 * this.step );
                    ippp = Math.max( this.start, i - 3 * this.step );

                }else{

                    ip = Math.min( this.end, i + this.step );
                    ipp = Math.min( this.end, i + 2 * this.step );
                    ippp = Math.min( this.end, i + 3 * this.step );

                }

                this._interpolate(
                    i, ip, ipp, ippp, 1 / this.interpolateStep, 0
                );

            }else{

                setTimeout( this._animate.bind( this ), this.timeout );

            }

        }else{

            this._running = false;

        }

    },

    _interpolate: function( i, ip, ipp, ippp, d, t ){

        t += d;

        if( t <= 1 ){

            var deltaTime = Math.round( this.timeout * d );

            this.traj.setFrameInterpolated(

                i, ip, ipp, ippp, t, this.interpolateType,

                function(){

                    setTimeout( function(){

                        this._interpolate( i, ip, ipp, ippp, d, t );

                    }.bind( this ), deltaTime );

                }.bind( this )

            );

        }else{

            setTimeout( this._animate.bind( this ), 0 );

        }

    },

    toggle: function(){

        if( this._running ){
            this.pause();
        }else{
            this.play();
        }

    },

    play: function(){

        if( !this._running ){

            if( this.traj.player !== this ){
                this.traj.setPlayer( this );
            }

            var frame = this.traj.currentFrame;

            // snap to the grid implied by this.step division and multiplication
            // thus minimizing cache misses
            var i = Math.ceil( frame / this.step ) * this.step

            // wrap when restarting from the limit (i.e. end or start)
            if( this.direction === "forward" && frame >= this.end ){

                i = this.start;

            }else if( this.direction === "backward" && frame <= this.start ){

                i = this.end;

            }

            this.traj.setFrame( i );

            this._stopFlag = false;
            this._animate();
            this.signals.startedRunning.dispatch();

        }

    },

    pause: function(){

        if( this._running ){
            this._stopFlag = true;
            this.signals.haltedRunning.dispatch();
        }

    },

    stop: function(){

        this.traj.setFrame( this.start );
        this.pause();

    }

};


// File:js/ngl/surface.js

/**
 * @file Surface
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


////////////
// Surface

NGL.Surface = function( name, path, data ){

    this.name = name;
    this.path = path;
    this.info = {};

    this.center = new THREE.Vector3();
    this.boundingBox = new THREE.Box3();

    if( data instanceof THREE.Geometry ||
        data instanceof THREE.BufferGeometry ||
        data instanceof THREE.Group
    ){

        this.fromGeometry( data );

    }else if( data ){

        this.set(
            data.position,
            data.index,
            data.normal,
            data.color,
            data.atomindex
        );

    }

};

NGL.Surface.prototype = {

    constructor: NGL.Surface,

    set: function( position, index, normal, color, atomindex ){

        this.position = position;
        this.index = index;
        this.normal = normal;
        this.color = color;
        this.atomindex = atomindex;

        this.size = position.length / 3;

    },

    fromGeometry: function( geometry ){

        NGL.time( "NGL.GeometrySurface.fromGeometry" );

        var geo;

        if( geometry instanceof THREE.Geometry ){

            geo = geometry;

            // TODO check if needed
            geo.computeFaceNormals( true );
            geo.computeVertexNormals( true );

        }else if( geometry instanceof THREE.BufferGeometry ){

            geo = geometry;

        }else{

            geo = geometry.children[0].geometry;

        }

        // TODO check if needed
        geo.computeBoundingSphere();
        geo.computeBoundingBox();

        this.center.copy( geo.boundingSphere.center );
        this.boundingBox.copy( geo.boundingBox );

        var position, color, index, normal;

        if( geo instanceof THREE.BufferGeometry ){

            var attr = geo.attributes
            var an = attr.normal ? attr.normal.array : false;

            // assume there are no normals if the first is zero
            if( !an || ( an[ 0 ] === 0 && an[ 1 ] === 0 && an[ 2 ] === 0 ) ){
                geo.computeVertexNormals();
            }

            position = attr.position.array;
            index = attr.index ? attr.index.array : null;
            normal = attr.normal.array;

        }else{

            // FIXME
            NGL.log( "TODO non BufferGeometry surface" );

            position = NGL.Utils.positionFromGeometry( geo );
            index = NGL.Utils.indexFromGeometry( geo );
            normal = NGL.Utils.normalFromGeometry( geo );

        }

        this.set( position, index, normal, color, undefined );

        NGL.timeEnd( "NGL.GeometrySurface.setGeometry" );

    },

    getPosition: function(){

        return this.position;

    },

    getColor: function( params ){

        var p = params || {};

        var n = this.size;
        var array;

        if( this.atomindex ){

            p.volume = this;

            var colorMaker = NGL.ColorMakerRegistry.getScheme( p );

            array = new Float32Array( n * 3 );

            var atoms = p.structure.atoms;
            var atomindex = this.atomindex;

            for( var i = 0, a; i < n; ++i ){

                a = atoms[ atomindex[ i ] ];
                colorMaker.atomColorToArray( a, array, i * 3 );

            }

        }else{

            var tc = new THREE.Color( p.value );

            array = NGL.Utils.uniformArray3( n, tc.r, tc.g, tc.b );

        }

        return array;

    },

    getPickingColor: function( params ){

        var p = Object.assign( params || {} );
        p.scheme = "picking";

        return this.getColor( p );

    },

    getNormal: function(){

        return this.normal;

    },

    getSize: function( size ){

        return NGL.Utils.uniformArray( this.size, size );

    },

    getIndex: function(){

        return this.index;

    },

    getFilteredIndex: function( sele, atoms ){

        if( sele && this.atomindex ){

            var selection = new NGL.Selection( sele );
            var filteredIndex = [];

            var atomindex = this.atomindex;
            var index = this.index;
            var n = index.length;
            var test = selection.test;

            for( var i = 0; i < n; i+=3 ){

                var idx1 = index[ i     ];
                var idx2 = index[ i + 1 ];
                var idx3 = index[ i + 2 ];

                var a1 = atoms[ atomindex[ idx1 ] ];
                var a2 = atoms[ atomindex[ idx2 ] ];
                var a3 = atoms[ atomindex[ idx3 ] ];

                if( test( a1 ) && test( a2 ) && test( a3 ) ){

                    filteredIndex.push( idx1 );
                    filteredIndex.push( idx2 );
                    filteredIndex.push( idx3 );

                }

            }

            return new Uint32Array( filteredIndex );

        }else{

            return this.index;

        }

    },

    getAtomindex: function(){

        return this.atomindex;

    },

    toJSON: function(){

        var output = {

            metadata: {
                version: 0.1,
                type: 'Surface',
                generator: 'SurfaceExporter'
            },

            name: this.name,
            path: this.path,
            info: this.info,

            position: this.position,
            index: this.index,
            normal: this.normal,
            color: this.color,
            atomindex: this.atomindex,

            size: this.size,

            center: this.center.toArray(),
            boundingBox: {
                min: this.boundingBox.min.toArray(),
                max: this.boundingBox.max.toArray()
            }

        }

        return output;

    },

    fromJSON: function( input ){

        this.name = input.name;
        this.path = input.path;
        this.info = input.info;

        this.position = input.position;
        this.index = input.index;
        this.normal = input.normal;
        this.color = input.color;
        this.atomindex = input.atomindex;

        this.size = input.size;

        this.center.fromArray( input.center );
        this.boundingBox.set(
            input.boundingBox.min,
            input.boundingBox.max
        );

        return this;

    },

    getTransferable: function(){

        var transferable = [];

        if( this.position ) transferable.push( this.position.buffer );
        if( this.index ) transferable.push( this.index.buffer );
        if( this.normal ) transferable.push( this.normal.buffer );
        if( this.color ) transferable.push( this.color.buffer );
        if( this.atomindex ) transferable.push( this.atomindex.buffer );

        return transferable;

    },

    dispose: function(){

        //

    }

};


/////////
// Grid

NGL.Grid = function( length, width, height, dataCtor, elemSize ){

    dataCtor = dataCtor || Int32Array;
    elemSize = elemSize || 1;

    var j;

    var data = new dataCtor( length * width * height * elemSize );

    function index( x, y, z ){

        return ( ( ( ( x * width ) + y ) * height ) + z ) * elemSize;

    }

    this.data = data;

    this.index = index;

    this.set = function( x, y, z ){

        var i = index( x, y, z );

        for( j = 0; j < elemSize; ++j ){
            data[ i + j ] = arguments[ 3 + j ];
        }

    };

    this.toArray = function( x, y, z, array, offset ){

        var i = index( x, y, z );

        if ( array === undefined ) array = [];
        if ( offset === undefined ) offset = 0;

        for( j = 0; j < elemSize; ++j ){
            array[ j ] = data[ i + j ];
        }

    };

    this.fromArray = function( x, y, z, array, offset ){

        var i = index( x, y, z );

        if ( offset === undefined ) offset = 0;

        for( j = 0; j < elemSize; ++j ){
            data[ i + j ] = array[ offset + j ];
        }

    };

    this.copy = function( grid ){

        this.data.set( grid.data );

    };

    this.clone = function(){

        return new NGL.Grid(

            length, width, height, dataCtor, elemSize

        ).copy( this );

    };

};


///////////
// Volume

NGL.WorkerRegistry.add( "surf", function( e, callback ){

    NGL.time( "WORKER surf" );

    if( self.vol === undefined ) self.vol = new NGL.Volume();

    var vol = self.vol;
    var d = e.data;
    var p = d.params;

    if( d.vol ) vol.fromJSON( d.vol );

    if( p ){
        var surface = vol.getSurface(
            p.isolevel, p.smooth, p.center, p.size
        );
    }

    NGL.timeEnd( "WORKER surf" );

    if( p ){
        callback( surface.toJSON(), surface.getTransferable() );
    }else{
        callback();
    }

} );


NGL.Volume = function( name, path, data, nx, ny, nz, dataAtomindex ){

    this.name = name;
    this.path = path;

    this.matrix = new THREE.Matrix4();
    this.normalMatrix = new THREE.Matrix3();
    this.inverseMatrix = new THREE.Matrix4();
    this.center = new THREE.Vector3();
    this.boundingBox = new THREE.Box3();

    this.setData( data, nx, ny, nz, dataAtomindex );

    if( this.__data.length <= Math.pow( 10, 7 ) ){
        NGL.GidPool.addObject( this );
    }

};

NGL.Volume.prototype = {

    constructor: NGL.Volume,

    setData: function( data, nx, ny, nz, dataAtomindex ){

        this.nx = nx || 1;
        this.ny = ny || 1;
        this.nz = nz || 1;

        this.data = data || new Float32Array( 1 );
        this.__data = this.data;

        this.setDataAtomindex( dataAtomindex );

        delete this.mc;

        delete this.__isolevel;
        delete this.__smooth;
        delete this.__minValue;
        delete this.__maxValue;

        delete this.__dataPositionBuffer;
        delete this.__dataPosition;
        delete this.__dataBuffer;

        delete this.__dataMin;
        delete this.__dataMax;
        delete this.__dataMean;
        delete this.__dataRms;

        if( this.worker ) this.worker.terminate();

        if( this.__data.length <= Math.pow( 10, 7 ) ){
            NGL.GidPool.updateObject( this, true );
        }else{
            NGL.warn( "Volume too large (>10^7), not adding to GidPool" );
            NGL.GidPool.removeObject( this );
        }

    },

    setMatrix: function( matrix ){

        this.matrix.copy( matrix );

        var bb = this.boundingBox;
        var v = this.center;  // temporary re-purposing

        var x = this.nx - 1;
        var y = this.ny - 1;
        var z = this.nz - 1;

        bb.makeEmpty();

        bb.expandByPoint( v.set( x, y, z ) );
        bb.expandByPoint( v.set( x, y, 0 ) );
        bb.expandByPoint( v.set( x, 0, z ) );
        bb.expandByPoint( v.set( x, 0, 0 ) );
        bb.expandByPoint( v.set( 0, y, z ) );
        bb.expandByPoint( v.set( 0, 0, z ) );
        bb.expandByPoint( v.set( 0, y, 0 ) );
        bb.expandByPoint( v.set( 0, 0, 0 ) );

        bb.applyMatrix4( this.matrix );
        bb.center( this.center );

        // make normal matrix

        var me = this.matrix.elements;
        var r0 = new THREE.Vector3( me[0], me[1], me[2] );
        var r1 = new THREE.Vector3( me[4], me[5], me[6] );
        var r2 = new THREE.Vector3( me[8], me[9], me[10] );
        var cp = new THREE.Vector3();
        //        [ r0 ]       [ r1 x r2 ]
        // M3x3 = [ r1 ]   N = [ r2 x r0 ]
        //        [ r2 ]       [ r0 x r1 ]
        var ne = this.normalMatrix.elements;
        cp.crossVectors( r1, r2 );
        ne[ 0 ] = cp.x;
        ne[ 1 ] = cp.y;
        ne[ 2 ] = cp.z;
        cp.crossVectors( r2, r0 );
        ne[ 3 ] = cp.x;
        ne[ 4 ] = cp.y;
        ne[ 5 ] = cp.z;
        cp.crossVectors( r0, r1 );
        ne[ 6 ] = cp.x;
        ne[ 7 ] = cp.y;
        ne[ 8 ] = cp.z;

        this.inverseMatrix.getInverse( this.matrix );

    },

    setDataAtomindex: function( dataAtomindex ){

        this.dataAtomindex = dataAtomindex;
        this.__dataAtomindex = this.dataAtomindex;

        delete this.__dataAtomindexBuffer;

    },

    getBox: function( center, size, target ){

        if( !target ) target = new THREE.Box3();

        target.set( center, center );
        target.expandByScalar( size );
        target.applyMatrix4( this.inverseMatrix );

        target.min.round();
        target.max.round();

        return target;

    },

    getSurface: function( isolevel, smooth, center, size ){

        isolevel = isNaN( isolevel ) ? this.getValueForSigma( 2 ) : isolevel;
        smooth = smooth || 0;
        center = center;
        size = size;

        //

        if( this.mc === undefined ){

            this.mc = new NGL.MarchingCubes2(
                this.__data, this.nx, this.ny, this.nz, this.__dataAtomindex
            );

        }

        var box;

        if( center && size ){

            if( !this.__box ) this.__box = new THREE.Box3();
            box = this.__box;
            this.getBox( center, size, box );

        }

        var sd;

        if( smooth ){

            sd = this.mc.triangulate( isolevel, true, box );
            NGL.laplacianSmooth( sd.position, sd.index, smooth, true );

            var bg = new THREE.BufferGeometry();
            bg.addAttribute( "position", new THREE.BufferAttribute( sd.position, 3 ) );
            bg.addIndex( new THREE.BufferAttribute( sd.index, 1 ) );
            bg.computeVertexNormals();
            sd.normal = bg.attributes.normal.array;
            bg.dispose();

        }else{

            sd = this.mc.triangulate( isolevel, false, box );

        }

        this.matrix.applyToVector3Array( sd.position );

        if( sd.normal ){

            this.normalMatrix.applyToVector3Array( sd.normal );

        }

        var surface = new NGL.Surface( "", "", sd );
        surface.info[ "isolevel" ] = isolevel;
        surface.info[ "smooth" ] = smooth;

        return surface;

    },

    getSurfaceWorker: function( isolevel, smooth, center, size, callback ){

        isolevel = isNaN( isolevel ) ? this.getValueForSigma( 2 ) : isolevel;
        smooth = smooth || 0;

        //

        if( NGL.useWorker && typeof Worker !== "undefined" &&
            typeof importScripts !== 'function'
        ){

            if( this.workerPool === undefined ){
                this.workerPool = new NGL.WorkerPool( "surf", 2 );
            }

            var worker = this.workerPool.getNextWorker();

            worker.post(

                {
                    vol: worker.postCount === 0 ? this.toJSON() : null,
                    params: {
                        isolevel: isolevel,
                        smooth: smooth,
                        center: center,
                        size: size
                    }
                },

                undefined,

                function( e ){

                    var surface = NGL.fromJSON( e.data );
                    callback( surface );

                },

                function( e ){

                    console.warn(
                        "NGL.Volume.generateSurfaceWorker error - trying without worker", e
                    );

                    var surface = this.getSurface( isolevel, smooth, center, size );
                    callback( surface );

                }.bind( this )

            );

        }else{

            var surface = this.getSurface( isolevel, smooth, center, size );
            callback( surface );

        }

    },

    getValueForSigma: function( sigma ){

        sigma = sigma !== undefined ? sigma : 2;

        return this.getDataMean() + sigma * this.getDataRms();

    },

    getSigmaForValue: function( value ){

        value = value !== undefined ? value : 0;

        return ( value - this.getDataMean() ) / this.getDataRms();

    },

    filterData: function( minValue, maxValue, outside ){

        if( isNaN( minValue ) && this.header ){
            minValue = this.header.DMEAN + 2.0 * this.header.ARMS;
        }

        minValue = ( minValue !== undefined && !isNaN( minValue ) ) ? minValue : -Infinity;
        maxValue = maxValue !== undefined ? maxValue : Infinity;
        outside = outside || false;

        if( !this.dataPosition ){

            this.makeDataPosition();

        }

        var dataPosition = this.__dataPosition;
        var data = this.__data;

        if( minValue === this.__minValue && maxValue == this.__maxValue &&
            outside === this.__outside
        ){

            // already filtered
            return;

        }else if( minValue === -Infinity && maxValue === Infinity ){

            this.dataPosition = dataPosition;
            this.data = data;

        }else{

            var n = data.length;

            if( !this.__dataBuffer ){

                // ArrayBuffer for re-use as Float32Array backend

                this.__dataPositionBuffer = new ArrayBuffer( n * 3 * 4 );
                this.__dataBuffer = new ArrayBuffer( n * 4 );

            }

            var filteredDataPosition = new Float32Array( this.__dataPositionBuffer );
            var filteredData = new Float32Array( this.__dataBuffer );

            var j = 0;

            for( var i = 0; i < n; ++i ){

                var i3 = i * 3;
                var v = data[ i ];

                if( ( !outside && v >= minValue && v <= maxValue ) ||
                    ( outside && ( v < minValue || v > maxValue ) )
                ){

                    var j3 = j * 3;

                    filteredDataPosition[ j3 + 0 ] = dataPosition[ i3 + 0 ];
                    filteredDataPosition[ j3 + 1 ] = dataPosition[ i3 + 1 ];
                    filteredDataPosition[ j3 + 2 ] = dataPosition[ i3 + 2 ];

                    filteredData[ j ] = v;

                    j += 1;

                }

            }

            // set views

            this.dataPosition = new Float32Array( this.__dataPositionBuffer, 0, j * 3 );
            this.data = new Float32Array( this.__dataBuffer, 0, j );

        }

        this.__minValue = minValue;
        this.__maxValue = maxValue;
        this.__outside = outside;

    },

    makeDataPosition: function(){

        var nz = this.nz;
        var ny = this.ny;
        var nx = this.nx;

        var position = new Float32Array( nx * ny * nz * 3 );

        var p = 0;

        for( var z = 0; z < nz; ++z ){

            for( var y = 0; y < ny; ++y ){

                for( var x = 0; x < nx; ++x ){

                    position[ p + 0 ] = x;
                    position[ p + 1 ] = y;
                    position[ p + 2 ] = z;

                    p += 3;

                }

            }

        }

        this.matrix.applyToVector3Array( position );

        this.dataPosition = position;
        this.__dataPosition = position;

    },

    getDataAtomindex: function(){

        return this.dataAtomindex;

    },

    getDataPosition: function(){

        return this.dataPosition;

    },

    getDataColor: function( params ){

        var p = params || {};
        p.volume = this;
        p.scale = p.scale || 'Spectral';
        p.domain = p.domain || [ this.getDataMin(), this.getDataMax() ];

        var colorMaker = NGL.ColorMakerRegistry.getScheme( p );

        var n = this.dataPosition.length / 3;
        var array = new Float32Array( n * 3 );

        // var atoms = p.structure.atoms;
        // var atomindex = this.dataAtomindex;

        for( var i = 0; i < n; ++i ){

            colorMaker.volumeColorToArray( i, array, i * 3 );

            // a = atoms[ atomindex[ i ] ];
            // if( a ) colorMaker.atomColorToArray( a, array, i * 3 );

        }

        return array;

    },

    getPickingDataColor: function( params ){

        var p = Object.assign( params || {} );
        p.scheme = "picking";

        return this.getDataColor( p );

    },

    getDataSize: function( size, scale ){

        var n = this.dataPosition.length / 3;
        var array;

        switch( size ){

            case "value":

                array = new Float32Array( this.data );
                break;

            case "abs-value":

                array = new Float32Array( this.data );
                for( var i = 0; i < n; ++i ){
                    array[ i ] = Math.abs( array[ i ] );
                }
                break;

            case "value-min":

                array = new Float32Array( this.data );
                var min = this.getDataMin();
                for( var i = 0; i < n; ++i ){
                    array[ i ] -= min;
                }
                break;

            case "deviation":

                array = new Float32Array( this.data );
                break;

            default:

                array = NGL.Utils.uniformArray( n, size );
                break;

        }

        if( scale !== 1.0 ){

            for( var i = 0; i < n; ++i ){
                array[ i ] *= scale;
            }

        }

        return array;

    },

    getDataMin: function(){

        if( this.__dataMin === undefined ){

            var data = this.__data;
            var n = data.length;
            var min = Infinity;

            for( var i = 0; i < n; ++i ){
                min = Math.min( min, data[ i ] );
            }

            this.__dataMin = min;

        }

        return this.__dataMin;

    },

    getDataMax: function(){

        if( this.__dataMax === undefined ){

            var data = this.__data;
            var n = data.length;
            var max = -Infinity;

            for( var i = 0; i < n; ++i ){
                max = Math.max( max, data[ i ] );
            }

            this.__dataMax = max;

        }

        return this.__dataMax;

    },

    getDataMean: function(){

        if( this.__dataMean === undefined ){

            var data = this.__data;
            var n = data.length;
            var sum = 0;

            for( var i = 0; i < n; ++i ){
                sum += data[ i ];
            }

            this.__dataMean = sum / n;

        }

        return this.__dataMean;

    },

    getDataRms: function(){

        if( this.__dataRms === undefined ){

            var data = this.__data;
            var n = data.length;
            var sumSq = 0;
            var di, i;

            for( i = 0; i < n; ++i ){
                di = data[ i ];
                sumSq += di * di;
            }

            this.__dataRms = Math.sqrt( sumSq / n );

        }

        return this.__dataRms;

    },

    clone: function(){

        var vol = new NGL.Volume(

            this.name,
            this.path,

            this.__data,

            this.nx,
            this.ny,
            this.nz,

            this.__dataAtomindex

        );

        vol.matrix.copy( this.matrix );

        if( this.header ){

            vol.header = Object.assign( {}, this.header );

        }

        return vol;

    },

    toJSON: function(){

        var output = {

            metadata: {
                version: 0.1,
                type: 'Volume',
                generator: 'VolumeExporter'
            },

            name: this.name,
            path: this.path,

            data: this.__data,

            nx: this.nx,
            ny: this.ny,
            nz: this.nz,

            dataAtomindex: this.__dataAtomindex,

            matrix: this.matrix.toArray(),
            normalMatrix: this.normalMatrix.toArray(),
            inverseMatrix: this.inverseMatrix.toArray(),

            center: this.center.toArray(),
            boundingBox: {
                min: this.boundingBox.min.toArray(),
                max: this.boundingBox.max.toArray()
            }

        }

        if( this.header ){

            output.header = Object.assign( {}, this.header );

        }

        return output;

    },

    fromJSON: function( input ){

        this.name = input.name;
        this.path = input.path;

        this.setData(

            input.data,

            input.nx,
            input.ny,
            input.nz,

            input.dataAtomindex

        );

        this.matrix.fromArray( input.matrix );
        this.normalMatrix.fromArray( input.normalMatrix );
        this.inverseMatrix.fromArray( input.inverseMatrix );

        if( input.header ){

            this.header = Object.assign( {}, input.header );

        }

        this.center.fromArray( input.center );
        this.boundingBox.set(
            input.boundingBox.min,
            input.boundingBox.max
        );

        return this;

    },

    getTransferable: function(){

        var transferable = [

            this.__data.buffer

        ];

        if( this.__dataAtomindex ){
            transferable.push( this.__dataAtomindex.buffer );
        }

        return transferable;

    },

    dispose: function(){

        if( this.workerPool ) this.workerPool.terminate();

        NGL.GidPool.removeObject( this );

    }

};


///////////////////
// Marching cubes

NGL.MarchingCubes = function( data, nx, ny, nz, isolevel ){

    // The MIT License (MIT) Copyright (c) 2012-2013 Mikola Lysenko
    // http://0fps.net/2012/07/12/smooth-voxel-terrain-part-2/
    //
    // Based on Paul Bourke's classic implementation:
    // http://paulbourke.net/geometry/polygonise/
    // JS port by Mikola Lysenko
    //
    // Adapted for NGL by Alexander Rose

    NGL.time( "NGL.MarchingCubes" );

    var dims = new Int32Array( [ nx, ny, nz ] );

    var edgeTable = NGL.MarchingCubes.edgeTable;
    var triTable = NGL.MarchingCubes.triTable;
    var cubeVerts = NGL.MarchingCubes.cubeVerts;
    var edgeIndex = NGL.MarchingCubes.edgeIndex;

    var vertices = [];
    var faces = [];
    var vc3 = 0;  // vertexCount * 3
    var fc3 = 0;  // faceCount * 3

    var n = 0;
    var grid = new Float32Array( 8 );
    var edges = new Int32Array( 12 );
    var x = new Int32Array( 3 );

    // March over the volume

    for( x[2]=0; x[2] < dims[2]-1; ++x[2], n+=dims[0] ){

        for( x[1]=0; x[1] < dims[1]-1; ++x[1], ++n){

            for( x[0]=0; x[0] < dims[0]-1; ++x[0], ++n) {

                // For each cell, compute cube mask

                var cubeIndex = 0;

                for( var i=0; i<8; ++i ){

                    var v = cubeVerts[ i ]
                    var k = n + v[0] + dims[0] * ( v[1] + dims[1] * v[2] );
                    var s = data[ k ] - isolevel;

                    grid[ i ] = s;
                    cubeIndex |= ( s > 0 ) ? 1 << i : 0;

                }

                // Compute vertices

                var edgeMask = edgeTable[ cubeIndex ];

                if( edgeMask === 0 ) {
                    continue;
                }

                for( var i=0; i<12; ++i ){

                    if( ( edgeMask & ( 1 << i ) ) === 0 ){
                        continue;
                    }

                    edges[ i ] = vc3 / 3;

                    var e = edgeIndex[ i ];
                    var p0 = cubeVerts[ e[ 0 ] ];
                    var p1 = cubeVerts[ e[ 1 ] ];
                    var a = grid[ e[ 0 ] ];
                    var b = grid[ e[ 1 ] ];
                    var d = a - b;
                    var t = 0;

                    if( Math.abs( d ) > 1e-6 ){
                        t = a / d;
                    }

                    vertices[ vc3 + 0 ] = ( x[0] + p0[0] ) + t * ( p1[0] - p0[0] );
                    vertices[ vc3 + 1 ] = ( x[1] + p0[1] ) + t * ( p1[1] - p0[1] );
                    vertices[ vc3 + 2 ] = ( x[2] + p0[2] ) + t * ( p1[2] - p0[2] );

                    vc3 += 3;

                }

                // Add faces

                var f = triTable[ cubeIndex ];

                for( var i=0; i<f.length; i += 3 ){

                    faces[ fc3 + 0 ] = edges[ f[ i + 0 ] ];
                    faces[ fc3 + 1 ] = edges[ f[ i + 1 ] ];
                    faces[ fc3 + 2 ] = edges[ f[ i + 2 ] ];

                    fc3 += 3;

                }

            }

        }

    }

    NGL.timeEnd( "NGL.MarchingCubes" );

    return {
        position: new Float32Array( vertices ),
        normal: undefined,
        index: new Uint32Array( faces )
    };

};

NGL.MarchingCubes2 = function( field, nx, ny, nz, atomindex ){

    // Based on alteredq / http://alteredqualia.com/
    // port of greggman's ThreeD version of marching cubes to Three.js
    // http://webglsamples.googlecode.com/hg/blob/blob.html
    //
    // Adapted for NGL by Alexander Rose

    var edgeTable = NGL.MarchingCubes.edgeTable;
    var triTable = NGL.MarchingCubes.triTable2;

    var isolevel = 0;
    var noNormals = false;
    var center = undefined;
    var size = Infinity;

    var n = nx * ny * nz;

    // deltas
    var yd = nx;
    var zd = nx * ny;

    var normalCache, vertexIndex;
    var count, icount;

    var ilist = new Int32Array( 12 );

    var positionArray = [];
    var normalArray = [];
    var indexArray = [];
    var atomindexArray = [];

    //

    this.triangulate = function( _isolevel, _noNormals, _box ){

        NGL.time( "NGL.MarchingCubes2.triangulate" );

        isolevel = _isolevel;
        noNormals = _noNormals;

        if( !noNormals && !normalCache ){
            normalCache = new Float32Array( n * 3 );
        }

        if( !vertexIndex ){
            vertexIndex = new Int32Array( n );
        }

        count = 0;
        icount = 0;

        if( _box !== undefined ){

            _box.min.round();
            _box.max.round();
            triangulate(
                _box.min.x, _box.min.y, _box.min.z,
                _box.max.x, _box.max.y, _box.max.z
            );

        }else{

            triangulate();

        }

        positionArray.length = count * 3;
        if( !noNormals ) normalArray.length = count * 3;
        indexArray.length = icount;
        if( atomindex ) atomindexArray.length = count;

        NGL.timeEnd( "NGL.MarchingCubes2.triangulate" );

        return {
            position: new Float32Array( positionArray ),
            normal: noNormals ? undefined : new Float32Array( normalArray ),
            index: new Uint32Array( indexArray ),
            atomindex: atomindex ? new Int32Array( atomindexArray ) : undefined,
        };

    }

    // polygonization

    function lerp( a, b, t ) { return a + ( b - a ) * t; }

    function VIntX( q, offset, x, y, z, valp1, valp2 ) {

        if( vertexIndex[ q ] < 0 ){

            var mu = ( isolevel - valp1 ) / ( valp2 - valp1 );
            var nc = normalCache;

            var c = count * 3;

            positionArray[ c + 0 ] = x + mu;
            positionArray[ c + 1 ] = y;
            positionArray[ c + 2 ] = z;

            if( !noNormals ){

                var q3 = q * 3;

                normalArray[ c ]     = -lerp( nc[ q3 ],     nc[ q3 + 3 ], mu );
                normalArray[ c + 1 ] = -lerp( nc[ q3 + 1 ], nc[ q3 + 4 ], mu );
                normalArray[ c + 2 ] = -lerp( nc[ q3 + 2 ], nc[ q3 + 5 ], mu );

            }

            if( atomindex ) atomindexArray[ count ] = atomindex[ q + mu ];

            vertexIndex[ q ] = count;
            ilist[ offset ] = count;

            count += 1;

        }else{

            ilist[ offset ] = vertexIndex[ q ];

        }

    }

    function VIntY( q, offset, x, y, z, valp1, valp2 ) {

        if( vertexIndex[ q ] < 0 ){

            var mu = ( isolevel - valp1 ) / ( valp2 - valp1 );
            var nc = normalCache;

            var c = count * 3;

            positionArray[ c ]     = x;
            positionArray[ c + 1 ] = y + mu;
            positionArray[ c + 2 ] = z;

            if( !noNormals ){

                var q3 = q * 3;
                var q6 = q3 + yd * 3;

                normalArray[ c ]     = -lerp( nc[ q3 ],     nc[ q6 ],     mu );
                normalArray[ c + 1 ] = -lerp( nc[ q3 + 1 ], nc[ q6 + 1 ], mu );
                normalArray[ c + 2 ] = -lerp( nc[ q3 + 2 ], nc[ q6 + 2 ], mu );

            }

            if( atomindex ) atomindexArray[ count ] = atomindex[ q + mu * yd ];

            vertexIndex[ q ] = count;
            ilist[ offset ] = count;

            count += 1;

        }else{

            ilist[ offset ] = vertexIndex[ q ];

        }

    }

    function VIntZ( q, offset, x, y, z, valp1, valp2 ) {

        if( vertexIndex[ q ] < 0 ){

            var mu = ( isolevel - valp1 ) / ( valp2 - valp1 );
            var nc = normalCache;

            var c = count * 3;

            positionArray[ c ]     = x;
            positionArray[ c + 1 ] = y;
            positionArray[ c + 2 ] = z + mu;

            if( !noNormals ){

                var q3 = q * 3;
                var q6 = q3 + zd * 3;

                normalArray[ c ]     = -lerp( nc[ q3 ],     nc[ q6 ],     mu );
                normalArray[ c + 1 ] = -lerp( nc[ q3 + 1 ], nc[ q6 + 1 ], mu );
                normalArray[ c + 2 ] = -lerp( nc[ q3 + 2 ], nc[ q6 + 2 ], mu );

            }

            if( atomindex ) atomindexArray[ count ] = atomindex[ q + mu * zd ];

            vertexIndex[ q ] = count;
            ilist[ offset ] = count;

            count += 1;

        }else{

            ilist[ offset ] = vertexIndex[ q ];

        }

    }

    function compNorm( q ) {

        var q3 = q * 3;

        if ( normalCache[ q3 ] === 0.0 ) {

            normalCache[ q3     ] = field[ q - 1  ] - field[ q + 1 ];
            normalCache[ q3 + 1 ] = field[ q - yd ] - field[ q + yd ];
            normalCache[ q3 + 2 ] = field[ q - zd ] - field[ q + zd ];

        }

    }

    function polygonize( fx, fy, fz, q ) {

        // cache indices
        var q1 = q + 1,
            qy = q + yd,
            qz = q + zd,
            q1y = q1 + yd,
            q1z = q1 + zd,
            qyz = q + yd + zd,
            q1yz = q1 + yd + zd;

        var cubeindex = 0,
            field0 = field[ q ],
            field1 = field[ q1 ],
            field2 = field[ qy ],
            field3 = field[ q1y ],
            field4 = field[ qz ],
            field5 = field[ q1z ],
            field6 = field[ qyz ],
            field7 = field[ q1yz ];

        if ( field0 < isolevel ) cubeindex |= 1;
        if ( field1 < isolevel ) cubeindex |= 2;
        if ( field2 < isolevel ) cubeindex |= 8;
        if ( field3 < isolevel ) cubeindex |= 4;
        if ( field4 < isolevel ) cubeindex |= 16;
        if ( field5 < isolevel ) cubeindex |= 32;
        if ( field6 < isolevel ) cubeindex |= 128;
        if ( field7 < isolevel ) cubeindex |= 64;

        // if cube is entirely in/out of the surface - bail, nothing to draw

        var bits = edgeTable[ cubeindex ];
        if ( bits === 0 ) return 0;

        var fx2 = fx + 1,
            fy2 = fy + 1,
            fz2 = fz + 1;

        // top of the cube

        if ( bits & 1 ) {

            if( !noNormals ){
                compNorm( q );
                compNorm( q1 );
            }
            VIntX( q, 0, fx, fy, fz, field0, field1 );

        };

        if ( bits & 2 ) {

            if( !noNormals ){
                compNorm( q1 );
                compNorm( q1y );
            }
            VIntY( q1, 1, fx2, fy, fz, field1, field3 );

        };

        if ( bits & 4 ) {

            if( !noNormals ){
                compNorm( qy );
                compNorm( q1y );
            }
            VIntX( qy, 2, fx, fy2, fz, field2, field3 );

        };

        if ( bits & 8 ) {

            if( !noNormals ){
                compNorm( q );
                compNorm( qy );
            }
            VIntY( q, 3, fx, fy, fz, field0, field2 );

        };

        // bottom of the cube

        if ( bits & 16 ) {

            if( !noNormals ){
                compNorm( qz );
                compNorm( q1z );
            }
            VIntX( qz, 4, fx, fy, fz2, field4, field5 );

        };

        if ( bits & 32 ) {

            if( !noNormals ){
                compNorm( q1z );
                compNorm( q1yz );
            }
            VIntY( q1z, 5, fx2, fy, fz2, field5, field7 );

        };

        if ( bits & 64 ) {

            if( !noNormals ){
                compNorm( qyz );
                compNorm( q1yz );
            }
            VIntX( qyz, 6, fx, fy2, fz2, field6, field7 );

        };

        if ( bits & 128 ) {

            if( !noNormals ){
                compNorm( qz );
                compNorm( qyz );
            }
            VIntY( qz, 7, fx, fy, fz2, field4, field6 );

        };

        // vertical lines of the cube

        if ( bits & 256 ) {

            if( !noNormals ){
                compNorm( q );
                compNorm( qz );
            }
            VIntZ( q, 8, fx, fy, fz, field0, field4 );

        };

        if ( bits & 512 ) {

            if( !noNormals ){
                compNorm( q1 );
                compNorm( q1z );
            }
            VIntZ( q1, 9, fx2, fy, fz, field1, field5 );

        };

        if ( bits & 1024 ) {

            if( !noNormals ){
                compNorm( q1y );
                compNorm( q1yz );
            }
            VIntZ( q1y, 10, fx2, fy2, fz, field3, field7 );

        };

        if ( bits & 2048 ) {

            if( !noNormals ){
                compNorm( qy );
                compNorm( qyz );
            }
            VIntZ( qy, 11, fx, fy2, fz, field2, field6 );

        };

        cubeindex <<= 4;  // re-purpose cubeindex into an offset into triTable

        var o1, o2, o3, i = 0;

        // here is where triangles are created

        while ( triTable[ cubeindex + i ] != -1 ) {

            o1 = cubeindex + i;
            o2 = o1 + 1;
            o3 = o1 + 2;

            // FIXME normals flipping (see above) and vertex order reversal
            indexArray[ icount ]     = ilist[ triTable[ o2 ] ];
            indexArray[ icount + 1 ] = ilist[ triTable[ o1 ] ];
            indexArray[ icount + 2 ] = ilist[ triTable[ o3 ] ];

            icount += 3;
            i += 3;

        }

    }

    function triangulate( xBeg, yBeg, zBeg, xEnd, yEnd, zEnd ) {

        var q, x, y, z, fx, fy, fz, y_offset, z_offset

        xBeg = xBeg !== undefined ? xBeg : 0;
        yBeg = yBeg !== undefined ? yBeg : 0;
        zBeg = zBeg !== undefined ? zBeg : 0;

        xEnd = xEnd !== undefined ? xEnd : nx - 1;
        yEnd = yEnd !== undefined ? yEnd : ny - 1;
        zEnd = zEnd !== undefined ? zEnd : nz - 1;

        if( noNormals ){

            xBeg = Math.max( 0, xBeg );
            yBeg = Math.max( 0, yBeg );
            zBeg = Math.max( 0, zBeg );

            xEnd = Math.min( nx - 1, xEnd );
            yEnd = Math.min( ny - 1, yEnd );
            zEnd = Math.min( nz - 1, zEnd );

        }else{

            xBeg = Math.max( 1, xBeg );
            yBeg = Math.max( 1, yBeg );
            zBeg = Math.max( 1, zBeg );

            xEnd = Math.min( nx - 2, xEnd );
            yEnd = Math.min( ny - 2, yEnd );
            zEnd = Math.min( nz - 2, zEnd );

        }

        // init part of the vertexIndex
        // (takes a significant amount of time to do for all)

        var xBeg2 = Math.max( 0, xBeg - 2);
        var yBeg2 = Math.max( 0, yBeg - 2 );
        var zBeg2 = Math.max( 0, zBeg - 2 );

        var xEnd2 = Math.min( nx, xEnd + 2 );
        var yEnd2 = Math.min( ny, yEnd + 2 );
        var zEnd2 = Math.min( nz, zEnd + 2 );

        for ( z = zBeg2; z < zEnd2; ++z ) {
            z_offset = zd * z;
            for ( y = yBeg2; y < yEnd2; ++y ) {
                y_offset = z_offset + yd * y;
                for ( x = xBeg2; x < xEnd2; ++x ) {
                    q = y_offset + x;
                    vertexIndex[ q ] = -1;
                }
            }
        }

        // clip space where the isovalue is too low

        var __break;
        var __xBeg = xBeg; var __yBeg = yBeg; var __zBeg = zBeg;
        var __xEnd = xEnd; var __yEnd = yEnd; var __zEnd = zEnd;

        __break = false;
        for ( z = zBeg; z < zEnd; ++z ) {
            for ( y = yBeg; y < yEnd; ++y ) {
                for ( x = xBeg; x < xEnd; ++x ) {
                    q = ( ( nx * ny ) * z ) + ( nx * y ) + x;
                    if( field[ q ] >= isolevel ){
                        __zBeg = z;
                        __break = true;
                        break;
                    }
                }
                if( __break ) break;
            }
            if( __break ) break;
        }

        __break = false;
        for ( y = yBeg; y < yEnd; ++y ) {
            for ( z = __zBeg; z < zEnd; ++z ) {
                for ( x = xBeg; x < xEnd; ++x ) {
                    q = ( ( nx * ny ) * z ) + ( nx * y ) + x;
                    if( field[ q ] >= isolevel ){
                        __yBeg = y;
                        __break = true;
                        break;
                    }
                }
                if( __break ) break;
            }
            if( __break ) break;
        }

        __break = false;
        for ( x = xBeg; x < xEnd; ++x ) {
            for ( y = __yBeg; y < yEnd; ++y ) {
                for ( z = __zBeg; z < zEnd; ++z ) {
                    q = ( ( nx * ny ) * z ) + ( nx * y ) + x;
                    if( field[ q ] >= isolevel ){
                        __xBeg = x;
                        __break = true;
                        break;
                    }
                }
                if( __break ) break;
            }
            if( __break ) break;
        }

        __break = false;
        for ( z = zEnd; z >= zBeg; --z ) {
            for ( y = yEnd; y >= yBeg; --y ) {
                for ( x = xEnd; x >= xBeg; --x ) {
                    q = ( ( nx * ny ) * z ) + ( nx * y ) + x;
                    if( field[ q ] >= isolevel ){
                        __zEnd = z;
                        __break = true;
                        break;
                    }
                }
                if( __break ) break;
            }
            if( __break ) break;
        }

        __break = false;
        for ( y = yEnd; y >= yBeg; --y ) {
            for ( z = __zEnd; z >= zBeg; --z ) {
                for ( x = xEnd; x >= xBeg; --x ) {
                    q = ( ( nx * ny ) * z ) + ( nx * y ) + x;
                    if( field[ q ] >= isolevel ){
                        __yEnd = y;
                        __break = true;
                        break;
                    }
                }
                if( __break ) break;
            }
            if( __break ) break;
        }

        __break = false;
        for ( x = xEnd; x >= xBeg; --x ) {
            for ( y = __yEnd; y >= yBeg; --y ) {
                for ( z = __zEnd; z >= zBeg; --z ) {
                    q = ( ( nx * ny ) * z ) + ( nx * y ) + x;
                    if( field[ q ] >= isolevel ){
                        __xEnd = x;
                        __break = true;
                        break;
                    }
                }
                if( __break ) break;
            }
            if( __break ) break;
        }

        //

        if( noNormals ){

            xBeg = Math.max( 0, __xBeg - 1);
            yBeg = Math.max( 0, __yBeg - 1 );
            zBeg = Math.max( 0, __zBeg - 1 );

            xEnd = Math.min( nx - 1, __xEnd + 1 );
            yEnd = Math.min( ny - 1, __yEnd + 1 );
            zEnd = Math.min( nz - 1, __zEnd + 1 );

        }else{

            xBeg = Math.max( 1, __xBeg - 1 );
            yBeg = Math.max( 1, __yBeg - 1 );
            zBeg = Math.max( 1, __zBeg - 1 );

            xEnd = Math.min( nx - 2, __xEnd + 1 );
            yEnd = Math.min( ny - 2, __yEnd + 1 );
            zEnd = Math.min( nz - 2, __zEnd + 1 );

        }

        // polygonize part of the grid

        for ( z = zBeg; z < zEnd; ++z ) {
            z_offset = zd * z;
            for ( y = yBeg; y < yEnd; ++y ) {
                y_offset = z_offset + yd * y;
                for ( x = xBeg; x < xEnd; ++x ) {
                    q = y_offset + x;
                    polygonize( x, y, z, q );
                }
            }
        }

    }

};

NGL.MarchingCubes.edgeTable = new Uint32Array( [
    0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
] );

NGL.MarchingCubes.triTable = [
    [],
    [0, 8, 3],
    [0, 1, 9],
    [1, 8, 3, 9, 8, 1],
    [1, 2, 10],
    [0, 8, 3, 1, 2, 10],
    [9, 2, 10, 0, 2, 9],
    [2, 8, 3, 2, 10, 8, 10, 9, 8],
    [3, 11, 2],
    [0, 11, 2, 8, 11, 0],
    [1, 9, 0, 2, 3, 11],
    [1, 11, 2, 1, 9, 11, 9, 8, 11],
    [3, 10, 1, 11, 10, 3],
    [0, 10, 1, 0, 8, 10, 8, 11, 10],
    [3, 9, 0, 3, 11, 9, 11, 10, 9],
    [9, 8, 10, 10, 8, 11],
    [4, 7, 8],
    [4, 3, 0, 7, 3, 4],
    [0, 1, 9, 8, 4, 7],
    [4, 1, 9, 4, 7, 1, 7, 3, 1],
    [1, 2, 10, 8, 4, 7],
    [3, 4, 7, 3, 0, 4, 1, 2, 10],
    [9, 2, 10, 9, 0, 2, 8, 4, 7],
    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],
    [8, 4, 7, 3, 11, 2],
    [11, 4, 7, 11, 2, 4, 2, 0, 4],
    [9, 0, 1, 8, 4, 7, 2, 3, 11],
    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],
    [3, 10, 1, 3, 11, 10, 7, 8, 4],
    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],
    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],
    [4, 7, 11, 4, 11, 9, 9, 11, 10],
    [9, 5, 4],
    [9, 5, 4, 0, 8, 3],
    [0, 5, 4, 1, 5, 0],
    [8, 5, 4, 8, 3, 5, 3, 1, 5],
    [1, 2, 10, 9, 5, 4],
    [3, 0, 8, 1, 2, 10, 4, 9, 5],
    [5, 2, 10, 5, 4, 2, 4, 0, 2],
    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],
    [9, 5, 4, 2, 3, 11],
    [0, 11, 2, 0, 8, 11, 4, 9, 5],
    [0, 5, 4, 0, 1, 5, 2, 3, 11],
    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],
    [10, 3, 11, 10, 1, 3, 9, 5, 4],
    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],
    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],
    [5, 4, 8, 5, 8, 10, 10, 8, 11],
    [9, 7, 8, 5, 7, 9],
    [9, 3, 0, 9, 5, 3, 5, 7, 3],
    [0, 7, 8, 0, 1, 7, 1, 5, 7],
    [1, 5, 3, 3, 5, 7],
    [9, 7, 8, 9, 5, 7, 10, 1, 2],
    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],
    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],
    [2, 10, 5, 2, 5, 3, 3, 5, 7],
    [7, 9, 5, 7, 8, 9, 3, 11, 2],
    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],
    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],
    [11, 2, 1, 11, 1, 7, 7, 1, 5],
    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],
    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],
    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],
    [11, 10, 5, 7, 11, 5],
    [10, 6, 5],
    [0, 8, 3, 5, 10, 6],
    [9, 0, 1, 5, 10, 6],
    [1, 8, 3, 1, 9, 8, 5, 10, 6],
    [1, 6, 5, 2, 6, 1],
    [1, 6, 5, 1, 2, 6, 3, 0, 8],
    [9, 6, 5, 9, 0, 6, 0, 2, 6],
    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],
    [2, 3, 11, 10, 6, 5],
    [11, 0, 8, 11, 2, 0, 10, 6, 5],
    [0, 1, 9, 2, 3, 11, 5, 10, 6],
    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],
    [6, 3, 11, 6, 5, 3, 5, 1, 3],
    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],
    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],
    [6, 5, 9, 6, 9, 11, 11, 9, 8],
    [5, 10, 6, 4, 7, 8],
    [4, 3, 0, 4, 7, 3, 6, 5, 10],
    [1, 9, 0, 5, 10, 6, 8, 4, 7],
    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],
    [6, 1, 2, 6, 5, 1, 4, 7, 8],
    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],
    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],
    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],
    [3, 11, 2, 7, 8, 4, 10, 6, 5],
    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],
    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],
    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],
    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],
    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],
    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],
    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],
    [10, 4, 9, 6, 4, 10],
    [4, 10, 6, 4, 9, 10, 0, 8, 3],
    [10, 0, 1, 10, 6, 0, 6, 4, 0],
    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],
    [1, 4, 9, 1, 2, 4, 2, 6, 4],
    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],
    [0, 2, 4, 4, 2, 6],
    [8, 3, 2, 8, 2, 4, 4, 2, 6],
    [10, 4, 9, 10, 6, 4, 11, 2, 3],
    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],
    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],
    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],
    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],
    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],
    [3, 11, 6, 3, 6, 0, 0, 6, 4],
    [6, 4, 8, 11, 6, 8],
    [7, 10, 6, 7, 8, 10, 8, 9, 10],
    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],
    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],
    [10, 6, 7, 10, 7, 1, 1, 7, 3],
    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],
    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],
    [7, 8, 0, 7, 0, 6, 6, 0, 2],
    [7, 3, 2, 6, 7, 2],
    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],
    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],
    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],
    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],
    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],
    [0, 9, 1, 11, 6, 7],
    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],
    [7, 11, 6],
    [7, 6, 11],
    [3, 0, 8, 11, 7, 6],
    [0, 1, 9, 11, 7, 6],
    [8, 1, 9, 8, 3, 1, 11, 7, 6],
    [10, 1, 2, 6, 11, 7],
    [1, 2, 10, 3, 0, 8, 6, 11, 7],
    [2, 9, 0, 2, 10, 9, 6, 11, 7],
    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],
    [7, 2, 3, 6, 2, 7],
    [7, 0, 8, 7, 6, 0, 6, 2, 0],
    [2, 7, 6, 2, 3, 7, 0, 1, 9],
    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],
    [10, 7, 6, 10, 1, 7, 1, 3, 7],
    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],
    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],
    [7, 6, 10, 7, 10, 8, 8, 10, 9],
    [6, 8, 4, 11, 8, 6],
    [3, 6, 11, 3, 0, 6, 0, 4, 6],
    [8, 6, 11, 8, 4, 6, 9, 0, 1],
    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],
    [6, 8, 4, 6, 11, 8, 2, 10, 1],
    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],
    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],
    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],
    [8, 2, 3, 8, 4, 2, 4, 6, 2],
    [0, 4, 2, 4, 6, 2],
    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],
    [1, 9, 4, 1, 4, 2, 2, 4, 6],
    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],
    [10, 1, 0, 10, 0, 6, 6, 0, 4],
    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],
    [10, 9, 4, 6, 10, 4],
    [4, 9, 5, 7, 6, 11],
    [0, 8, 3, 4, 9, 5, 11, 7, 6],
    [5, 0, 1, 5, 4, 0, 7, 6, 11],
    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],
    [9, 5, 4, 10, 1, 2, 7, 6, 11],
    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],
    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],
    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],
    [7, 2, 3, 7, 6, 2, 5, 4, 9],
    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],
    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],
    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],
    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],
    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],
    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],
    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],
    [6, 9, 5, 6, 11, 9, 11, 8, 9],
    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],
    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],
    [6, 11, 3, 6, 3, 5, 5, 3, 1],
    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],
    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],
    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],
    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],
    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],
    [9, 5, 6, 9, 6, 0, 0, 6, 2],
    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],
    [1, 5, 6, 2, 1, 6],
    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],
    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],
    [0, 3, 8, 5, 6, 10],
    [10, 5, 6],
    [11, 5, 10, 7, 5, 11],
    [11, 5, 10, 11, 7, 5, 8, 3, 0],
    [5, 11, 7, 5, 10, 11, 1, 9, 0],
    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],
    [11, 1, 2, 11, 7, 1, 7, 5, 1],
    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],
    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],
    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],
    [2, 5, 10, 2, 3, 5, 3, 7, 5],
    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],
    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],
    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],
    [1, 3, 5, 3, 7, 5],
    [0, 8, 7, 0, 7, 1, 1, 7, 5],
    [9, 0, 3, 9, 3, 5, 5, 3, 7],
    [9, 8, 7, 5, 9, 7],
    [5, 8, 4, 5, 10, 8, 10, 11, 8],
    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],
    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],
    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],
    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],
    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],
    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],
    [9, 4, 5, 2, 11, 3],
    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],
    [5, 10, 2, 5, 2, 4, 4, 2, 0],
    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],
    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],
    [8, 4, 5, 8, 5, 3, 3, 5, 1],
    [0, 4, 5, 1, 0, 5],
    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],
    [9, 4, 5],
    [4, 11, 7, 4, 9, 11, 9, 10, 11],
    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],
    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],
    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],
    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],
    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],
    [11, 7, 4, 11, 4, 2, 2, 4, 0],
    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],
    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],
    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],
    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],
    [1, 10, 2, 8, 7, 4],
    [4, 9, 1, 4, 1, 7, 7, 1, 3],
    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],
    [4, 0, 3, 7, 4, 3],
    [4, 8, 7],
    [9, 10, 8, 10, 11, 8],
    [3, 0, 9, 3, 9, 11, 11, 9, 10],
    [0, 1, 10, 0, 10, 8, 8, 10, 11],
    [3, 1, 10, 11, 3, 10],
    [1, 2, 11, 1, 11, 9, 9, 11, 8],
    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],
    [0, 2, 11, 8, 0, 11],
    [3, 2, 11],
    [2, 3, 8, 2, 8, 10, 10, 8, 9],
    [9, 10, 2, 0, 9, 2],
    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],
    [1, 10, 2],
    [1, 3, 8, 9, 1, 8],
    [0, 9, 1],
    [0, 3, 8],
    []
];

NGL.MarchingCubes.triTable2 = new Int32Array( [
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,
    3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,
    3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,
    3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,
    9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
    2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,
    8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
    4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,
    3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,
    1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
    4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,
    4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
    5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,
    2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
    9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,
    0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,
    2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,
    10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,
    5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,
    5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,
    9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,
    1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,
    10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,
    8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
    2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,
    7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,
    2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,
    11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,
    5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,
    11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,
    11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
    9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,
    2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,
    6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,
    3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,
    6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,
    10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,
    6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,
    8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,
    7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,
    3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,
    5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
    0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,
    9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,
    8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,
    5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,
    0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
    6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
    10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,
    10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,
    8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,
    0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,
    3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,
    9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,
    8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
    3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,
    6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,
    0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,
    10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
    10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,
    2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,
    7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,
    7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,
    2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,
    1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,
    11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,
    8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
    0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,
    7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
    10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,
    7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,
    2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,
    1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
    10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,
    10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,
    0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,
    7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,
    6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,
    9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,
    6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
    4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,
    10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,
    8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,
    0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
    1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,
    10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,
    4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,
    10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
    5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
    11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,
    9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
    6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,
    7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,
    3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,
    7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
    3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,
    6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,
    9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,
    1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,
    4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
    7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,
    6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,
    3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,
    0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,
    6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,
    0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,
    11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,
    6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,
    5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
    9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,
    1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,
    1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,
    10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
    0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,
    5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
    10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,
    11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,
    9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,
    7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
    2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,
    8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,
    9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,
    9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,
    1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,
    9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,
    9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,
    5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
    0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,
    10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,
    2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,
    0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,
    0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
    9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,
    5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,
    3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,
    5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
    8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,
    0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,
    9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
    0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,
    1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,
    3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,
    4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,
    9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
    11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,
    11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,
    2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,
    9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,
    3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
    1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,
    4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,
    4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,
    0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,
    3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
    3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,
    0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,
    9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,
    1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
] );

NGL.MarchingCubes.cubeVerts = [
    [0,0,0],
    [1,0,0],
    [1,1,0],
    [0,1,0],
    [0,0,1],
    [1,0,1],
    [1,1,1],
    [0,1,1]
];

NGL.MarchingCubes.edgeIndex = [
    [0,1], [1,2], [2,3], [3,0], [4,5], [5,6],
    [6,7], [7,4], [0,4], [1,5], [2,6], [3,7]
];


//////////////
// Smoothing

NGL.laplacianSmooth = function( verts, faces, numiter, inflate ){

    // based on D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular
    // Surfaces by Euclidean Distance Transform. PLoS ONE 4(12): e8140.
    //
    // Permission to use, copy, modify, and distribute this program for
    // any purpose, with or without fee, is hereby granted, provided that
    // the notices on the head, the reference information, and this
    // copyright notice appear in all copies or substantial portions of
    // the Software. It is provided "as is" without express or implied
    // warranty.
    //
    // ported to JavaScript and adapted to NGL by Alexander Rose

    NGL.time( "NGL.laplacianSmooth" );

    numiter = numiter || 1;
    inflate = inflate || true;

    var nv = verts.length / 3;
    var nf = faces.length / 3;

    if( inflate ){

        // Buffer geometry is only used to calculate normals

        var bg = new THREE.BufferGeometry();
        bg.addAttribute( "position", new THREE.BufferAttribute( verts, 3 ) );
        bg.addIndex( new THREE.BufferAttribute( faces, 1 ) );

    }

    var tps = new Float32Array( nv * 3 );

    var ndeg = 20;
    var vertdeg = new Array( ndeg );

    for( var i = 0; i < ndeg; ++i ){
        vertdeg[ i ] = new Uint32Array( nv );
    }

    for( var i = 0; i < nv; ++i ){
        vertdeg[ 0 ][ i ] = 0;
    }

    var j, jl;
    var flagvert;

    // for each face

    for( var i = 0; i < nf; ++i ){

        var ao = i * 3;
        var bo = i * 3 + 1;
        var co = i * 3 + 2;

        // vertex a

        flagvert = true;
        for( j = 0, jl = vertdeg[ 0 ][ faces[ao] ]; j < jl; ++j ){
            if( faces[ bo ] == vertdeg[ j + 1 ][ faces[ ao ]] ){
                flagvert = false;
                break;
            }
        }
        if( flagvert ){
            vertdeg[ 0 ][ faces[ ao ] ]++;
            vertdeg[ vertdeg[ 0 ][ faces[ ao ] ] ][ faces[ ao ] ] = faces[ bo ];
        }

        flagvert = true;
        for( j = 0, jl = vertdeg[ 0 ][ faces[ ao ] ]; j < jl; ++j ){
            if( faces[ co] == vertdeg[ j + 1 ][ faces[ ao ] ] ){
                flagvert = false;
                break;
            }
        }
        if( flagvert ){
            vertdeg[ 0 ][ faces[ ao ] ]++;
            vertdeg[ vertdeg[ 0 ][ faces[ ao ] ] ][ faces[ ao ] ] = faces[ co ];
        }

        // vertex b

        flagvert = true;
        for( j = 0, jl = vertdeg[ 0 ][ faces[ bo ] ]; j < jl; ++j ){
            if( faces[ ao ] == vertdeg[ j + 1 ][ faces[ bo ] ] ){
                flagvert = false;
                break;
            }
        }
        if( flagvert ){
            vertdeg[ 0 ][ faces[ bo ] ]++;
            vertdeg[ vertdeg[ 0 ][ faces[ bo ] ] ][ faces[ bo ] ] = faces[ ao ];
        }

        flagvert = true;
        for( j = 0, jl = vertdeg[ 0 ][ faces[ bo ] ]; j < jl; ++j ){
            if( faces[ co ] == vertdeg[ j + 1 ][ faces[ bo ] ] ){
                flagvert = false;
                break;
            }
        }
        if( flagvert ){
            vertdeg[ 0 ][ faces[ bo ] ]++;
            vertdeg[ vertdeg[ 0 ][ faces[ bo ] ] ][ faces[ bo ] ] = faces[ co ];
        }

        // vertex c

        flagvert = true;
        for( j = 0; j < vertdeg[ 0 ][ faces[ co ] ]; ++j ){
            if( faces[ ao ] == vertdeg[ j + 1 ][ faces[ co ] ] ){
                flagvert = false;
                break;
            }
        }
        if( flagvert ){
            vertdeg[ 0 ][ faces[ co ] ]++;
            vertdeg[ vertdeg[ 0 ][ faces[ co ] ] ][ faces[ co ] ] = faces[ ao ];
        }

        flagvert = true;
        for( j = 0, jl = vertdeg[ 0 ][ faces[ co ] ]; j < jl; ++j ){
            if( faces[ bo ] == vertdeg[ j + 1 ][ faces[ co ] ] ){
                flagvert = false;
                break;
            }
        }
        if( flagvert ){
            vertdeg[ 0 ][ faces[ co ] ]++;
            vertdeg[ vertdeg[ 0 ][ faces[ co ] ] ][ faces[ co ] ] = faces[ bo ];
        }

    }

    var wt = 1.0;
    var wt2 = 0.5;
    var i3, vi3, vi, vdi, wt_vi, wt2_vi;
    var ssign = -1;
    var scaleFactor = 1;
    var outwt = 0.75 / ( scaleFactor + 3.5 );  // area-preserving

    // smoothing iterations

    for( var k = 0; k < numiter; ++k ){

        // for each vertex

        for( var i = 0; i < nv; ++i ){

            i3 = i * 3;
            vdi = vertdeg[ 0 ][ i ];

            if( vdi < 3 ){

                tps[ i3     ] = verts[ i3     ];
                tps[ i3 + 1 ] = verts[ i3 + 1 ];
                tps[ i3 + 2 ] = verts[ i3 + 2 ];

            }else if( vdi === 3 || vdi === 4 ){

                tps[ i3     ] = 0;
                tps[ i3 + 1 ] = 0;
                tps[ i3 + 2 ] = 0;

                for( j = 0; j < vdi; ++j ){
                    vi3 = vertdeg[ j + 1 ][ i ] * 3;
                    tps[ i3     ] += verts[ vi3     ];
                    tps[ i3 + 1 ] += verts[ vi3 + 1 ];
                    tps[ i3 + 2 ] += verts[ vi3 + 2 ];
                }

                tps[ i3     ] += wt2 * verts[ i3 ];
                tps[ i3 + 1 ] += wt2 * verts[ i3 + 1 ];
                tps[ i3 + 2 ] += wt2 * verts[ i3 + 2 ];

                wt2_vi = wt2 + vdi;
                tps[ i3     ] /= wt2_vi;
                tps[ i3 + 1 ] /= wt2_vi;
                tps[ i3 + 2 ] /= wt2_vi;

            }else{

                tps[ i3     ] = 0;
                tps[ i3 + 1 ] = 0;
                tps[ i3 + 2 ] = 0;

                for( j = 0; j < vdi; ++j ){
                    vi3 = vertdeg[ j + 1 ][ i ] * 3;
                    tps[ i3     ] += verts[ vi3     ];
                    tps[ i3 + 1 ] += verts[ vi3 + 1 ];
                    tps[ i3 + 2 ] += verts[ vi3 + 2 ];
                }

                tps[ i3     ] += wt * verts[ i3 ];
                tps[ i3 + 1 ] += wt * verts[ i3 + 1 ];
                tps[ i3 + 2 ] += wt * verts[ i3 + 2 ];

                wt_vi = wt + vdi;
                tps[ i3     ] /= wt_vi;
                tps[ i3 + 1 ] /= wt_vi;
                tps[ i3 + 2 ] /= wt_vi;

            }

        }

        verts.set( tps );  // copy smoothed positions

        if( inflate ){

            bg.computeVertexNormals();
            var norms = bg.attributes.normal.array;
            var nv3 = nv * 3;

            for( i3 = 0; i3 < nv3; i3 += 3 ){

                // if(verts[i].inout) ssign=1;
                // else ssign=-1;

                verts[ i3     ] += ssign * outwt * norms[ i3     ];
                verts[ i3 + 1 ] += ssign * outwt * norms[ i3 + 1 ];
                verts[ i3 + 2 ] += ssign * outwt * norms[ i3 + 2 ];

            }

        }

    }

    if( inflate ){

        bg.dispose();

    }

    NGL.timeEnd( "NGL.laplacianSmooth" );

};


//////////////////////
// Molecular surface

NGL.WorkerRegistry.add( "molsurf", function( e, callback ){

    NGL.time( "WORKER molsurf" );

    var d = e.data;
    var p = d.params;

    if( d.atomSet ){

        self.molsurf = new NGL.MolecularSurface(
            new NGL.AtomSet().fromJSON( d.atomSet )
        );

    }

    var molsurf = self.molsurf;

    var surface = molsurf.getSurface(
        p.type, p.probeRadius, p.scaleFactor, p.smooth, p.lowRes, p.cutoff
    );

    NGL.timeEnd( "WORKER molsurf" );

    callback( surface.toJSON(), surface.getTransferable() );

} );


NGL.MolecularSurface = function( atomSet ){

    this.atomSet = atomSet;

};

NGL.MolecularSurface.prototype = {

    getSurface: function( type, probeRadius, scaleFactor, smooth, lowRes, cutoff ){

        var edtsurf = new NGL.EDTSurface( this.atomSet );
        var vol = edtsurf.getVolume(
            type, probeRadius, scaleFactor, lowRes, cutoff
        );
        var surface = vol.getSurface( 1, smooth );

        surface.info[ "type" ] = type;
        surface.info[ "probeRadius" ] = probeRadius;
        surface.info[ "scaleFactor" ] = scaleFactor;
        surface.info[ "smooth" ] = smooth;
        surface.info[ "lowRes" ] = lowRes;
        surface.info[ "cutoff" ] = cutoff;

        vol.dispose();

        return surface;

    },

    getSurfaceWorker: function( type, probeRadius, scaleFactor, smooth, lowRes, cutoff, callback ){

        if( NGL.useWorker && typeof Worker !== "undefined" &&
            typeof importScripts !== 'function'
        ){

            var atomSet = undefined;

            if( this.worker === undefined ){

                atomSet = this.atomSet.toJSON();
                this.worker = new NGL.Worker( "molsurf" );

            }

            this.worker.post(

                {
                    atomSet: atomSet,
                    params: {
                        type: type,
                        probeRadius: probeRadius,
                        scaleFactor: scaleFactor,
                        smooth: smooth,
                        lowRes: lowRes,
                        cutoff: cutoff
                    }
                },

                undefined,

                function( e ){

                    var surface = NGL.fromJSON( e.data );
                    callback( surface );

                }.bind( this ),

                function( e ){

                    console.warn(
                        "NGL.MolecularSurface.generateSurfaceWorker error - trying without worker", e
                    );
                    this.worker.terminate();
                    this.worker = undefined;

                    var surface = this.getSurface(
                        type, probeRadius, scaleFactor, smooth, lowRes, cutoff
                    );
                    callback( surface );

                }.bind( this )

            );

        }else{

            var surface = this.getSurface(
                type, probeRadius, scaleFactor, smooth, lowRes, cutoff
            );
            callback( surface );

        }

    },

    dispose: function(){

        if( this.worker ) this.worker.terminate();

    }

};


NGL.EDTSurface = function( atomSet ){

    // based on D. Xu, Y. Zhang (2009) Generating Triangulated Macromolecular
    // Surfaces by Euclidean Distance Transform. PLoS ONE 4(12): e8140.
    //
    // Permission to use, copy, modify, and distribute this program for
    // any purpose, with or without fee, is hereby granted, provided that
    // the notices on the head, the reference information, and this
    // copyright notice appear in all copies or substantial portions of
    // the Software. It is provided "as is" without express or implied
    // warranty.
    //
    // ported to JavaScript by biochem_fan (http://webglmol.sourceforge.jp/)
    // refactored by dkoes (https://github.com/dkoes)
    //
    // adapted to NGL by Alexander Rose

    var atoms = atomSet.atoms;
    var bbox = atomSet.getBoundingBox();

    var probeRadius, scaleFactor, cutoff, lowRes;
    var pLength, pWidth, pHeight;
    var matrix, ptran;
    var depty, widxz;
    var cutRadius;
    var setAtomID;
    var vpBits, vpDistance, vpAtomID;

    var radiusProperty;
    var radiusDict;
    var selection;

    function init( btype, _probeRadius, _scaleFactor, _cutoff, _lowRes, _setAtomID ){

        probeRadius = _probeRadius || 1.4;
        scaleFactor = _scaleFactor || 2.0;
        lowRes = _lowRes || false;
        setAtomID = _setAtomID || true;

        if( lowRes ){

            radiusProperty = "resname";
            radiusDict = NGL.ResidueRadii;

            selection = new NGL.Selection( ".CA" );

        }else{

            radiusProperty = "element";
            radiusDict = NGL.VdwRadii;

            selection = undefined;

        }

        var maxRadius = 0;
        for( var name in radiusDict ){
            maxRadius = Math.max( maxRadius, radiusDict[ name ] );
        }

        var grid = NGL.getSurfaceGrid(
            bbox, maxRadius, scaleFactor, btype ? probeRadius : 0
        );

        pLength = grid.dim.x;
        pWidth = grid.dim.y;
        pHeight = grid.dim.z;

        matrix = grid.matrix;
        ptran = grid.tran;
        scaleFactor = grid.scaleFactor;

        // boundingatom caches
        depty = {};
        widxz = {};
        boundingatom( btype );

        cutRadius = probeRadius * scaleFactor;

        if( _cutoff ){
            cutoff = _cutoff;
        }else{
            cutoff = Math.max( 0.1, -1.2 + scaleFactor * probeRadius );
        }

        vpBits = new Uint8Array( pLength * pWidth * pHeight );
        if( btype ){
            vpDistance = new Float64Array( pLength * pWidth * pHeight );
        }
        if( setAtomID ){
            vpAtomID = new Int32Array( pLength * pWidth * pHeight );
        }

    }

    // constants for vpBits bitmasks
    var INOUT = 1;
    var ISDONE = 2;
    var ISBOUND = 4;

    var nb = [
        new Int32Array([  1,  0,  0 ]), new Int32Array([ -1,  0,  0 ]),
        new Int32Array([  0,  1,  0 ]), new Int32Array([  0, -1,  0 ]),
        new Int32Array([  0,  0,  1 ]), new Int32Array([  0,  0, -1 ]),
        new Int32Array([  1,  1,  0 ]), new Int32Array([  1, -1,  0 ]),
        new Int32Array([ -1,  1,  0 ]), new Int32Array([ -1, -1,  0 ]),
        new Int32Array([  1,  0,  1 ]), new Int32Array([  1,  0, -1 ]),
        new Int32Array([ -1,  0,  1 ]), new Int32Array([ -1,  0, -1 ]),
        new Int32Array([  0,  1,  1 ]), new Int32Array([  0,  1, -1 ]),
        new Int32Array([  0, -1,  1 ]), new Int32Array([  0, -1, -1 ]),
        new Int32Array([  1,  1,  1 ]), new Int32Array([  1,  1, -1 ]),
        new Int32Array([  1, -1,  1 ]), new Int32Array([ -1,  1,  1 ]),
        new Int32Array([  1, -1, -1 ]), new Int32Array([ -1, -1,  1 ]),
        new Int32Array([ -1,  1, -1 ]), new Int32Array([ -1, -1, -1 ])
    ];

    //

    this.getVolume = function( type, probeRadius, scaleFactor, lowRes, cutoff, setAtomID ){

        NGL.time( "NGL.EDTSurface.getVolume" );

        var btype = type !== "vws";
        setAtomID = true;

        init( btype, probeRadius, scaleFactor, cutoff, lowRes, setAtomID );

        fillvoxels( btype );
        buildboundary();

        if( type === "ms" || type === "ses" ){

            fastdistancemap();

        }

        if( type === "ses" ){

            boundingatom( false );
            fillvoxelswaals();

        }

        marchingcubeinit( type );

        var vol = new NGL.Volume(
            type, "", vpBits, pHeight, pWidth, pLength, vpAtomID
        );

        vol.setMatrix( matrix );

        NGL.timeEnd( "NGL.EDTSurface.getVolume" );

        return vol;

    };


    function boundingatom( btype ){

        var r, j, k;
        var txz, tdept, sradius, tradius, widxz_r;
        var depty_name, indx;

        for( var name in radiusDict ){

            r = radiusDict[ name ];

            if( depty[ name ] ) continue;

            if( !btype ){
                tradius = r * scaleFactor + 0.5;
            }else{
                tradius = ( r + probeRadius ) * scaleFactor + 0.5;
            }

            sradius = tradius * tradius;
            widxz_r = Math.floor( tradius ) + 1;
            depty_name = new Int32Array( widxz_r * widxz_r );
            indx = 0;

            for( j = 0; j < widxz_r; ++j ){

                for( k = 0; k < widxz_r; ++k ){

                    txz = j * j + k * k;

                    if( txz > sradius ){

                        depty_name[ indx ] = -1;

                    }else{

                        tdept = Math.sqrt( sradius - txz );
                        depty_name[ indx ] = Math.floor( tdept );

                    }

                    ++indx;

                }

            }

            widxz[ name ] = widxz_r;
            depty[ name ] = depty_name;

        }

    }

    function fillatom( atomIndex ){

        var cx, cy, cz, ox, oy, oz, mi, mj, mk, i, j, k, si, sj, sk;
        var ii, jj, kk;

        var atom = atoms[ atomIndex ];

        if( selection && !selection.test( atom ) ) return;

        cx = Math.floor( 0.5 + scaleFactor * ( atom.x + ptran.x ) );
        cy = Math.floor( 0.5 + scaleFactor * ( atom.y + ptran.y ) );
        cz = Math.floor( 0.5 + scaleFactor * ( atom.z + ptran.z ) );

        var at = atom[ radiusProperty ];
        var depty_at = depty[ at ];
        var nind = 0;
        var cnt = 0;
        var pWH = pWidth * pHeight;
        var n = widxz[ at ];

        var depty_at_nind;

        for( i = 0; i < n; ++i ){
        for( j = 0; j < n; ++j ) {

            depty_at_nind = depty_at[ nind ];

            if( depty_at_nind != -1 ){

                for( ii = -1; ii < 2; ++ii ){
                for( jj = -1; jj < 2; ++jj ){
                for( kk = -1; kk < 2; ++kk ){

                    if( ii !== 0 && jj !== 0 && kk !== 0 ){

                        mi = ii * i;
                        mk = kk * j;

                        for( k = 0; k <= depty_at_nind; ++k ){

                            mj = k * jj;
                            si = cx + mi;
                            sj = cy + mj;
                            sk = cz + mk;

                            if( si < 0 || sj < 0 || sk < 0 ||
                                si >= pLength || sj >= pWidth || sk >= pHeight
                            ){
                                continue;
                            }

                            var index = si * pWH + sj * pHeight + sk;

                            if( !setAtomID ){

                                vpBits[ index ] |= INOUT;

                            }else{

                                if( !( vpBits[ index ] & INOUT ) ){

                                    vpBits[ index ] |= INOUT;
                                    vpAtomID[ index ] = atomIndex;

                                }else if( vpBits[ index ] & INOUT ){
                                // }else{

                                    var atom2 = atoms[ vpAtomID[ index ] ];

                                    if( atom2 !== atom ){

                                        ox = cx + mi - Math.floor( 0.5 + scaleFactor * ( atom2.x + ptran.x ) );
                                        oy = cy + mj - Math.floor( 0.5 + scaleFactor * ( atom2.y + ptran.y ) );
                                        oz = cz + mk - Math.floor( 0.5 + scaleFactor * ( atom2.z + ptran.z ) );

                                        if( mi * mi + mj * mj + mk * mk <
                                            ox * ox + oy * oy + oz * oz
                                        ){
                                            vpAtomID[ index ] = atomIndex;
                                        }

                                    }

                                }

                            }

                        }// k

                    }// if

                }// kk
                }// jj
                }// ii

            }// if

            nind++;

        }// j
        }// i

    }

    function fillvoxels( btype ){

        NGL.time( "NGL.EDTSurface fillvoxels" );

        var i, il;

        for( i = 0, il = vpBits.length; i < il; ++i ){
            vpBits[ i ] = 0;
            if( btype ) vpDistance[ i ] = -1.0;
            if( setAtomID ) vpAtomID[ i ] = -1;
        }

        for( i = 0, il = atoms.length; i < il; ++i ){
            fillatom( i );
        }

        for( i = 0, il = vpBits.length; i < il; ++i ){
            if( vpBits[ i ] & INOUT ){
                vpBits[ i ] |= ISDONE;
            }
        }

        NGL.timeEnd( "NGL.EDTSurface fillvoxels" );

    }

    function fillAtomWaals( atomIndex ){

        var cx, cy, cz, ox, oy, oz, nind = 0;
        var mi, mj, mk, si, sj, sk, i, j, k, ii, jj, kk, n;

        var atom = atoms[ atomIndex ];

        if( selection && !selection.test( atom ) ) return;

        cx = Math.floor( 0.5 + scaleFactor * ( atom.x + ptran.x ) );
        cy = Math.floor( 0.5 + scaleFactor * ( atom.y + ptran.y ) );
        cz = Math.floor( 0.5 + scaleFactor * ( atom.z + ptran.z ) );

        var at = atom[ radiusProperty ];
        var pWH = pWidth * pHeight;

        for( i = 0, n = widxz[at]; i < n; ++i ){
        for( j = 0; j < n; ++j ){

            if( depty[ at ][ nind ] != -1 ){

                for( ii = -1; ii < 2; ++ii ){
                for( jj = -1; jj < 2; ++jj ){
                for( kk = -1; kk < 2; ++kk ){

                    if( ii !== 0 && jj !== 0 && kk !== 0 ){

                        mi = ii * i;
                        mk = kk * j;

                        for( k = 0; k <= depty[ at ][ nind ]; ++k ){

                            mj = k * jj;
                            si = cx + mi;
                            sj = cy + mj;
                            sk = cz + mk;

                            if( si < 0 || sj < 0 || sk < 0 ||
                                si >= pLength || sj >= pWidth || sk >= pHeight
                            ){
                                continue;
                            }

                            var index = si * pWH + sj * pHeight + sk;

                            if( !( vpBits[ index ] & ISDONE ) ){

                                vpBits[ index ] |= ISDONE;
                                if( setAtomID ) vpAtomID[ index ] = atom.index;

                            }else if( setAtomID ){

                                var atom2 = atoms[ vpAtomID[ index ] ];
                                ox = Math.floor( 0.5 + scaleFactor * ( atom2.x + ptran.x ) );
                                oy = Math.floor( 0.5 + scaleFactor * ( atom2.y + ptran.y ) );
                                oz = Math.floor( 0.5 + scaleFactor * ( atom2.z + ptran.z ) );

                                if( mi * mi + mj * mj + mk * mk <
                                    ox * ox + oy * oy + oz * oz
                                ){
                                    vpAtomID[ index ] = atom.index;
                                }

                            }

                        }// k

                    }// if

                }// kk
                }// jj
                }// ii

            }// if

            nind++;

        }// j
        }// i

    }

    function fillvoxelswaals(){

        var i, il;

        for( i = 0, il = vpBits.length; i < il; ++i ){
            vpBits[ i ] &= ~ISDONE;  // not isdone
        }

        for( i = 0, il = atoms.length; i < il; ++i ){
            fillAtomWaals( i );
        }

    }

    function buildboundary(){

        var i, j, k;
        var pWH = pWidth * pHeight;

        for( i = 0; i < pLength; ++i ){
        for( j = 0; j < pHeight; ++j ){
        for( k = 0; k < pWidth; ++k ){

            var index = i * pWH + k * pHeight + j;

            if( vpBits[ index ] & INOUT ){

                // var flagbound = false;
                var ii = 0;

                // while( !flagbound && ii < 26 ){
                while( ii < 26 ){

                    var ti = i + nb[ ii ][ 0 ];
                    var tj = j + nb[ ii ][ 2 ];
                    var tk = k + nb[ ii ][ 1 ];

                    if( ti > -1 && ti < pLength &&
                        tk > -1 && tk < pWidth &&
                        tj > -1 && tj < pHeight &&
                        !( vpBits[ ti * pWH + tk * pHeight + tj ] & INOUT )
                    ){

                        vpBits[ index ] |= ISBOUND;
                        // flagbound = true;
                        break;

                    }else{

                        ii++;

                    }

                }

            }

        } // k
        } // j
        } // i

    }

    function fastdistancemap(){

        NGL.time( "NGL.EDTSurface fastdistancemap" );

        var eliminate = 0;
        var certificate;
        var i, j, k, n;

        var boundPoint = new NGL.Grid(
            pLength, pWidth, pHeight, Uint16Array, 3
        );
        var pWH = pWidth * pHeight;
        var cutRSq = cutRadius * cutRadius;

        var totalsurfacevox = 0;
        var totalinnervox = 0;

        var index;

        // console.log( "lwh", pLength * pWidth * pHeight );
        console.log( "l, w, h", pLength, pWidth, pHeight );

        for( i = 0; i < pLength; ++i ){
            for( j = 0; j < pWidth; ++j ){
                for( k = 0; k < pHeight; ++k ){

                    index = i * pWH + j * pHeight + k;

                    vpBits[ index ] &= ~ISDONE;

                    if( vpBits[ index ] & INOUT ){

                        if( vpBits[ index ] & ISBOUND ){

                            boundPoint.set(
                                i, j, k,
                                i, j, k
                            );

                            vpDistance[ index ] = 0;
                            vpBits[ index ] |= ISDONE;

                            totalsurfacevox += 1;

                        }else{

                            totalinnervox += 1;

                        }

                    }

                }
            }
        }

        console.log( "totalsurfacevox", totalsurfacevox );
        console.log( "totalinnervox", totalinnervox );

        var inarray = new Int32Array( 3 * totalsurfacevox );
        var positin = 0;
        var outarray = new Int32Array( 3 * totalsurfacevox );
        var positout = 0;

        for( i = 0; i < pLength; ++i ){
            for( j = 0; j < pWidth; ++j ){
                for( k = 0; k < pHeight; ++k ){

                    index = i * pWH + j * pHeight + k;

                    if( vpBits[ index ] & ISBOUND ){

                        inarray[ positin     ] = i;
                        inarray[ positin + 1 ] = j;
                        inarray[ positin + 2 ] = k;
                        positin += 3;

                        vpBits[ index ] &= ~ISBOUND;

                    }

                }
            }
        }

        do{

            positout = fastoneshell( inarray, boundPoint, positin, outarray );
            positin = 0;

            console.log( "positout", positout / 3 );

            for( i = 0, n = positout; i < n; i+=3 ){

                index = pWH * outarray[ i ] + pHeight * outarray[ i + 1 ] + outarray[ i + 2 ];
                vpBits[ index ] &= ~ISBOUND;

                if( vpDistance[ index ] <= 1.0404 * cutRSq ){
                //if( vpDistance[ index ] <= 1.02 * cutRadius ){

                    inarray[ positin     ] = outarray[ i     ];
                    inarray[ positin + 1 ] = outarray[ i + 1 ];
                    inarray[ positin + 2 ] = outarray[ i + 2 ];
                    positin += 3;

                }

            }

        }while( positin > 0 );

        // var cutsf = Math.max( 0, scaleFactor - 0.5 );
        // cutoff = cutRadius - 0.5 / ( 0.1 + cutsf );
        var cutoffSq = cutoff * cutoff;

        var index2;
        var bp = new Uint16Array( 3 );

        for( i = 0; i < pLength; ++i ){
            for( j = 0; j < pWidth; ++j ){
                for( k = 0; k < pHeight; ++k ){

                    index = i * pWH + j * pHeight + k;
                    vpBits[ index ] &= ~ISBOUND;

                    // ses solid

                    if( vpBits[ index ] & INOUT ) {

                        if( !( vpBits[ index ] & ISDONE ) ||
                            ( ( vpBits[ index ] & ISDONE ) && vpDistance[ index ] >= cutoffSq )
                        ){

                            vpBits[ index ] |= ISBOUND;

                            if( setAtomID && ( vpBits[ index ] & ISDONE ) ){

                                boundPoint.toArray( i, j, k, bp );
                                index2 = bp[ 0 ] * pWH + bp[ 1 ] * pHeight + bp[ 2 ];

                                vpAtomID[ index ] = vpAtomID[ index2 ];

                            }

                        }
                    }

                }
            }
        }

        NGL.timeEnd( "NGL.EDTSurface fastdistancemap" );

    }

    function fastoneshell( inarray, boundPoint, positin, outarray ){

        console.log( "positin", positin / 3 );

        // *allocout,voxel2
        // ***boundPoint, int*
        // outnum, int *elimi)
        var tx, ty, tz;
        var dx, dy, dz;
        var i, j, n;
        var square;
        var index;
        var nb_j;
        var bp = new Uint16Array( 3 );
        var positout = 0;

        if( positin === 0 ){
            return positout;
        }

        var tnv_ix = -1;
        var tnv_iy = -1;
        var tnv_iz = -1;

        var pWH = pWidth * pHeight;

        for( i = 0, n = positin; i < n; i+=3 ){

            tx = inarray[ i     ];
            ty = inarray[ i + 1 ];
            tz = inarray[ i + 2 ];
            boundPoint.toArray( tx, ty, tz, bp );

            for( j = 0; j < 6; ++j ){

                nb_j = nb[ j ];
                tnv_ix = tx + nb_j[ 0 ];
                tnv_iy = ty + nb_j[ 1 ];
                tnv_iz = tz + nb_j[ 2 ];

                if( tnv_ix < pLength && tnv_ix > -1 &&
                    tnv_iy < pWidth  && tnv_iy > -1 &&
                    tnv_iz < pHeight && tnv_iz > -1
                ){

                    index = tnv_ix * pWH + pHeight * tnv_iy + tnv_iz;

                    if( ( vpBits[ index ] & INOUT ) && !( vpBits[ index ] & ISDONE ) ){

                        boundPoint.fromArray( tnv_ix, tnv_iy, tnv_iz, bp );
                        dx = tnv_ix - bp[ 0 ];
                        dy = tnv_iy - bp[ 1 ];
                        dz = tnv_iz - bp[ 2 ];
                        square = dx * dx + dy * dy + dz * dz;
                        //square = Math.sqrt( square );

                        vpDistance[ index ] = square;
                        vpBits[ index ] |= ISDONE;
                        vpBits[ index ] |= ISBOUND;

                        outarray[ positout     ] = tnv_ix;
                        outarray[ positout + 1 ] = tnv_iy;
                        outarray[ positout + 2 ] = tnv_iz;
                        positout += 3;

                    }else if( ( vpBits[ index ] & INOUT ) && ( vpBits[ index ] & ISDONE ) ){

                        dx = tnv_ix - bp[ 0 ];
                        dy = tnv_iy - bp[ 1 ];
                        dz = tnv_iz - bp[ 2 ];
                        square = dx * dx + dy * dy + dz * dz;
                        //square = Math.sqrt( square );

                        if( square < vpDistance[ index ] ){

                            boundPoint.fromArray( tnv_ix, tnv_iy, tnv_iz, bp );
                            vpDistance[ index ] = square;

                            if( !( vpBits[ index ] & ISBOUND ) ){

                                vpBits[ index ] |= ISBOUND;

                                outarray[ positout     ] = tnv_ix;
                                outarray[ positout + 1 ] = tnv_iy;
                                outarray[ positout + 2 ] = tnv_iz;
                                positout += 3;

                            }

                        }

                    }

                }
            }
        }

        // console.log("part1", positout);

        for( i = 0, n = positin; i < n; i+=3 ){

            tx = inarray[ i     ];
            ty = inarray[ i + 1 ];
            tz = inarray[ i + 2 ];
            boundPoint.toArray( tx, ty, tz, bp );

            for (j = 6; j < 18; j++) {

                nb_j = nb[ j ];
                tnv_ix = tx + nb_j[ 0 ];
                tnv_iy = ty + nb_j[ 1 ];
                tnv_iz = tz + nb_j[ 2 ];

                if( tnv_ix < pLength && tnv_ix > -1 &&
                    tnv_iy < pWidth  && tnv_iy > -1 &&
                    tnv_iz < pHeight && tnv_iz > -1
                ) {

                    index = tnv_ix * pWH + pHeight * tnv_iy + tnv_iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {

                        boundPoint.fromArray( tnv_ix, tnv_iy, tnv_iz, bp );
                        dx = tnv_ix - bp[ 0 ];
                        dy = tnv_iy - bp[ 1 ];
                        dz = tnv_iz - bp[ 2 ];
                        square = dx * dx + dy * dy + dz * dz;
                        //square = Math.sqrt( square );

                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray[ positout     ] = tnv_ix;
                        outarray[ positout + 1 ] = tnv_iy;
                        outarray[ positout + 2 ] = tnv_iz;
                        positout += 3;

                    } else if ((vpBits[index] & INOUT) && (vpBits[index] & ISDONE)) {

                        dx = tnv_ix - bp[ 0 ];
                        dy = tnv_iy - bp[ 1 ];
                        dz = tnv_iz - bp[ 2 ];
                        square = dx * dx + dy * dy + dz * dz;
                        //square = Math.sqrt( square );

                        if (square < vpDistance[index]) {

                            boundPoint.fromArray( tnv_ix, tnv_iy, tnv_iz, bp );
                            vpDistance[index] = square;

                            if (!(vpBits[index] & ISBOUND)) {

                                vpBits[index] |= ISBOUND;

                                outarray[ positout     ] = tnv_ix;
                                outarray[ positout + 1 ] = tnv_iy;
                                outarray[ positout + 2 ] = tnv_iz;
                                positout += 3;

                            }

                        }

                    }

                }
            }
        }

        // console.log("part2", positout);

        for( i = 0, n = positin; i < n; i+=3 ){

            tx = inarray[ i     ];
            ty = inarray[ i + 1 ];
            tz = inarray[ i + 2 ];
            boundPoint.toArray( tx, ty, tz, bp );

            for (j = 18; j < 26; j++) {

                nb_j = nb[ j ];
                tnv_ix = tx + nb_j[ 0 ];
                tnv_iy = ty + nb_j[ 1 ];
                tnv_iz = tz + nb_j[ 2 ];

                if( tnv_ix < pLength && tnv_ix > -1 &&
                    tnv_iy < pWidth  && tnv_iy > -1 &&
                    tnv_iz < pHeight && tnv_iz > -1
                ){

                    index = tnv_ix * pWH + pHeight * tnv_iy + tnv_iz;

                    if ((vpBits[index] & INOUT) && !(vpBits[index] & ISDONE)) {

                        boundPoint.fromArray( tnv_ix, tnv_iy, tnv_iz, bp );
                        dx = tnv_ix - bp[ 0 ];
                        dy = tnv_iy - bp[ 1 ];
                        dz = tnv_iz - bp[ 2 ];
                        square = dx * dx + dy * dy + dz * dz;
                        //square = Math.sqrt( square );

                        vpDistance[index] = square;
                        vpBits[index] |= ISDONE;
                        vpBits[index] |= ISBOUND;

                        outarray[ positout     ] = tnv_ix;
                        outarray[ positout + 1 ] = tnv_iy;
                        outarray[ positout + 2 ] = tnv_iz;
                        positout += 3;

                    } else if ((vpBits[index] & INOUT)  && (vpBits[index] & ISDONE)) {

                        dx = tnv_ix - bp[ 0 ];
                        dy = tnv_iy - bp[ 1 ];
                        dz = tnv_iz - bp[ 2 ];
                        square = dx * dx + dy * dy + dz * dz;
                        //square = Math.sqrt( square );

                        if (square < vpDistance[index]) {

                            boundPoint.fromArray( tnv_ix, tnv_iy, tnv_iz, bp );
                            vpDistance[index] = square;

                            if (!(vpBits[index] & ISBOUND)) {

                                vpBits[index] |= ISBOUND;

                                outarray[ positout     ] = tnv_ix;
                                outarray[ positout + 1 ] = tnv_iy;
                                outarray[ positout + 2 ] = tnv_iz;
                                positout += 3;

                            }

                        }

                    }

                }
            }
        }

        // console.log("part3", positout);

        return positout;

    }

    function marchingcubeinit( stype ){

        var n = vpBits.length;

        if( stype === "vws" ) {

            for( var i = 0; i < n; ++i ){

                vpBits[ i ] &= ~ISBOUND;
                vpBits[ i ] = !!( vpBits[ i ] & ISDONE ) ? 1 : 0;

            }

        }else if( stype === "ms" ){  // ses without vdw => ms

            for( var i = 0; i < n; ++i ){

                vpBits[ i ] &= ~ISDONE;
                if( vpBits[ i ] & ISBOUND ){
                    vpBits[ i ] |= ISDONE;
                }
                vpBits[ i ] &= ~ISBOUND;
                vpBits[ i ] = !!( vpBits[ i ] & ISDONE ) ? 1 : 0;

            }

        }else if( stype === "ses" ){

            for( var i = 0; i < n; ++i ){

                if( ( vpBits[ i ] & ISBOUND ) && ( vpBits[ i ] & ISDONE ) ){
                    vpBits[ i ] &= ~ISBOUND;
                }else if( ( vpBits[ i ] & ISBOUND ) && !( vpBits[ i ] & ISDONE ) ){
                    vpBits[ i ] |= ISDONE;
                }
                vpBits[ i ] = !!( vpBits[ i ] & ISDONE ) ? 1 : 0;

            }

        }else if( stype === "sas" ){

            for( var i = 0; i < n; ++i ){

                vpBits[ i ] &= ~ISBOUND;
                vpBits[ i ] = !!( vpBits[ i ] & ISDONE ) ? 1 : 0;

            }

        }

    };

};


NGL.getSurfaceGrid = function( bbox, maxRadius, scaleFactor, extraMargin ){

    // need margin to avoid boundary/round off effects
    var margin = ( 1 / scaleFactor ) * 3;
    margin += maxRadius;

    var min = new THREE.Vector3().copy( bbox.min );
    var max = new THREE.Vector3().copy( bbox.max );

    min.subScalar( extraMargin + margin );
    max.addScalar( extraMargin + margin );

    min.multiplyScalar( scaleFactor ).floor().divideScalar( scaleFactor );
    max.multiplyScalar( scaleFactor ).ceil().divideScalar( scaleFactor );

    var dim = new THREE.Vector3()
        .subVectors( max, min )
        .multiplyScalar( scaleFactor )
        .ceil()
        .addScalar( 1 );

    var maxSize = Math.pow( 10, 6 ) * 256;
    var tmpSize = dim.x * dim.y * dim.z * 3;

    if( maxSize <= tmpSize ){

        scaleFactor *= Math.pow( maxSize / tmpSize, 1/3 );

        min.multiplyScalar( scaleFactor ).floor().divideScalar( scaleFactor );
        max.multiplyScalar( scaleFactor ).ceil().divideScalar( scaleFactor );

        dim.subVectors( max, min )
            .multiplyScalar( scaleFactor )
            .ceil()
            .addScalar( 1 );

    }

    var tran = new THREE.Vector3().copy( min ).negate();

    // coordinate transformation matrix
    var matrix = new THREE.Matrix4();
    matrix.multiply(
        new THREE.Matrix4().makeRotationY( THREE.Math.degToRad( 90 ) )
    );
    matrix.multiply(
        new THREE.Matrix4().makeScale(
            -1 / scaleFactor,
             1 / scaleFactor,
             1 / scaleFactor
        )
    );
    matrix.multiply(
        new THREE.Matrix4().makeTranslation(
            -scaleFactor * tran.z,
            -scaleFactor * tran.y,
            -scaleFactor * tran.x
        )
    );

    return {
        dim: dim,
        tran: tran,
        matrix: matrix,
        scaleFactor: scaleFactor
    };

};

// File:js/ngl/script.js

/**
 * @file Script
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


///////////
// Script

NGL.Script = function( functionBody, name, path ){

    var SIGNALS = signals;

    this.signals = {

        elementAdded: new SIGNALS.Signal(),
        nameChanged: new SIGNALS.Signal(),

    };

    this.name = name;
    this.path = path;
    this.dir = path.substring( 0, path.lastIndexOf( '/' ) + 1 );

    try {

        this.fn = new Function(

            'stage', 'panel',
            '__name__', '__path__', '__dir__',

            Object.keys( NGL.makeScriptHelper() ).join( ',' ),

            functionBody

        );

    }catch( e ){

        NGL.error( "NGL.Script compilation failed", e );
        this.fn = null;

    }

}

NGL.Script.prototype = {

    constructor: NGL.Script,

    call: function( stage, onFinish ){

        var panel = {

            add: function( element ){

                this.signals.elementAdded.dispatch( arguments );

            }.bind( this ),

            setName: function( value ){

                this.signals.nameChanged.dispatch( value );

            }.bind( this )

        };

        var queue = new NGL.ScriptQueue( stage, this.dir, onFinish );
        var helper = NGL.makeScriptHelper( stage, queue, panel );

        if( this.fn ){

            var args = [
                stage, panel,
                this.name, this.path, this.dir
            ];

            try{

                var fnList = [];
                Object.keys( helper ).forEach( function( name ){
                    fnList.push( helper[ name ] );
                } );

                this.fn.apply(
                    null, args.concat( fnList )
                );

            }catch( e ){

                NGL.error( "NGL.Script.fn", e );

            }

        }else{

            NGL.log( "NGL.Script.call no function available" );

        }

        function finish(){
            if( typeof onFinish === "function" ) onFinish();
        }

        function error(){
            panel.add( new UI.Text( "ERROR" ) );
            finish();
        }

        queue.then( finish, error );

    }

}


NGL.ScriptQueue = function( stage, dir, onFinish ){

    this.stage = stage;
    this.dir = dir || "";
    this.onFinish = onFinish;

    this.promise = new Promise( function( resolve, reject ){

        resolve();

    } );

};

NGL.ScriptQueue.prototype = {

    constructor: NGL.ScriptQueue,

    load: function( file, params ){

        var status = {};

        // TODO check for pdbid or http...
        var path = this.dir + file;

        var _onLoad;
        var p = params || {};

        // allow loadFile( path, onLoad ) method signature
        if( typeof params === "function" ){

            _onLoad = params;
            p = {};

        }else{

            _onLoad = p.onLoad;

        }

        p.onLoad = function( component ){

            component.requestGuiVisibility( false );

            if( typeof _onLoad === "function" ){
                _onLoad( component );
            }

            if( status.resolve ){
                status.resolve();
            }else{
                status.success = true;
            }

        };

        p.onError = function( e ){

            if( status.reject ){
                status.reject( e );
            }else{
                status.error = e || "error";
            }

        };

        this.stage.loadFile( path, p );

        var handle = function( resolve, reject ){

            if( status.success === true ){
                resolve();
            }else if( status.error !== undefined ){
                reject( status.error );
            }else{
                status.resolve = resolve;
                status.reject = reject;
            }

        };

        this.promise = this.promise.then( function(){

            return new Promise( handle );

        } );

    },

    then: function( callback, onError ){

        this.promise = this.promise.then( callback, function( e ){

            NGL.error( "NGL.ScriptQueue.then", e );

            if( typeof onError === "function" ) onError();

        } );

    }

};


NGL.makeScriptHelper = function( stage, queue, panel ){

    var U = NGL.unicodeHelper;

    //

    function load(){

        queue.load.apply( queue, arguments );

    }

    function then(){

        queue.then.apply( queue, arguments );

    }

    //

    function components( name ){

        return stage.getComponentsByName( name );

    }

    function representations( name ){

        return stage.getRepresentationsByName( name );

    }

    function structures( name ){

        return stage.getComponentsByName( name, NGL.StructureComponent );

    }

    //

    function color( value, collection ){

        collection.setColor( value );

    }

    function visibility( value, collection ){

        collection.setVisibility( value );

    }

    function hide( collection ){

        visibility( false, collection );

    }

    function show( collection, only ){

        if( only ) hide();

        visibility( true, collection );

    }

    function superpose( comp1, comp2, align, sele1, sele2, xsele1, xsele2 ){

        comp1.superpose( comp2, align, sele1, sele2, xsele1, xsele2 );

    }

    //

    function uiText( text, newline ){

        var elm = new UI.Text( U( text ) );

        panel.add( elm );

        if( newline ) uiBreak( 1 );

        return elm;

    }

    function uiHtml( html, newline ){

        var elm = new UI.Html( U( html ) );

        panel.add( elm );

        if( newline ) uiBreak( 1 );

        return elm;

    }

    function uiBreak( n ){

        n = n === undefined ? 1 : n;

        for( var i = 0; i < n; ++i ){

            panel.add( new UI.Break() );

        }

    }

    function uiButton( label, callback ){

        var btn = new UI.Button( U( label ) ).onClick( function(){
            callback( btn );
        } );

        panel.add( btn );

        return btn;

    }

    function uiSelect( options, callback ){

        if( Array.isArray( options ) ){
            var newOptions = {};
            options.forEach( function( name ){
                newOptions[ name ] = name;
            } );
            options = newOptions;
        }

        var select = new UI.Select()
            .setOptions( options )
            .onChange( function(){
                callback( select );
            } );

        panel.add( select );

        return select;

    }

    function uiOpenButton( label, callback, extensionList ){

        var btn = new UI.Button( U( label ) ).onClick( function(){

            NGL.open( callback, extensionList );

        } );

        panel.add( btn );

        return btn;

    }

    function uiDownloadButton( label, callback, downloadName ){

        var btn = new UI.Button( U( label ) ).onClick( function(){

            NGL.download( callback(), downloadName );

        } );

        panel.add( btn );

        return btn;

    }

    function uiVisibilitySelect( collection ){

        var list = collection.list;

        function getVisible(){

            var nameList = [];

            list.forEach( function( o ){

                if( o.visible ) nameList.push( o.name );

            } );

            return nameList;

        }

        var options = { "": "[show]" };

        list.forEach( function( o ){

            options[ o.name ] = o.name;

            o.signals.visibilityChanged.add( function(){

                var nameList = getVisible();

                if( nameList.length === list.length ){
                    select.setValue( "" );
                }else if( o.visible ){
                    select.setValue( o.name );
                }else{
                    select.setValue( nameList[ 0 ] );
                }

            } );

        } );

        var select = new UI.Select()
            .setOptions( options )
            .onChange( function(){

                var name = select.getValue();

                if( name === "" ){
                    show( collection );
                }else{
                    hide( collection );
                    show( stage.getAnythingByName( name ) );
                }

            } );

        panel.add( select );

        return select;

    }

    function uiVisibilityButton( label, collection ){

        label = U( label ? label : "all" );
        collection = collection || new NGL.Collection();

        if( !( collection instanceof NGL.Collection ) &&
            !( collection instanceof NGL.ComponentCollection ) &&
            !( collection instanceof NGL.RepresentationCollection )
        ){
            collection = new NGL.Collection( [ collection ] );
        }

        var list = collection.list;

        function isVisible(){

            var visible = false;

            list.forEach( function( o ){

                if( o.visible ) visible = true;

            } );

            return visible;

        }

        function getLabel( value ){

            return ( isVisible() ? "hide " : "show " ) + label;

        }

        list.forEach( function( o ){

            o.signals.visibilityChanged.add( function(){

                btn.setLabel( getLabel() );

            } );

        } );

        var btn = new UI.Button( getLabel() ).onClick( function(){

            visibility( !isVisible(), collection );

        } );

        // panel.add( btn );

        return btn;

    }

    function uiPlayButton( label, trajComp, step, timeout, start, end ){

        var traj = trajComp.trajectory;
        label = U( label );

        var player = new NGL.TrajectoryPlayer( traj, step, timeout, start, end );
        player.mode = "once";

        var btn = new UI.Button( "play " + label )
            .onClick( function(){
                player.toggle();
            } );

        player.signals.startedRunning.add( function(){
            btn.setLabel( "pause " + label );
        } );

        player.signals.haltedRunning.add( function(){
            btn.setLabel( "play " + label );
        } );

        panel.add( btn );

        return btn;

    }

    //

    return {

        'load': load,
        'then': then,

        'components': components,
        'representations': representations,
        'structures': structures,

        'color': color,
        'visibility': visibility,
        'hide': hide,
        'show': show,
        'superpose': superpose,

        'uiText': uiText,
        'uiHtml': uiHtml,
        'uiBreak': uiBreak,
        'uiSelect': uiSelect,
        'uiButton': uiButton,
        'uiOpenButton': uiOpenButton,
        'uiDownloadButton': uiDownloadButton,
        'uiVisibilitySelect': uiVisibilitySelect,
        'uiVisibilityButton': uiVisibilityButton,
        'uiPlayButton': uiPlayButton,

    };

};

// File:js/ngl/streamer.js

/**
 * @file Streamer
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


/////////////
// Streamer

NGL.Streamer = function( src, params ){

    var p = params || {};

    this.compressed = p.compressed !== undefined ? p.compressed : false;

    this.src = src;
    this.chunkSize = 1024 * 1024 * 10;
    this.newline = "\n";

    this.__pointer = 0;
    this.__partialLine = "";

    if( this.__srcName ){
        this[ this.__srcName ] = src;
    }

};

NGL.Streamer.prototype.constructor = NGL.Streamer;

NGL.Streamer.prototype = {

    constructor: NGL.Streamer,

    type: "",

    __srcName: undefined,

    onload: function(){},

    onprogress: function(){},

    onerror: function(){},

    read: function( callback ){

        this._read( function( data ){

            if( this.compressed ){

                NGL.decompressWorker(

                    // TODO find better way to specify compression
                    data, "foo." + this.compressed, true,

                    function( decompressedData ){

                        this.data = decompressedData;
                        if( typeof this.onload === "function" ){
                            this.onload( this.data );
                        }
                        callback();

                    }.bind( this )

                );

            }else{

                if( data instanceof ArrayBuffer ){
                    data = new Uint8Array( data );
                }

                this.data = data;
                if( typeof this.onload === "function" ){
                    this.onload( this.data );
                }
                callback();

            }

        }.bind( this ) );

    },

    _read: function( callback ){

        // overwrite this method when this.src does not contain the data

        callback( this.src );

    },

    _chunk: function( start, end ){

        // overwrite this method when this.data is no Uint8Array

        return this.data.subarray( start, end );

    },

    chunk: function( start ){

        var end = start + this.chunkSize;

        return this._chunk( start, end );

    },

    peekLines: function( m ){

        var data = this.data;
        var n = data.length;

        // FIXME does not work for multi-char newline
        var newline = this.newline.charCodeAt( 0 );

        var i;
        var count = 0;

        for( i = 0; i < n; ++i ){

            if( data[ i ] === newline ) ++count;
            if( count === m ) break;

        }

        var chunk = this._chunk( 0, i + 1 );
        var d = this.chunkToLines( chunk, "", i > n );

        return d.lines;

    },

    lineCount: function(){

        var data = this.data;
        var n = data.length;

        // FIXME does not work for multi-char newline
        var newline = this.newline.charCodeAt( 0 );

        var count = 0;

        for( var i = 0; i < n; ++i ){

            if( data[ i ] === newline ) ++count;

        }

        if( data[ n - 1 ] !== newline ) ++count;

        return count;

    },

    chunkCount: function(){

        return Math.floor( this.data.length / this.chunkSize ) + 1;

    },

    asText: function(){

        return NGL.Uint8ToString( this.data );

    },

    chunkToLines: function( chunk, partialLine, isLast ){

        var newline = this.newline;
        var str = NGL.Uint8ToString( chunk );
        var lines = [];
        var idx = str.lastIndexOf( newline );

        if( idx === -1 ){

            partialLine += str;

        }else{

            var str2 = partialLine + str.substr( 0, idx );
            lines = lines.concat( str2.split( newline ) );

            if( idx === str.length - newline.length ){

                partialLine = "";

            }else{

                partialLine = str.substr( idx + newline.length );

            }

        }

        if( isLast && partialLine !== "" ){

            lines.push( partialLine );

        }

        return {

            lines: lines,
            partialLine: partialLine

        };

    },

    nextChunk: function(){

        var start = this.__pointer;

        if( start > this.data.length ){

            return undefined;

        }

        this.__pointer += this.chunkSize;
        return this.chunk( start );

    },

    nextChunkOfLines: function(){

        var chunk = this.nextChunk();

        if( chunk === undefined ){

            return undefined;

        }

        var isLast = this.__pointer > this.data.length;
        var d = this.chunkToLines( chunk, this.__partialLine, isLast );

        this.__partialLine = d.partialLine;

        return d.lines;

    },

    eachChunk: function( callback ){

        var chunkSize = this.chunkSize;
        var n = this.data.length;
        var chunkCount = this.chunkCount();

        for( var i = 0; i < n; i += chunkSize ){

            var chunk = this.chunk( i );
            var chunkNo = Math.round( i / chunkSize );

            callback( chunk, chunkNo, chunkCount );

        }

    },

    eachChunkOfLines: function( callback ){

        var newline = this.newline;
        var partialLine = "";

        this.eachChunk( function( chunk, chunkNo, chunkCount ){

            var isLast = chunkNo === chunkCount + 1;
            var d = this.chunkToLines( chunk, partialLine, isLast );

            partialLine = d.partialLine;

            callback( d.lines, chunkNo, chunkCount );

        }.bind( this ) );

    },

    eachChunkOfLinesAsync: function( callback, onfinish ){

        var self = this;

        async.timesSeries(

            self.chunkCount(),

            function( i, wcallback ){

                NGL.processArray(
                    self.nextChunkOfLines(),
                    callback,
                    wcallback
                );

            },

            onfinish

        );

    },

    toJSON: function(){

        var type = this.type.substr( 0, 1 ).toUpperCase() +
                    this.type.substr( 1 );

        var output = {

            metadata: {
                version: 0.1,
                type: type + 'Streamer',
                generator: type + 'StreamerExporter'
            },

            src: this.src,
            compressed: this.compressed,
            chunkSize: this.chunkSize,
            newline: this.newline,



        }

        if( this.__srcName ){
            output[ this.__srcName ] = this[ this.__srcName ];
        }

        return output;

    },

    fromJSON: function( input ){

        this.src = input.src;
        this.compressed = input.compressed;
        this.chunkSize = input.chunkSize;
        this.newline = input.newline;

        if( this.__srcName ){
            this[ this.__srcName ] = input[ this.__srcName ];
        }

        return this;

    },

    getTransferable: function(){

        var transferable = [];

        return transferable;

    },

    dispose: function(){

        delete this.src;

        if( this.__srcName ){
            delete this[ this.__srcName ];
        }

    }

};


NGL.NetworkStreamer = function( url, params ){

    NGL.Streamer.call( this, url, params );

};

NGL.NetworkStreamer.prototype = NGL.createObject(

    NGL.Streamer.prototype, {

    constructor: NGL.NetworkStreamer,

    type: "network",

    __srcName: "url",

    _read: function( callback ){

        var url = this.src;

        if( typeof importScripts === 'function' ){

            // FIXME
            // adjust relative path when inside a web worker
            if( url.substr( 0, 3 ) === "../" ) url = "../" + url;

        }

        var xhr = new XMLHttpRequest();
        xhr.open( "GET", url, true );

        //

        xhr.addEventListener( 'load', function ( event ) {

            if( xhr.status === 200 || xhr.status === 304 ||
                // when requesting from local file system
                // the status in Google Chrome/Chromium is 0
                xhr.status === 0
             ){

                callback( xhr.response );

            } else {

                if( typeof this.onerror === "function" ){

                    this.onerror( xhr.status );

                }

                throw "NGL.NetworkStreamer._read: status code " + xhr.status;

            }

        }.bind( this ), false );

        //

        if( typeof this.onprogress === "function" ){

            xhr.addEventListener( 'progress', function ( event ) {

                this.onprogress( event );

            }.bind( this ), false );

        }

        //

        if( typeof this.onerror === "function" ){

            xhr.addEventListener( 'error', function ( event ) {

                this.onerror( event );

            }.bind( this ), false );

        }

        //

        xhr.responseType = "arraybuffer";
        // xhr.crossOrigin = true;

        try {

            xhr.send( null );

        }catch( e ){

            if( typeof this.onerror === "function" ){

                this.onerror( e.message );

            }

        }

    }

} );


NGL.FileStreamer = function( file, params ){

    NGL.Streamer.call( this, file, params );

};

NGL.FileStreamer.prototype = NGL.createObject(

    NGL.Streamer.prototype, {

    constructor: NGL.FileStreamer,

    type: "file",

    __srcName: "file",

    _read: function( callback ){

        if( typeof importScripts === 'function' ){

            // Use FileReaderSync within Worker

            var reader = new FileReaderSync();
            var data = reader.readAsArrayBuffer( this.file );

            //

            callback( data );

        }else{

            var reader = new FileReader();

            //

            reader.onload = function( event ){

                callback( event.target.result );

            }.bind( this );

            //

            if( typeof this.onprogress === "function" ){

                reader.onprogress = function ( event ) {

                    this.onprogress( event );

                }.bind( this );

            }

            //

            if( typeof this.onerror === "function" ){

                reader.onerror = function ( event ) {

                    this.onerror( event );

                }.bind( this );

            }

            //

            reader.readAsArrayBuffer( this.file );

        }

    }

} );


NGL.StringStreamer = function( str, params ){

    NGL.Streamer.call( this, str, params );

};

NGL.StringStreamer.prototype = NGL.createObject(

    NGL.Streamer.prototype, {

    constructor: NGL.StringStreamer,

    type: "string",

    __srcName: "str",

    _chunk: function( start, end ){

        return this.data.substr( start, end );

    },

} );


NGL.BinaryStreamer = function( bin, params ){

    if( bin instanceof ArrayBuffer ) bin = new Uint8Array( bin );

    NGL.Streamer.call( this, bin, params );

};

NGL.BinaryStreamer.prototype = NGL.createObject(

    NGL.Streamer.prototype, {

    constructor: NGL.BinaryStreamer,

    type: "binary",

    __srcName: "bin",

    getTransferable: function(){

        var transferable = NGL.Streamer.prototype.getTransferable.call( this );

        if( this.bin instanceof Uint8Array ){
            transferable.push( this.bin.buffer );
        }

        return transferable;

    }

} );

// File:js/ngl/parser.js

/**
 * @file Parser
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


NGL.atomArrayQuicksort = function( atomArray, compareFunction ){

    NGL.time( "NGL.atomArrayQuicksort" );

    var tmpAtom = new NGL.Atom();
    var proxyAtom1 = new NGL.ProxyAtom( atomArray );
    var proxyAtom2 = new NGL.ProxyAtom( atomArray );

    function cmp( index1, index2 ){
        proxyAtom1.index = index1;
        proxyAtom2.index = index2;
        return compareFunction( proxyAtom1, proxyAtom2 );
    }

    function swap( index1, index2 ){
        if( index1 === index2 ) return;
        proxyAtom1.index = index1;
        proxyAtom2.index = index2;
        tmpAtom.copy( proxyAtom1 );
        proxyAtom1.copy( proxyAtom2 );
        proxyAtom2.copy( tmpAtom );
    }

    function quicksort( left, right ){
        if( left < right ){
            var pivot = Math.floor( ( left + right ) / 2 );
            var left_new = left;
            var right_new = right;
            do{
                while( cmp( left_new, pivot ) < 0 ){
                    left_new += 1;
                }
                while( cmp( right_new, pivot ) > 0 ){
                    right_new -= 1;
                }
                if( left_new <= right_new ){
                    if( left_new === pivot ){
                        pivot = right_new;
                    }else if( right_new === pivot ){
                        pivot = left_new;
                    }
                    swap( left_new, right_new );
                    left_new += 1;
                    right_new -= 1;
                }
            }while( left_new <= right_new );
            quicksort( left, right_new );
            quicksort( left_new, right );
        }
    }

    quicksort( 0, atomArray.usedLength - 1 );

    NGL.timeEnd( "NGL.atomArrayQuicksort" );

};


NGL.reorderAtoms = function( structure ){

    NGL.time( "NGL.reorderAtoms" );

    var atoms = structure.atoms;
    var atomArray = structure.atomArray;

    function compareModelChainResno( a1, a2 ){

        if( a1.modelindex < a2.modelindex ){
            return -1;
        }else if( a1.modelindex > a2.modelindex ){
            return 1;
        }else{
            if( a1.chainname < a2.chainname ){
                return -1;
            }else if( a1.chainname > a2.chainname ){
                return 1;
            }else{
                if( a1.resno < a2.resno ){
                    return -1;
                }else if( a1.resno > a2.resno ){
                    return 1;
                }else{
                    return 0;
                }
            }
        }

    }

    if( atomArray ){
        NGL.atomArrayQuicksort( atomArray, compareModelChainResno );
    }else{
        atoms.sort( compareModelChainResno );
    }

    for( var i = 0, il = atoms.length; i < il; ++i ){
        atoms[ i ].index = i;
    }

    NGL.timeEnd( "NGL.reorderAtoms" );

};


NGL.buildStructure = function( structure, callback ){

    NGL.time( "NGL.buildStructure" );

    var m, c, r, a;
    var i, chainDict;

    var currentModelindex = null;
    var currentChainname;
    var currentResno;

    function _chunked( _i, _n, atoms ){

        for( i = _i; i < _n; ++i ){

            a = atoms[ i ];

            var modelindex = a.modelindex;
            var chainname = a.chainname;
            var resno = a.resno;
            var resname = a.resname;

            if( currentModelindex!==modelindex ){

                m = structure.addModel();

                chainDict = {};

                c = m.addChain();
                c.chainname = chainname;
                chainDict[ chainname ] = c;

                r = c.addResidue();
                r.resno = resno;
                r.resname = resname;

            }else if( currentChainname!==chainname ){

                if( !chainDict[ chainname ] ){

                    c = m.addChain();
                    c.chainname = chainname;
                    chainDict[ chainname ] = c;

                }else{

                    c = chainDict[ chainname ];

                }

                r = c.addResidue();
                r.resno = resno;
                r.resname = resname;

            }else if( currentResno!==resno ){

                r = c.addResidue();
                r.resno = resno;
                r.resname = resname;

            }

            r.addAtom( a );

            // seems to slow down Chrome
            // delete a.modelindex;

            currentModelindex = modelindex;
            currentChainname = chainname;
            currentResno = resno;

        }

    }

    NGL.processArray(

        structure.atoms,

        _chunked,

        function(){

            NGL.GidPool.updateObject( structure );

            NGL.timeEnd( "NGL.buildStructure" );

            if( NGL.debug ) NGL.log( structure );

            callback();

        }

    );

    return structure;

};


NGL.createAtomArray = function( structure, callback ){

    NGL.time( "NGL.createAtomArray" );

    var s = structure;
    var atoms = s.atoms;
    var n = atoms.length;

    s.atomArray = new NGL.AtomArray( n );
    var atomArray = s.atomArray;

    function _chunked( _i, _n ){

        for( var i = _i; i < _n; ++i ){

            var ai = atoms[ i ];

            var a = new NGL.ProxyAtom( atomArray, i );

            atomArray.setResname( i, ai.resname );
            atomArray.x[ i ] = ai.x;
            atomArray.y[ i ] = ai.y;
            atomArray.z[ i ] = ai.z;
            atomArray.setElement( i, ai.element );
            atomArray.hetero[ i ] = ai.hetero;
            atomArray.setChainname( i, ai.chainname );
            atomArray.resno[ i ] = ai.resno;
            atomArray.serial[ i ] = ai.serial;
            atomArray.setAtomname( i, ai.atomname );
            atomArray.ss[ i ] = ai.ss.charCodeAt( 0 );
            atomArray.bfactor[ i ] = ai.bfactor;
            atomArray.altloc[ i ] = ai.altloc.charCodeAt( 0 );
            atomArray.vdw[ i ] = ai.vdw;
            atomArray.covalent[ i ] = ai.covalent;
            atomArray.modelindex[ i ] = ai.modelindex;

            atomArray.usedLength += 1;

            // set proxy atoms in already existing bonds

            if( ai.bonds.length ){

                a.bonds = ai.bonds;

                a.bonds.forEach( function( b ){

                    if( b.atom1.index === a.index ){
                        b.atom1 = a;
                    }else if( b.atom2.index === a.index ){
                        b.atom2 = a;
                    }else{
                        NGL.warn(
                            "NGL.createAtomArray: bond atom not found"
                        );
                    }

                } );

            }

            atoms[ i ] = a;

        }

    }

    NGL.processArray(

        atoms,

        _chunked,

        function(){

            NGL.timeEnd( "NGL.createAtomArray" );

            callback();

        },

        50000

    );

    return structure;

};


NGL.assignSecondaryStructure = function( structure, callback ){

    NGL.time( "NGL.assignSecondaryStructure" );

    var chainnames = [];
    structure.eachModel( function( m ){
        m.eachChain( function( c ){
            chainnames.push( c.chainname );
        } );
    } );

    var chainnamesSorted = chainnames.slice().sort();
    var chainnamesIndex = [];
    chainnamesSorted.forEach( function( c ){
        chainnamesIndex.push( chainnames.indexOf( c ) );
    } );

    // helix assignment

    var helices = structure.helices || [];

    helices.sort( function( h1, h2 ){

        var c1 = h1[ 0 ];
        var c2 = h2[ 0 ];
        var r1 = h1[ 1 ];
        var r2 = h2[ 1 ];

        if( c1 === c2 ){
            if( r1 === r2 ){
                return 0;
            }else{
                return r1 < r2 ? -1 : 1;
            }
        }else{
            var idx1 = NGL.binarySearchIndexOf( chainnamesSorted, c1 );
            var idx2 = NGL.binarySearchIndexOf( chainnamesSorted, c2 );
            return chainnamesIndex[ idx1 ] < chainnamesIndex[ idx2 ] ? -1 : 1;
        }

    } );

    structure.eachModel( function( m ){

        var i = 0;
        var n = helices.length;
        if( n === 0 ) return;
        var helix = helices[ i ];
        var helixRun = false;
        var done = false;

        m.eachChain( function( c ){

            var chainChange = false;

            if( c.chainname === helix[ 0 ] ){

                var j = 0;
                var m = c.residueCount;

                for( j = 0; j < m; ++j ){

                    var r = c.residues[ j ];

                    if( r.resno === helix[ 1 ] ){  // resnoBeg
                        helixRun = true;
                    }

                    if( helixRun ){

                        r.ss = helix[ 4 ];

                        if( r.resno === helix[ 3 ] ){  // resnoEnd

                            helixRun = false
                            i += 1;

                            if( i < n ){
                                // must look at previous residues as
                                // residues may not be ordered by resno
                                j = -1;
                                helix = helices[ i ];
                                chainChange = c.chainname !== helix[ 0 ];
                            }else{
                                done = true;
                            }

                        }

                    }

                    if( chainChange || done ) return;

                }

            }

        } );

    } );

    // sheet assignment

    var sheets = structure.sheets || [];

    sheets.sort( function( s1, s2 ){

        var c1 = s1[ 0 ];
        var c2 = s2[ 0 ];

        if( c1 === c2 ) return 0;
        var idx1 = NGL.binarySearchIndexOf( chainnamesSorted, c1 );
        var idx2 = NGL.binarySearchIndexOf( chainnamesSorted, c2 );
        return chainnamesIndex[ idx1 ] < chainnamesIndex[ idx2 ] ? -1 : 1;

    } );

    structure.eachModel( function( m ){

        var i = 0;
        var n = sheets.length;
        if( n === 0 ) return;
        var sheet = sheets[ i ];
        var sheetRun = false;
        var done = false;

        m.eachChain( function( c ){

            var chainChange = false;

            if( c.chainname === sheet[ 0 ] ){

                var j = 0;
                var m = c.residueCount;

                for( j = 0; j < m; ++j ){

                    var r = c.residues[ j ];

                    if( r.resno === sheet[ 1 ] ){  // resnoBeg
                        sheetRun = true;
                    }

                    if( sheetRun ){

                        r.ss = "s";

                        if( r.resno === sheet[ 3 ] ){  // resnoEnd

                            sheetRun = false
                            i += 1;

                            if( i < n ){
                                // must look at previous residues as
                                // residues may not be ordered by resno
                                j = -1;
                                sheet = sheets[ i ];
                                chainChange = c.chainname !== sheet[ 0 ];
                            }else{
                                done = true;
                            }

                        }

                    }

                    if( chainChange || done ) return;

                }

            }

        } );

    } );

    NGL.timeEnd( "NGL.assignSecondaryStructure" );

    callback();

    return structure;

};


NGL.buildUnitcellAssembly = function( structure, callback ){

    var uc = structure.unitcell;
    var biomolDict = structure.biomolDict;

    var centerFrac = structure.atomCenter().applyMatrix4( uc.cartToFrac );
    var symopDict = NGL.getSymmetryOperations( uc.spacegroup );

    var positionFrac = new THREE.Vector3();
    var centerFracSymop = new THREE.Vector3();
    var positionFracSymop = new THREE.Vector3();

    if( centerFrac.x > 1 ) positionFrac.x -= 1;
    if( centerFrac.x < 0 ) positionFrac.x += 1;
    if( centerFrac.y > 1 ) positionFrac.y -= 1;
    if( centerFrac.y < 0 ) positionFrac.y += 1;
    if( centerFrac.z > 1 ) positionFrac.z -= 1;
    if( centerFrac.z < 0 ) positionFrac.z += 1;

    function getOpDict( shift, suffix ){

        suffix = suffix || "";
        var opDict = {};

        Object.keys( symopDict ).forEach( function( name ){

            var m = symopDict[ name ].clone();

            centerFracSymop.copy( centerFrac ).applyMatrix4( m );
            positionFracSymop.setFromMatrixPosition( m );
            positionFracSymop.sub( positionFrac );

            if( centerFracSymop.x > 1 ) positionFracSymop.x -= 1;
            if( centerFracSymop.x < 0 ) positionFracSymop.x += 1;
            if( centerFracSymop.y > 1 ) positionFracSymop.y -= 1;
            if( centerFracSymop.y < 0 ) positionFracSymop.y += 1;
            if( centerFracSymop.z > 1 ) positionFracSymop.z -= 1;
            if( centerFracSymop.z < 0 ) positionFracSymop.z += 1;

            if( shift ) positionFracSymop.add( shift );

            m.setPosition( positionFracSymop );
            m.multiplyMatrices( uc.fracToCart, m );
            m.multiply( uc.cartToFrac );

            opDict[ name + suffix ] = m;

        } );

        return opDict;

    }

    biomolDict[ "UNITCELL" ] = {
        matrixDict: getOpDict(),
        chainList: undefined
    };

    biomolDict[ "SUPERCELL" ] = {
        matrixDict: Object.assign( {},
            getOpDict(),
            getOpDict( new THREE.Vector3(  1,  1,  1 ), "_666" ),
            getOpDict( new THREE.Vector3( -1, -1, -1 ), "_444" ),

            getOpDict( new THREE.Vector3(  1,  0,  0 ), "_655" ),
            getOpDict( new THREE.Vector3(  1,  1,  0 ), "_665" ),
            getOpDict( new THREE.Vector3(  1,  0,  1 ), "_656" ),
            getOpDict( new THREE.Vector3(  0,  1,  0 ), "_565" ),
            getOpDict( new THREE.Vector3(  0,  1,  1 ), "_566" ),
            getOpDict( new THREE.Vector3(  0,  0,  1 ), "_556" ),

            getOpDict( new THREE.Vector3( -1,  0,  0 ), "_455" ),
            getOpDict( new THREE.Vector3( -1, -1,  0 ), "_445" ),
            getOpDict( new THREE.Vector3( -1,  0, -1 ), "_454" ),
            getOpDict( new THREE.Vector3(  0, -1,  0 ), "_545" ),
            getOpDict( new THREE.Vector3(  0, -1, -1 ), "_544" ),
            getOpDict( new THREE.Vector3(  0,  0, -1 ), "_554" ),

            getOpDict( new THREE.Vector3(  1, -1, -1 ), "_644" ),
            getOpDict( new THREE.Vector3(  1,  1, -1 ), "_664" ),
            getOpDict( new THREE.Vector3(  1, -1,  1 ), "_646" ),
            getOpDict( new THREE.Vector3( -1,  1,  1 ), "_466" ),
            getOpDict( new THREE.Vector3( -1, -1,  1 ), "_446" ),
            getOpDict( new THREE.Vector3( -1,  1, -1 ), "_464" ),

            getOpDict( new THREE.Vector3(  0,  1, -1 ), "_564" ),
            getOpDict( new THREE.Vector3(  0, -1,  1 ), "_546" ),
            getOpDict( new THREE.Vector3(  1,  0, -1 ), "_654" ),
            getOpDict( new THREE.Vector3( -1,  0,  1 ), "_456" ),
            getOpDict( new THREE.Vector3(  1, -1,  0 ), "_645" ),
            getOpDict( new THREE.Vector3( -1,  1,  0 ), "_465" )
        ),
        chainList: undefined
    };

    callback();

    return structure;

}


///////////
// Parser

NGL.WorkerRegistry.add( "parse", function( e, callback ){

    NGL.time( "WORKER parse" );

    var parser = NGL.fromJSON( e.data );

    parser.parse( function(){

        NGL.timeEnd( "WORKER parse" );

        // no need to return the streamer data
        parser.streamer.dispose();

        callback( parser.toJSON(), parser.getTransferable() );

    } );

} );


NGL.Parser = function( streamer, params ){

    var p = params || {};

    this.streamer = streamer;

    this.name = p.name;
    this.path = p.path;

};

NGL.Parser.prototype = {

    constructor: NGL.Parser,

    type: "",

    __objName: "",

    parse: function( callback ){

        var self = this;

        async.series( [

            function( wcallback ){

                self.streamer.read( wcallback );

            },

            function( wcallback ){

                self._beforeParse( wcallback );

            },

            function( wcallback ){

                self._parse( wcallback );

            },

            function( wcallback ){

                self._afterParse( wcallback );

            }

        ], function(){

            callback( this[ this.__objName ] );

        }.bind( this ) );

        return this[ this.__objName ];

    },

    parseWorker: function( callback ){

        if( NGL.useWorker && typeof Worker !== "undefined" &&
            typeof importScripts !== 'function'
        ){

            var worker = new NGL.Worker( "parse" ).post(

                this.toJSON(),

                this.getTransferable(),

                function( e ){

                    worker.terminate();

                    this.fromJSON( e.data );
                    this._afterWorker( callback );

                }.bind( this ),

                function( e ){

                    console.warn(
                        "NGL.Parser.parseWorker error - trying without worker", e
                    );
                    worker.terminate();

                    this.parse( callback );

                }.bind( this )

            );

        }else{

            this.parse( callback );

        }

        return this[ this.__objName ];

    },

    _parse: function( callback ){

        NGL.warn( "NGL.Parser._parse not implemented" );
        callback();

    },

    _beforeParse: function( callback ){

        callback();

    },

    _afterParse: function( callback ){

        callback();

    },

    _afterWorker: function( callback ){

        callback( this[ this.__objName ] );

    },

    toJSON: function(){

        var type = this.type.substr( 0, 1 ).toUpperCase() +
                    this.type.substr( 1 );

        var output = {

            metadata: {
                version: 0.1,
                type: type + 'Parser',
                generator: type + 'ParserExporter'
            },

            streamer: this.streamer.toJSON(),
            name: this.name,
            path: this.path,

        }

        if( typeof this[ this.__objName ].toJSON === "function" ){

            output[ this.__objName ] = this[ this.__objName ].toJSON();

        }else{

            output[ this.__objName ] = this[ this.__objName ];

        }

        return output;

    },

    fromJSON: function( input ){

        this.streamer = NGL.fromJSON( input.streamer );
        this.name = input.name;
        this.path = input.path;

        if( typeof this[ this.__objName ].toJSON === "function" ){

            this[ this.__objName ].fromJSON( input[ this.__objName ] );

        }else{

            this[ this.__objName ] = input[ this.__objName ];

        }

        return this;

    },

    getTransferable: function(){

        var transferable = [];

        transferable = transferable.concat(
            this.streamer.getTransferable()
        );

        if( typeof this[ this.__objName ].toJSON === "function" ){

            transferable = transferable.concat(
                this[ this.__objName ].getTransferable()
            );

        }

        return transferable;

    }

};


////////////////////
// StructureParser

NGL.useAtomArrayThreshold = 1000;

NGL.StructureParser = function( streamer, params ){

    var p = params || {};

    this.firstModelOnly = p.firstModelOnly || false;
    this.asTrajectory = p.asTrajectory || false;
    this.cAlphaOnly = p.cAlphaOnly || false;
    this.reorderAtoms = p.reorderAtoms || false;

    NGL.Parser.call( this, streamer, p );

    this.structure = new NGL.Structure( this.name, this.path );

};

NGL.StructureParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.StructureParser,

    type: "structure",

    __objName: "structure",

    _afterParse: function( callback ){

        var self = this;

        async.series( [

            function( wcallback ){

                if( self.reorderAtoms ){
                    NGL.reorderAtoms( self.structure );
                }

                if( !self.structure.atomArray &&
                    self.structure.atoms.length > NGL.useAtomArrayThreshold
                ){

                    NGL.createAtomArray( self.structure, wcallback );

                }else{

                    wcallback();

                }

            },

            function( wcallback ){

                NGL.buildStructure( self.structure, wcallback );

            },

            function( wcallback ){

                NGL.assignSecondaryStructure( self.structure, wcallback );

            },

            function( wcallback ){

                NGL.buildUnitcellAssembly( self.structure, wcallback );

            },

            function( wcallback ){

                self._postProcess( wcallback );

            },

            function( wcallback ){

                var s = self.structure;

                // check for secondary structure
                if( s.helices.length === 0 && s.sheets.length === 0 ){
                    s._doAutoSS = true;
                }

                // check for chain names
                var _doAutoChainName = true;
                s.eachChain( function( c ){
                    if( c.chainname ) _doAutoChainName = false;
                } );
                s._doAutoChainName = _doAutoChainName;

                self.structure.postProcess( wcallback );

            }

        ], function(){

            callback();

        } );

    },

    _afterWorker: function( callback ){

        NGL.buildStructure( this.structure, function(){

            callback( this[ this.__objName ] )

        }.bind( this ) );

    },

    _postProcess: function( callback ){

        callback();

    },

    toJSON: function(){

        var output = NGL.Parser.prototype.toJSON.call( this );

        output.firstModelOnly = this.firstModelOnly;
        output.asTrajectory = this.asTrajectory;
        output.cAlphaOnly = this.cAlphaOnly;
        output.reorderAtoms = this.reorderAtoms;

        return output;

    },

    fromJSON: function( input ){

        NGL.Parser.prototype.fromJSON.call( this, input );

        this.firstModelOnly = input.firstModelOnly;
        this.asTrajectory = input.asTrajectory;
        this.cAlphaOnly = input.cAlphaOnly;
        this.reorderAtoms = input.reorderAtoms;

        return this;

    },

} );


NGL.PdbParser = function( streamer, params ){

    NGL.StructureParser.call( this, streamer, params );

};

NGL.PdbParser.prototype = NGL.createObject(

    NGL.StructureParser.prototype, {

    constructor: NGL.PdbParser,

    type: "pdb",

    _parse: function( callback ){

        // http://www.wwpdb.org/documentation/file-format.php

        var isPqr = this.type === "pqr";
        var reWhitespace = /\s+/;

        var __timeName = "NGL.PdbParser._parse " + this.name;

        NGL.time( __timeName );

        var s = this.structure;
        var firstModelOnly = this.firstModelOnly;
        var asTrajectory = this.asTrajectory;
        var cAlphaOnly = this.cAlphaOnly;

        var frames = s.frames;
        var boxes = s.boxes;
        var doFrames = false;
        var currentFrame, currentCoord;

        var id = s.id;
        var title = s.title;

        var atoms = s.atoms;
        var bondSet = s.bondSet;
        var helices = s.helices;
        var sheets = s.sheets;
        var biomolDict = s.biomolDict;
        var currentBiomol;

        var guessElem = NGL.guessElement;
        var covRadii = NGL.CovalentRadii;
        var vdwRadii = NGL.VdwRadii;
        var helixTypes = NGL.HelixTypes;

        var line, recordName;
        var serial, chainname, resno, resname,
            atomname, element, hetero, bfactor, altloc;

        var serialDict = {};
        var unitcellDict = {};

        s.hasConnect = false;

        var atomArray;
        var lineCount = this.streamer.lineCount();
        if( lineCount > NGL.useAtomArrayThreshold ){
            atomArray = new NGL.AtomArray( lineCount );
            s.atomArray = atomArray;
        }

        var idx = 0;
        var modelIdx = 0;
        var pendingStart = true;

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                line = lines[ i ];
                recordName = line.substr( 0, 6 );

                if( recordName === 'ATOM  ' || recordName === 'HETATM' ){

                    // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM

                    if( pendingStart ){

                        if( asTrajectory ){

                            if( doFrames ){
                                currentFrame = new Float32Array( atoms.length * 3 );
                                frames.push( currentFrame );
                            }else{
                                currentFrame = [];
                            }
                            currentCoord = 0;

                        }else{

                            if( !firstModelOnly ) serialDict = {};

                        }

                    }

                    pendingStart = false;

                    if( firstModelOnly && modelIdx > 0 ) continue;

                    if( isPqr ){

                        var ls = line.split( reWhitespace );
                        var dd = ls.length === 10 ? 1 : 0;

                        atomname = ls[ 2 ];
                        if( cAlphaOnly && atomname !== 'CA' ) continue;

                        var x = parseFloat( ls[ 6 - dd ] );
                        var y = parseFloat( ls[ 7 - dd ] );
                        var z = parseFloat( ls[ 8 - dd ] );

                    }else{

                        atomname = line.substr( 12, 4 ).trim();
                        if( cAlphaOnly && atomname !== 'CA' ) continue;

                        var x = parseFloat( line.substr( 30, 8 ) );
                        var y = parseFloat( line.substr( 38, 8 ) );
                        var z = parseFloat( line.substr( 46, 8 ) );

                    }

                    if( asTrajectory ){

                        var j = currentCoord * 3;

                        currentFrame[ j + 0 ] = x;
                        currentFrame[ j + 1 ] = y;
                        currentFrame[ j + 2 ] = z;

                        currentCoord += 1;

                        if( doFrames ) continue;

                    }

                    if( isPqr ){

                        serial = parseInt( ls[ 1 ] );
                        element = "";
                        hetero = ( line[ 0 ] === 'H' ) ? 1 : 0;
                        chainname = dd ? "" : ls[ 4 ];
                        resno = parseInt( ls[ 5 - dd ] );
                        resname = ls[ 3 ];
                        bfactor = parseFloat( ls[ 9 - dd ] );  // charge FIXME should be its own field
                        altloc = "";

                    }else{

                        serial = parseInt( line.substr( 6, 5 ) );
                        element = line.substr( 76, 2 ).trim();
                        hetero = ( line[ 0 ] === 'H' ) ? 1 : 0;
                        chainname = line[ 21 ].trim();
                        resno = parseInt( line.substr( 22, 4 ) );
                        // icode = line[ 26 ];  // FIXME currently not supported
                        resname = line.substr( 17, 4 ).trim();
                        bfactor = parseFloat( line.substr( 60, 8 ) );
                        altloc = line[ 16 ].trim();

                    }

                    if( !element ) element = guessElem( atomname );

                    var a;

                    if( atomArray ){

                        a = new NGL.ProxyAtom( atomArray, idx );

                        atomArray.setResname( idx, resname );
                        atomArray.x[ idx ] = x;
                        atomArray.y[ idx ] = y;
                        atomArray.z[ idx ] = z;
                        atomArray.setElement( idx, element );
                        atomArray.hetero[ idx ] = hetero;
                        atomArray.setChainname( idx, chainname );
                        atomArray.resno[ idx ] = resno;
                        atomArray.serial[ idx ] = serial;
                        atomArray.setAtomname( idx, atomname );
                        atomArray.ss[ idx ] = 'c'.charCodeAt( 0 );
                        atomArray.bfactor[ idx ] = bfactor;
                        atomArray.altloc[ idx ] = altloc.charCodeAt( 0 );
                        atomArray.vdw[ idx ] = vdwRadii[ element ];
                        atomArray.covalent[ idx ] = covRadii[ element ];
                        atomArray.modelindex[ idx ] = modelIdx;

                        atomArray.usedLength += 1;

                    }else{

                        a = new NGL.Atom();
                        a.index = idx;

                        a.resname = resname;
                        a.x = x;
                        a.y = y;
                        a.z = z;
                        a.element = element;
                        a.hetero = hetero;
                        a.chainname = chainname;
                        a.resno = resno;
                        a.serial = serial;
                        a.atomname = atomname;
                        a.ss = 'c';
                        a.bfactor = bfactor;
                        a.altloc = altloc;
                        a.vdw = vdwRadii[ element ];
                        a.covalent = covRadii[ element ];
                        a.modelindex = modelIdx;

                    }

                    serialDict[ serial ] = a;

                    idx += 1;
                    atoms.push( a );

                }else if( recordName === 'CONECT' ){

                    var from = serialDict[ parseInt( line.substr( 6, 5 ) ) ];
                    var pos = [ 11, 16, 21, 26 ];

                    if( from === undefined ){
                        // NGL.log( "missing CONNECT serial" );
                        continue;
                    }

                    for( var j = 0; j < 4; ++j ){

                        var to = parseInt( line.substr( pos[ j ], 5 ) );
                        if( Number.isNaN( to ) ) continue;
                        to = serialDict[ to ];
                        if( to === undefined ){
                            // NGL.log( "missing CONNECT serial" );
                            continue;
                        }/*else if( to < from ){
                            // likely a duplicate in standard PDB format
                            // but not necessarily, so better remove duplicates
                            // in a pass after parsing (and auto bonding)
                            continue;
                        }*/

                        bondSet.addBond( from, to );

                    }

                    s.hasConnect = true;

                }else if( recordName === 'HELIX ' ){

                    var startChain = line[ 19 ].trim();
                    var startResi = parseInt( line.substr( 21, 4 ) );
                    var endChain = line[ 31 ].trim();
                    var endResi = parseInt( line.substr( 33, 4 ) );
                    var helixType = parseInt( line.substr( 39, 1 ) );
                    helixType = helixTypes[ helixType ] || helixTypes[""];
                    helices.push([ startChain, startResi, endChain, endResi, helixType ]);

                }else if( recordName === 'SHEET ' ){

                    var startChain = line[ 21 ].trim();
                    var startResi = parseInt( line.substr( 22, 4 ) );
                    var endChain = line[ 32 ].trim();
                    var endResi = parseInt( line.substr( 33, 4 ) );
                    sheets.push([ startChain, startResi, endChain, endResi ]);

                }else if( recordName === 'REMARK' && line.substr( 7, 3 ) === '350' ){

                    if( line.substr( 11, 12 ) === "BIOMOLECULE:" ){

                        var name = line.substr( 23 ).trim();
                        if( /^(0|[1-9][0-9]*)$/.test( name ) ) name = "BU" + name;

                        biomolDict[ name ] = {
                            matrixDict: {},
                            chainList: []
                        };
                        currentBiomol = biomolDict[ name ];

                    }else if( line.substr( 13, 5 ) === "BIOMT" ){

                        var ls = line.split( /\s+/ );

                        var row = parseInt( line[ 18 ] ) - 1;
                        var mat = ls[ 3 ].trim();

                        if( row === 0 ){
                            currentBiomol.matrixDict[ mat ] = new THREE.Matrix4();
                        }

                        var elms = currentBiomol.matrixDict[ mat ].elements;

                        elms[ 4 * 0 + row ] = parseFloat( ls[ 4 ] );
                        elms[ 4 * 1 + row ] = parseFloat( ls[ 5 ] );
                        elms[ 4 * 2 + row ] = parseFloat( ls[ 6 ] );
                        elms[ 4 * 3 + row ] = parseFloat( ls[ 7 ] );

                    }else if(
                        line.substr( 11, 30 ) === 'APPLY THE FOLLOWING TO CHAINS:' ||
                        line.substr( 11, 30 ) === '                   AND CHAINS:'
                    ){

                        line.substr( 41, 30 ).split( "," ).forEach( function( v ){

                            var c = v.trim();
                            if( c ){
                                currentBiomol.chainList.push( c )
                            }

                        } );

                    }

                }else if( recordName === 'HEADER' ){

                    id = line.substr( 62, 4 );

                }else if( recordName === 'TITLE ' ){

                    title += line.substr( 10, 70 ) + "\n";

                }else if( recordName === 'MODEL ' ){

                    pendingStart = true;

                }else if( recordName === 'ENDMDL' || line.substr( 0, 3 ) === 'END' ){

                    if( pendingStart ) continue;

                    if( asTrajectory && !doFrames ){

                        frames.push( new Float32Array( currentFrame ) );
                        doFrames = true;

                    }

                    modelIdx += 1;
                    pendingStart = true;

                }else if( line.substr( 0, 5 ) === 'MTRIX' ){

                    var ls = line.split( /\s+/ );
                    var mat = ls[ 1 ].trim();

                    if( line[ 5 ] === "1" && mat === "1" ){

                        biomolDict[ "NCS" ] = {
                            matrixDict: {},
                            chainList: undefined
                        };
                        currentBiomol = biomolDict[ "NCS" ];

                    }

                    var row = parseInt( line[ 5 ] ) - 1;

                    if( row === 0 ){
                        currentBiomol.matrixDict[ mat ] = new THREE.Matrix4();
                    }

                    var elms = currentBiomol.matrixDict[ mat ].elements;

                    elms[ 4 * 0 + row ] = parseFloat( ls[ 2 ] );
                    elms[ 4 * 1 + row ] = parseFloat( ls[ 3 ] );
                    elms[ 4 * 2 + row ] = parseFloat( ls[ 4 ] );
                    elms[ 4 * 3 + row ] = parseFloat( ls[ 5 ] );

                }else if( line.substr( 0, 5 ) === 'ORIGX' ){

                    if( !unitcellDict.origx ){
                        unitcellDict.origx = new THREE.Matrix4();
                    }

                    var ls = line.split( /\s+/ );
                    var row = parseInt( line[ 5 ] ) - 1;
                    var elms = unitcellDict.origx.elements;

                    elms[ 4 * 0 + row ] = parseFloat( ls[ 1 ] );
                    elms[ 4 * 1 + row ] = parseFloat( ls[ 2 ] );
                    elms[ 4 * 2 + row ] = parseFloat( ls[ 3 ] );
                    elms[ 4 * 3 + row ] = parseFloat( ls[ 4 ] );

                }else if( line.substr( 0, 5 ) === 'SCALE' ){

                    if( !unitcellDict.scale ){
                        unitcellDict.scale = new THREE.Matrix4();
                    }

                    var ls = line.split( /\s+/ );
                    var row = parseInt( line[ 5 ] ) - 1;
                    var elms = unitcellDict.scale.elements;

                    elms[ 4 * 0 + row ] = parseFloat( ls[ 1 ] );
                    elms[ 4 * 1 + row ] = parseFloat( ls[ 2 ] );
                    elms[ 4 * 2 + row ] = parseFloat( ls[ 3 ] );
                    elms[ 4 * 3 + row ] = parseFloat( ls[ 4 ] );

                }else if( recordName === 'CRYST1' ){

                    // CRYST1   55.989   55.989   55.989  90.00  90.00  90.00 P 1           1
                    //  7 - 15       Real(9.3)      a (Angstroms)
                    // 16 - 24       Real(9.3)      b (Angstroms)
                    // 25 - 33       Real(9.3)      c (Angstroms)
                    // 34 - 40       Real(7.2)      alpha         alpha (degrees).
                    // 41 - 47       Real(7.2)      beta          beta (degrees).
                    // 48 - 54       Real(7.2)      gamma         gamma (degrees).
                    // 56 - 66       LString        sGroup        Space group.
                    // 67 - 70       Integer        z             Z value.

                    var a = parseFloat( line.substr( 6, 9 ) );
                    var b = parseFloat( line.substr( 15, 9 ) );
                    var c = parseFloat( line.substr( 24, 9 ) );

                    var alpha = parseFloat( line.substr( 33, 7 ) );
                    var beta = parseFloat( line.substr( 40, 7 ) );
                    var gamma = parseFloat( line.substr( 47, 7 ) );

                    var sGroup = line.substr( 55, 11 ).trim();
                    var z = parseInt( line.substr( 66, 4 ) );

                    var box = new Float32Array( 9 );
                    box[ 0 ] = a;
                    box[ 4 ] = b;
                    box[ 8 ] = c;
                    boxes.push( box );

                    if( modelIdx === 0 ){

                        unitcellDict.a = a;
                        unitcellDict.b = b;
                        unitcellDict.c = c;
                        unitcellDict.alpha = alpha;
                        unitcellDict.beta = beta;
                        unitcellDict.gamma = gamma;
                        unitcellDict.spacegroup = sGroup;

                    }

                }

            }

        }

        this.streamer.eachChunkOfLinesAsync(

            _parseChunkOfLines,

            function(){

                s.unitcell = new NGL.Unitcell(
                    unitcellDict.a,
                    unitcellDict.b,
                    unitcellDict.c,
                    unitcellDict.alpha,
                    unitcellDict.beta,
                    unitcellDict.gamma,
                    unitcellDict.spacegroup,
                    unitcellDict.scale
                );

                NGL.timeEnd( __timeName );
                callback();

            }

        );

    }

} );


NGL.PqrParser = function( streamer, params ){

    NGL.StructureParser.call( this, streamer, params );

};

NGL.PqrParser.prototype = NGL.createObject(

    NGL.PdbParser.prototype, {

    constructor: NGL.PqrParser,

    type: "pqr",

} );


NGL.GroParser = function( streamer, params ){

    NGL.StructureParser.call( this, streamer, params );

    this.structure._doAutoSS = true;
    this.structure._doAutoChainName = true;

};

NGL.GroParser.prototype = NGL.createObject(

    NGL.StructureParser.prototype, {

    constructor: NGL.GroParser,

    type: "gro",

    _parse: function( callback ){

        // http://manual.gromacs.org/current/online/gro.html

        var __timeName = "NGL.GroParser._parse " + this.name;

        NGL.time( __timeName );

        var s = this.structure;
        var firstModelOnly = this.firstModelOnly;
        var asTrajectory = this.asTrajectory;
        var cAlphaOnly = this.cAlphaOnly;

        var frames = s.frames;
        var boxes = s.boxes;
        var doFrames = false;
        var currentFrame, currentCoord;

        var atoms = s.atoms;

        var guessElem = NGL.guessElement;
        var covRadii = NGL.CovalentRadii;
        var vdwRadii = NGL.VdwRadii;

        var firstLines = this.streamer.peekLines( 3 );

        s.title = firstLines[ 0 ].trim();

        // determine number of decimal places
        var ndec = firstLines[ 2 ].length - firstLines[ 2 ].lastIndexOf( "." ) - 1;
        var lpos = 5 + ndec;
        var xpos = 20;
        var ypos = 20 + lpos;
        var zpos = 20 + 2 * lpos;

        //

        var atomname, resname, element, resno, serial;

        var atomCount = parseInt( firstLines[ 1 ] );
        var modelLineCount = atomCount + 3;

        var atomArray;
        var lineCount = this.streamer.lineCount();
        if( lineCount > NGL.useAtomArrayThreshold ){
            atomArray = new NGL.AtomArray( lineCount );
            s.atomArray = atomArray;
        }

        var idx = 0;
        var modelIdx = 0;
        var lineNo = 0;

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                ++lineNo;
                var l = lineNo - 1;

                var line = lines[ i ];

                if( !line ) continue;

                if( l % modelLineCount === 0 ){

                    // NGL.log( "title", line )

                    if( asTrajectory ){

                        currentFrame = new Float32Array( atomCount * 3 );
                        frames.push( currentFrame );
                        currentCoord = 0;

                    }

                }else if( l % modelLineCount === 1 ){

                    // NGL.log( "atomCount", line )

                }else if( l % modelLineCount === modelLineCount - 1 ){

                    var str = line.trim().split( /\s+/ );
                    var box = new Float32Array( 9 );
                    box[ 0 ] = parseFloat( box[ 0 ] ) * 10;
                    box[ 4 ] = parseFloat( box[ 1 ] ) * 10;
                    box[ 8 ] = parseFloat( box[ 2 ] ) * 10;
                    boxes.push( box );

                    if( firstModelOnly ){

                        return true;

                    }

                    modelIdx += 1;

                }else{

                    atomname = line.substr( 10, 5 ).trim();
                    if( cAlphaOnly && atomname !== 'CA' ) continue;

                    var x = parseFloat( line.substr( xpos, lpos ) ) * 10;
                    var y = parseFloat( line.substr( ypos, lpos ) ) * 10;
                    var z = parseFloat( line.substr( zpos, lpos ) ) * 10;

                    if( asTrajectory ){

                        var j = currentCoord * 3;

                        currentFrame[ j + 0 ] = x;
                        currentFrame[ j + 1 ] = y;
                        currentFrame[ j + 2 ] = z;

                        currentCoord += 1;

                        if( l > modelLineCount ) continue;

                    }

                    resname = line.substr( 5, 5 ).trim();
                    element = guessElem( atomname );
                    resno = parseInt( line.substr( 0, 5 ) );
                    serial = parseInt( line.substr( 15, 5 ) );

                    var a;

                    if( atomArray ){

                        a = new NGL.ProxyAtom( atomArray, idx );

                        atomArray.setResname( idx, resname );
                        atomArray.x[ idx ] = x;
                        atomArray.y[ idx ] = y;
                        atomArray.z[ idx ] = z;
                        atomArray.setElement( idx, element );
                        atomArray.setChainname( idx, '' );
                        atomArray.resno[ idx ] = resno;
                        atomArray.serial[ idx ] = serial;
                        atomArray.setAtomname( idx, atomname );
                        atomArray.ss[ idx ] = 'c'.charCodeAt( 0 );
                        atomArray.setAltloc( idx, '' );
                        atomArray.vdw[ idx ] = vdwRadii[ element ];
                        atomArray.covalent[ idx ] = covRadii[ element ];
                        atomArray.modelindex[ idx ] = modelIdx;

                        atomArray.usedLength += 1;

                    }else{

                        a = new NGL.Atom();
                        a.index = idx;

                        a.resname = resname;
                        a.x = x;
                        a.y = y;
                        a.z = z;
                        a.element = element;
                        a.chainname = '';
                        a.resno = resno;
                        a.serial = serial;
                        a.atomname = atomname;
                        a.ss = 'c';
                        a.altloc = '';
                        a.vdw = vdwRadii[ element ];
                        a.covalent = covRadii[ element ];
                        a.modelindex = modelIdx;

                    }

                    idx += 1;
                    atoms.push( a );

                }

            }

        }

        this.streamer.eachChunkOfLinesAsync(

            _parseChunkOfLines,

            function(){

                NGL.timeEnd( __timeName );
                callback();

            }

        );

    }

} );


NGL.CifParser = function( streamer, params ){

    NGL.StructureParser.call( this, streamer, params );

};

NGL.CifParser.prototype = NGL.createObject(

    NGL.StructureParser.prototype, {

    constructor: NGL.CifParser,

    type: "cif",


    _parse: function( callback ){

        // http://mmcif.wwpdb.org/

        var __timeName = "NGL.CifParser._parse " + this.name;

        NGL.time( __timeName );

        var s = this.structure;
        var firstModelOnly = this.firstModelOnly;
        var asTrajectory = this.asTrajectory;
        var cAlphaOnly = this.cAlphaOnly;

        var frames = s.frames;
        var boxes = s.boxes;
        var doFrames = false;
        var currentFrame, currentCoord;

        var title = s.title;
        var atoms = s.atoms;
        var bondSet = s.bondSet;

        var guessElem = NGL.guessElement;
        var covRadii = NGL.CovalentRadii;
        var vdwRadii = NGL.VdwRadii;
        var helixTypes = NGL.HelixTypes;

        var line, recordName;
        var altloc, serial, elem, chainname, resno, resname, atomname, element;

        s.hasConnect = false;

        //

        var reWhitespace = /\s+/;
        var reQuotedWhitespace = /'(.*?)'|"(.*?)"|(\S+)/g;
        var reDoubleQuote = /"/g;

        var cif = {};
        this.cif = cif;

        var pendingString = false;
        var currentString = null;
        var pendingValue = false;
        var pendingLoop = false;
        var loopPointers = [];
        var currentLoopIndex = null;
        var currentCategory = null;
        var currentName = null;
        var first = null;
        var indexList = [];
        var pointerNames = [];

        var label_atom_id, label_alt_id, Cartn_x, Cartn_y, Cartn_z, id,
            type_symbol, label_asym_id,
            // label_seq_id,
            label_comp_id,
            group_PDB, B_iso_or_equiv, auth_seq_id, pdbx_PDB_model_num;

        //

        var atomArray;
        var lineCount = this.streamer.lineCount();
        if( lineCount > NGL.useAtomArrayThreshold ){
            atomArray = new NGL.AtomArray( lineCount );
            s.atomArray = atomArray;
        }

        var idx = 0;
        var modelIdx = 0;
        var modelNum;

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                line = lines[i].trim();

                if( ( !line && !pendingString ) || line[0]==="#" ){

                    // NGL.log( "NEW BLOCK" );

                    pendingString = false;
                    pendingLoop = false;
                    pendingValue = false;
                    loopPointers.length = 0;
                    currentLoopIndex = null;
                    currentCategory = null;
                    currentName = null;
                    first = null;
                    indexList.length = 0;
                    pointerNames.length = 0;

                }else if( line.substring( 0, 5 )==="data_" ){

                    var data = line.substring( 5 );

                    // NGL.log( "DATA", data );

                }else if( line[0]===";" ){

                    if( pendingString ){

                        // NGL.log( "STRING END", currentString );

                        if( pendingLoop ){

                            if( currentLoopIndex === loopPointers.length ){
                                currentLoopIndex = 0;
                            }
                            loopPointers[ currentLoopIndex ].push( currentString );
                            currentLoopIndex += 1;

                        }else{

                            cif[ currentCategory ][ currentName ] = currentString;

                        }

                        pendingString = false;
                        currentString = null;

                    }else{

                        // NGL.log( "STRING START" );

                        pendingString = true;
                        currentString = line.substring( 1 );

                    }

                }else if( line==="loop_" ){

                    // NGL.log( "LOOP START" );

                    pendingLoop = true;
                    loopPointers.length = 0;
                    pointerNames.length = 0;
                    currentLoopIndex = 0;

                }else if( line[0]==="_" ){

                    if( pendingLoop ){

                        // NGL.log( "LOOP KEY", line );

                        var ks = line.split(".");
                        var category = ks[ 0 ].substring( 1 );
                        var name = ks[ 1 ];

                        if( !cif[ category ] ) cif[ category ] = {};
                        if( cif[ category ][ name ] ){
                            NGL.warn( category, name, "already exists" );
                        }else{
                            cif[ category ][ name ] = [];
                            loopPointers.push( cif[ category ][ name ] );
                            pointerNames.push( name );
                        }

                        currentCategory = category;
                        currentName = name;
                        first = true;

                    }else{

                        var ls = line.match( reQuotedWhitespace );
                        var key = ls[ 0 ];
                        var value = ls[ 1 ];
                        var ks = key.split(".");
                        var category = ks[ 0 ].substring( 1 );
                        var name = ks[ 1 ];

                        if( !cif[ category ] ) cif[ category ] = {};

                        if( cif[ category ][ name ] ){
                            NGL.warn( category, name, "already exists" );
                        }else{
                            cif[ category ][ name ] = value;
                        }

                        if( !value ) pendingValue = true;

                        currentCategory = category;
                        currentName = name;

                    }

                }else{

                    if( pendingString ){

                        // NGL.log( "STRING VALUE", line );

                        currentString += " " + line;

                    }else if( pendingLoop ){

                        // NGL.log( "LOOP VALUE", line );

                        if( currentCategory==="atom_site" ){

                            var nn = pointerNames.length;

                            var ls = line.split( reWhitespace );
                            var k;

                            if( first ){

                                var names = [
                                    "group_PDB", "id", "label_atom_id",
                                    // "label_seq_id",
                                    "label_comp_id", "type_symbol", "label_asym_id",
                                    "Cartn_x", "Cartn_y", "Cartn_z", "B_iso_or_equiv",
                                    "label_alt_id", "auth_seq_id", "pdbx_PDB_model_num"
                                ];

                                indexList.length = 0;

                                for( var j = 0; j < nn; ++j ){

                                    if( names.indexOf( pointerNames[ j ] ) !== -1 ){
                                        indexList.push( j );
                                    }

                                }

                                label_atom_id = pointerNames.indexOf( "label_atom_id" );
                                label_alt_id = pointerNames.indexOf( "label_alt_id" );
                                Cartn_x = pointerNames.indexOf( "Cartn_x" );
                                Cartn_y = pointerNames.indexOf( "Cartn_y" );
                                Cartn_z = pointerNames.indexOf( "Cartn_z" );
                                id = pointerNames.indexOf( "id" );
                                type_symbol = pointerNames.indexOf( "type_symbol" );
                                label_asym_id = pointerNames.indexOf( "label_asym_id" );
                                // label_seq_id = pointerNames.indexOf( "label_seq_id" );
                                label_comp_id = pointerNames.indexOf( "label_comp_id" );
                                group_PDB = pointerNames.indexOf( "group_PDB" );
                                B_iso_or_equiv = pointerNames.indexOf( "B_iso_or_equiv" );
                                auth_seq_id = pointerNames.indexOf( "auth_seq_id" );
                                pdbx_PDB_model_num = pointerNames.indexOf( "pdbx_PDB_model_num" );

                                first = false;

                                modelNum = parseInt( ls[ pdbx_PDB_model_num ] );

                                if( asTrajectory ){
                                    currentFrame = [];
                                    currentCoord = 0;
                                }

                            }

                            //

                            var _modelNum = parseInt( ls[ pdbx_PDB_model_num ] );

                            if( modelNum !== _modelNum ){

                                if( asTrajectory ){

                                    if( modelIdx === 0 ){
                                        frames.push( new Float32Array( currentFrame ) );
                                    }

                                    currentFrame = new Float32Array( atoms.length * 3 );
                                    frames.push( currentFrame );
                                    currentCoord = 0;

                                }

                                modelIdx += 1;

                            }

                            modelNum = _modelNum;

                            if( firstModelOnly && modelIdx > 0 ) continue;

                            //

                            var atomname = ls[ label_atom_id ].replace( reDoubleQuote, '' );
                            if( cAlphaOnly && atomname !== 'CA' ) continue;

                            var x = parseFloat( ls[ Cartn_x ] );
                            var y = parseFloat( ls[ Cartn_y ] );
                            var z = parseFloat( ls[ Cartn_z ] );

                            if( asTrajectory ){

                                var j = currentCoord * 3;

                                currentFrame[ j + 0 ] = x;
                                currentFrame[ j + 1 ] = y;
                                currentFrame[ j + 2 ] = z;

                                currentCoord += 1;

                                if( modelIdx > 0 ) continue;

                            }

                            //

                            var serial = parseInt( ls[ id ] );
                            var element = ls[ type_symbol ];
                            var hetero = ( ls[ group_PDB ][ 0 ] === 'H' ) ? 1 : 0;
                            var chainname = ls[ label_asym_id ];
                            // var resno = parseInt( ls[ label_seq_id ] );
                            var resno = parseInt( ls[ auth_seq_id ] );
                            var resname = ls[ label_comp_id ];
                            var bfactor = parseFloat( ls[ B_iso_or_equiv ] );
                            var altloc = ls[ label_alt_id ];
                            altloc = ( altloc === '.' ) ? '' : altloc;

                            var a;

                            if( atomArray ){

                                a = new NGL.ProxyAtom( atomArray, idx );

                                atomArray.setResname( idx, resname );
                                atomArray.x[ idx ] = x;
                                atomArray.y[ idx ] = y;
                                atomArray.z[ idx ] = z;
                                atomArray.setElement( idx, element );
                                atomArray.hetero[ idx ] = hetero;
                                atomArray.setChainname( idx, chainname );
                                atomArray.resno[ idx ] = resno;
                                atomArray.serial[ idx ] = serial;
                                atomArray.setAtomname( idx, atomname );
                                atomArray.ss[ idx ] = 'c'.charCodeAt( 0 );
                                atomArray.bfactor[ idx ] = bfactor;
                                atomArray.altloc[ idx ] = altloc.charCodeAt( 0 );
                                atomArray.vdw[ idx ] = vdwRadii[ element ];
                                atomArray.covalent[ idx ] = covRadii[ element ];
                                atomArray.modelindex[ idx ] = modelIdx;

                                atomArray.usedLength += 1;

                            }else{

                                a = new NGL.Atom();
                                a.index = idx;

                                a.resname = resname;
                                a.x = x;
                                a.y = y;
                                a.z = z;
                                a.element = element;
                                a.hetero = hetero;
                                a.chainname = chainname;
                                a.resno = resno;
                                a.serial = serial;
                                a.atomname = atomname;
                                a.ss = 'c';
                                a.bfactor = bfactor;
                                a.altloc = altloc;
                                a.vdw = vdwRadii[ element ];
                                a.covalent = covRadii[ element ];
                                a.modelindex = modelIdx;

                            }

                            idx += 1;
                            atoms.push( a );

                        }else{

                            var ls = line.match( reQuotedWhitespace );
                            var nn = ls.length;

                            if( currentLoopIndex === loopPointers.length ){
                                currentLoopIndex = 0;
                            }/*else if( currentLoopIndex > loopPointers.length ){
                                NGL.warn( "cif parsing error, wrong number of loop data entries", nn, loopPointers.length );
                            }*/

                            for( var j = 0; j < nn; ++j ){
                                loopPointers[ currentLoopIndex + j ].push( ls[ j ] );
                            }

                            currentLoopIndex += nn;

                        }

                    }else if( line[0]==="'" && line.substring( line.length-1 )==="'" ){

                        // NGL.log( "NEWLINE STRING", line );

                        cif[ currentCategory ][ currentName ] = line.substring(
                            1, line.length - 2
                        );

                    }else if( pendingValue ){

                        // NGL.log( "NEWLINE VALUE", line );

                        cif[ currentCategory ][ currentName ] = line.trim();

                    }else{

                        NGL.log( "NGL.CifParser._parse: unknown state", line );

                    }

                }


            }

        }

        function _ensureArray( dict, field ){

            if( !Array.isArray( dict[ field ] ) ){
                Object.keys( dict ).forEach( function( key ){
                    dict[ key ] = [ dict[ key ] ];
                } );
            }

        }

        async.series( [

            // parse lines
            function( wcallback ){

                this.streamer.eachChunkOfLinesAsync(

                    _parseChunkOfLines,

                    function(){

                        if( cif.struct && cif.struct.title ){

                            s.title = cif.struct.title.trim()
                                        .replace( /^['"]+|['"]+$/g, "" );

                        }

                        wcallback();

                    }

                );

            }.bind( this ),

            // get helices
            function( wcallback ){

                var sc = cif.struct_conf;

                if( !sc ){

                    wcallback();
                    return;

                }

                var helices = s.helices;
                var helixTypes = NGL.HelixTypes;

                // ensure data is in lists
                _ensureArray( sc, "id" );

                NGL.processArray(

                    sc.beg_auth_seq_id,

                    function( _i, _n ){

                        for( var i = _i; i < _n; ++i ){

                            var helixType = parseInt( sc.pdbx_PDB_helix_class[ i ] );

                            if( !Number.isNaN( helixType ) ){

                                helices.push( [

                                    sc.beg_label_asym_id[ i ],
                                    parseInt( sc.beg_auth_seq_id[ i ] ),
                                    sc.end_label_asym_id[ i ],
                                    parseInt( sc.end_auth_seq_id[ i ] ),
                                    helixTypes[ helixType ] || helixTypes[""]

                                ] );

                            }

                        }

                    },

                    wcallback,

                    1000

                );

            },

            // get sheets
            function( wcallback ){

                var ssr = cif.struct_sheet_range;

                if( !ssr ){

                    wcallback();
                    return;

                }

                var sheets = s.sheets;

                // ensure data is in lists
                _ensureArray( ssr, "id" );

                NGL.processArray(

                    ssr.beg_auth_seq_id,

                    function( _i, _n ){

                        for( var i = _i; i < _n; ++i ){

                            sheets.push( [

                                ssr.beg_label_asym_id[ i ],
                                parseInt( ssr.beg_auth_seq_id[ i ] ),
                                ssr.end_label_asym_id[ i ],
                                parseInt( ssr.end_auth_seq_id[ i ] )

                            ] );

                        }

                    },

                    wcallback,

                    1000

                );

            },

            // biomol & ncs processing
            function( wcallback ){

                var operDict = {};
                var biomolDict = s.biomolDict;

                if( cif.pdbx_struct_oper_list ){

                    var op = cif.pdbx_struct_oper_list;

                    // ensure data is in lists
                    _ensureArray( op, "id" );

                    op.id.forEach( function( id, i ){

                        var m = new THREE.Matrix4();
                        var elms = m.elements;

                        elms[  0 ] = parseFloat( op[ "matrix[1][1]" ][ i ] );
                        elms[  1 ] = parseFloat( op[ "matrix[1][2]" ][ i ] );
                        elms[  2 ] = parseFloat( op[ "matrix[1][3]" ][ i ] );

                        elms[  4 ] = parseFloat( op[ "matrix[2][1]" ][ i ] );
                        elms[  5 ] = parseFloat( op[ "matrix[2][2]" ][ i ] );
                        elms[  6 ] = parseFloat( op[ "matrix[2][3]" ][ i ] );

                        elms[  8 ] = parseFloat( op[ "matrix[3][1]" ][ i ] );
                        elms[  9 ] = parseFloat( op[ "matrix[3][2]" ][ i ] );
                        elms[ 10 ] = parseFloat( op[ "matrix[3][3]" ][ i ] );

                        elms[  3 ] = parseFloat( op[ "vector[1]" ][ i ] );
                        elms[  7 ] = parseFloat( op[ "vector[2]" ][ i ] );
                        elms[ 11 ] = parseFloat( op[ "vector[3]" ][ i ] );

                        m.transpose();

                        operDict[ id ] = m;

                    } );

                }

                if( cif.pdbx_struct_assembly_gen ){

                    var gen = cif.pdbx_struct_assembly_gen;

                    // ensure data is in lists
                    _ensureArray( gen, "assembly_id" );

                    var getMatrixDict = function( expr ){

                        var matDict = {};

                        var l = expr.replace( /[\(\)']/g, "" ).split( "," );

                        l.forEach( function( e ){

                            if( e.indexOf( "-" ) !== -1 ){

                                var es = e.split( "-" );

                                var j = parseInt( es[ 0 ] );
                                var m = parseInt( es[ 1 ] );

                                for( ; j <= m; ++j ){

                                    matDict[ j ] = operDict[ j ];

                                }

                            }else{

                                matDict[ e ] = operDict[ e ];

                            }

                        } );

                        return matDict;

                    }

                    gen.assembly_id.forEach( function( id, i ){

                        var md = {};
                        var oe = gen.oper_expression[ i ];

                        if( oe.indexOf( ")(" ) !== -1 ){

                            oe = oe.split( ")(" );

                            var md1 = getMatrixDict( oe[ 0 ] );
                            var md2 = getMatrixDict( oe[ 1 ] );

                            Object.keys( md1 ).forEach( function( k1 ){

                                Object.keys( md2 ).forEach( function( k2 ){

                                    var mat = new THREE.Matrix4();

                                    mat.multiplyMatrices( md1[ k1 ], md2[ k2 ] );
                                    md[ k1 + "x" + k2 ] = mat;

                                } );

                            } );

                        }else{

                            md = getMatrixDict( oe );

                        }

                        var name = id;
                        if( /^(0|[1-9][0-9]*)$/.test( name ) ) name = "BU" + name;

                        biomolDict[ name ] = {

                            matrixDict: md,
                            chainList: gen.asym_id_list[ i ].split( "," )

                        };

                    } );

                }

                // non-crystallographic symmetry operations
                if( cif.struct_ncs_oper ){

                    var op = cif.struct_ncs_oper;

                    // ensure data is in lists
                    _ensureArray( op, "id" );

                    var md = {};

                    biomolDict[ "NCS" ] = {

                        matrixDict: md,
                        chainList: undefined

                    };

                    op.id.forEach( function( id, i ){

                        var m = new THREE.Matrix4();
                        var elms = m.elements;

                        elms[  0 ] = parseFloat( op[ "matrix[1][1]" ][ i ] );
                        elms[  1 ] = parseFloat( op[ "matrix[1][2]" ][ i ] );
                        elms[  2 ] = parseFloat( op[ "matrix[1][3]" ][ i ] );

                        elms[  4 ] = parseFloat( op[ "matrix[2][1]" ][ i ] );
                        elms[  5 ] = parseFloat( op[ "matrix[2][2]" ][ i ] );
                        elms[  6 ] = parseFloat( op[ "matrix[2][3]" ][ i ] );

                        elms[  8 ] = parseFloat( op[ "matrix[3][1]" ][ i ] );
                        elms[  9 ] = parseFloat( op[ "matrix[3][2]" ][ i ] );
                        elms[ 10 ] = parseFloat( op[ "matrix[3][3]" ][ i ] );

                        elms[  3 ] = parseFloat( op[ "vector[1]" ][ i ] );
                        elms[  7 ] = parseFloat( op[ "vector[2]" ][ i ] );
                        elms[ 11 ] = parseFloat( op[ "vector[3]" ][ i ] );

                        m.transpose();

                        md[ id ] = m;

                    } );

                }

                // cell

                var unitcellDict = {};

                if( cif.cell ){

                    var cell = cif.cell;
                    var symmetry = cif.symmetry || {};

                    var a = parseFloat( cell.length_a );
                    var b = parseFloat( cell.length_b );
                    var c = parseFloat( cell.length_c );

                    var alpha = parseFloat( cell.angle_alpha );
                    var beta = parseFloat( cell.angle_beta );
                    var gamma = parseFloat( cell.angle_gamma );

                    var sGroup = symmetry[ "space_group_name_H-M" ];
                    if( sGroup[0] === sGroup[ sGroup.length-1 ] &&
                        ( sGroup[0] === "'" || sGroup[0] === '"' )
                    ){
                        sGroup = sGroup.substring( 1, sGroup.length-1 );
                    }
                    var z = parseInt( cell.Z_PDB );

                    var box = new Float32Array( 9 );
                    box[ 0 ] = a;
                    box[ 4 ] = b;
                    box[ 8 ] = c;
                    boxes.push( box );

                    unitcellDict.a = a;
                    unitcellDict.b = b;
                    unitcellDict.c = c;
                    unitcellDict.alpha = alpha;
                    unitcellDict.beta = beta;
                    unitcellDict.gamma = gamma;
                    unitcellDict.spacegroup = sGroup;

                }

                // origx

                var origx = new THREE.Matrix4();

                if( cif.database_PDB_matrix ){

                    var mat = cif.database_PDB_matrix;
                    var elms = origx.elements;

                    elms[  0 ] = parseFloat( mat[ "origx[1][1]" ] );
                    elms[  1 ] = parseFloat( mat[ "origx[1][2]" ] );
                    elms[  2 ] = parseFloat( mat[ "origx[1][3]" ] );

                    elms[  4 ] = parseFloat( mat[ "origx[2][1]" ] );
                    elms[  5 ] = parseFloat( mat[ "origx[2][2]" ] );
                    elms[  6 ] = parseFloat( mat[ "origx[2][3]" ] );

                    elms[  8 ] = parseFloat( mat[ "origx[3][1]" ] );
                    elms[  9 ] = parseFloat( mat[ "origx[3][2]" ] );
                    elms[ 10 ] = parseFloat( mat[ "origx[3][3]" ] );

                    elms[  3 ] = parseFloat( mat[ "origx_vector[1]" ] );
                    elms[  7 ] = parseFloat( mat[ "origx_vector[2]" ] );
                    elms[ 11 ] = parseFloat( mat[ "origx_vector[3]" ] );

                    origx.transpose();

                    unitcellDict.origx = origx;

                }

                // scale

                var scale = new THREE.Matrix4();

                if( cif.atom_sites ){

                    var mat = cif.atom_sites;
                    var elms = scale.elements;

                    elms[  0 ] = parseFloat( mat[ "fract_transf_matrix[1][1]" ] );
                    elms[  1 ] = parseFloat( mat[ "fract_transf_matrix[1][2]" ] );
                    elms[  2 ] = parseFloat( mat[ "fract_transf_matrix[1][3]" ] );

                    elms[  4 ] = parseFloat( mat[ "fract_transf_matrix[2][1]" ] );
                    elms[  5 ] = parseFloat( mat[ "fract_transf_matrix[2][2]" ] );
                    elms[  6 ] = parseFloat( mat[ "fract_transf_matrix[2][3]" ] );

                    elms[  8 ] = parseFloat( mat[ "fract_transf_matrix[3][1]" ] );
                    elms[  9 ] = parseFloat( mat[ "fract_transf_matrix[3][2]" ] );
                    elms[ 10 ] = parseFloat( mat[ "fract_transf_matrix[3][3]" ] );

                    elms[  3 ] = parseFloat( mat[ "fract_transf_vector[1]" ] );
                    elms[  7 ] = parseFloat( mat[ "fract_transf_vector[2]" ] );
                    elms[ 11 ] = parseFloat( mat[ "fract_transf_vector[3]" ] );

                    scale.transpose();

                    unitcellDict.scale = scale;

                }

                s.unitcell = new NGL.Unitcell(
                    unitcellDict.a,
                    unitcellDict.b,
                    unitcellDict.c,
                    unitcellDict.alpha,
                    unitcellDict.beta,
                    unitcellDict.gamma,
                    unitcellDict.spacegroup,
                    unitcellDict.scale
                );

                wcallback();

            }

        ], function(){

            NGL.timeEnd( __timeName );
            callback();

        } );

    },

    _postProcess: function( callback ){

        NGL.time( "NGL.CifParser._postProcess" );

        var s = this.structure;
        var cif = this.cif;

        function _ensureArray( dict, field ){

            if( !Array.isArray( dict[ field ] ) ){
                Object.keys( dict ).forEach( function( key ){
                    dict[ key ] = [ dict[ key ] ];
                } );
            }

        }

        async.series( [

            // add connections
            function( wcallback ){

                var sc = cif.struct_conn;

                if( !sc ){

                    wcallback();
                    return;

                }

                // ensure data is in lists
                _ensureArray( sc, "id" );

                var reDoubleQuote = /"/g;

                NGL.processArray(

                    sc.id,

                    function( _i, _n ){

                        for( var i = _i; i < _n; ++i ){

                            // ignore:
                            // hydrog - hydrogen bond
                            // mismat - mismatched base pairs
                            // saltbr - ionic interaction

                            var conn_type_id = sc.conn_type_id[ i ]
                            if( conn_type_id === "hydrog" ||
                                conn_type_id === "mismat" ||
                                conn_type_id === "saltbr" ) continue;

                            // ignore bonds between symmetry mates
                            if( sc.ptnr1_symmetry[ i ] !== "1_555" ||
                                sc.ptnr2_symmetry[ i ] !== "1_555" ) continue;

                            // process:
                            // covale - covalent bond
                            // covale_base -
                            //      covalent modification of a nucleotide base
                            // covale_phosphate -
                            //      covalent modification of a nucleotide phosphate
                            // covale_sugar -
                            //      covalent modification of a nucleotide sugar
                            // disulf - disulfide bridge
                            // metalc - metal coordination
                            // modres - covalent residue modification

                            var sele1 = (
                                sc.ptnr1_auth_seq_id[ i ] + ":" +
                                sc.ptnr1_label_asym_id[ i ] + "." +
                                sc.ptnr1_label_atom_id[ i ].replace( reDoubleQuote, '' )
                            );
                            var selection1 = new NGL.Selection( sele1 );
                            if( selection1.selection[ "error" ] ){
                                NGL.warn(
                                    "invalid selection for connection", sele1
                                );
                                continue;
                            }
                            var atoms1 = s.getAtoms( selection1 );

                            var sele2 = (
                                sc.ptnr2_auth_seq_id[ i ] + ":" +
                                sc.ptnr2_label_asym_id[ i ] + "." +
                                sc.ptnr2_label_atom_id[ i ].replace( reDoubleQuote, '' )
                            );
                            var selection2 = new NGL.Selection( sele2 );
                            if( selection2.selection[ "error" ] ){
                                NGL.warn(
                                    "invalid selection for connection", sele2
                                );
                                continue;
                            }
                            var atoms2 = s.getAtoms( selection2 );

                            // cases with more than one atom per selection
                            // - #altloc1 to #altloc2
                            // - #model to #model
                            // - #altloc1 * #model to #altloc2 * #model

                            var k = atoms1.length;
                            var l = atoms2.length;

                            if( k > l ){
                                var tmpA = k;
                                k = l;
                                l = tmpA;
                                var tmpB = atoms1;
                                atoms1 = atoms2;
                                atoms2 = tmpB;
                            }

                            for( var j = 0; j < l; ++j ){

                                var a1 = atoms1[ j % k ];
                                var a2 = atoms2[ j ];

                                if( a1 && a2 ){

                                    s.bondSet.addBond( a1, a2 );

                                }else{

                                    NGL.log( "atoms for connection not found" );

                                }

                            }

                        }

                    },

                    wcallback,

                    500

                );

            }

        ], function(){

            NGL.timeEnd( "NGL.CifParser._postProcess" );
            callback();

        } );

    }

} );


NGL.SdfParser = function( streamer, params ){

    NGL.StructureParser.call( this, streamer, params );

};

NGL.SdfParser.prototype = NGL.createObject(

    NGL.StructureParser.prototype, {

    constructor: NGL.SdfParser,

    type: "sdf",

    _parse: function( callback ){

        // https://en.wikipedia.org/wiki/Chemical_table_file#SDF
        // http://download.accelrys.com/freeware/ctfile-formats/ctfile-formats.zip

        var headerLines = this.streamer.peekLines( 2 );

        var s = this.structure;
        var firstModelOnly = this.firstModelOnly;
        var asTrajectory = this.asTrajectory;

        s.id = headerLines[ 0 ].trim();
        s.title = headerLines[ 1 ].trim();

        var frames = s.frames;
        var boxes = s.boxes;
        var doFrames = false;
        var currentFrame, currentCoord;

        var atoms = s.atoms;
        var bondSet = s.bondSet;

        var covRadii = NGL.CovalentRadii;
        var vdwRadii = NGL.VdwRadii;

        var atomArray;
        var lineCount = this.streamer.lineCount();
        if( lineCount > NGL.useAtomArrayThreshold ){
            atomArray = new NGL.AtomArray( lineCount );
            s.atomArray = atomArray;
        }

        var idx = 0;
        var lineNo = 0;
        var modelIdx = 0;
        var modelAtomIdxStart = 0;

        var atomCount, bondCount, atomStart, atomEnd, bondStart, bondEnd;

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                var line = lines[ i ];

                if( line.substr( 0, 4 ) === "$$$$" ){

                    lineNo = -1;
                    ++modelIdx;
                    modelAtomIdxStart = atoms.length;

                }

                if( lineNo === 3 ){

                    atomCount = parseInt( line.substr( 0, 3 ) );
                    bondCount = parseInt( line.substr( 3, 3 ) );

                    atomStart = 4;
                    atomEnd = atomStart + atomCount;
                    bondStart = atomEnd;
                    bondEnd = bondStart + bondCount;

                    if( asTrajectory ){

                        currentCoord = 0;
                        currentFrame = new Float32Array( atomCount * 3 );
                        frames.push( currentFrame );

                        if( modelIdx > 0 ) doFrames = true;

                    }

                }

                if( lineNo >= atomStart && lineNo < atomEnd ){

                    if( firstModelOnly && modelIdx > 0 ) continue;

                    var x = parseFloat( line.substr( 0, 10 ) );
                    var y = parseFloat( line.substr( 10, 10 ) );
                    var z = parseFloat( line.substr( 20, 10 ) );

                    if( asTrajectory ){

                        var j = currentCoord * 3;

                        currentFrame[ j + 0 ] = x;
                        currentFrame[ j + 1 ] = y;
                        currentFrame[ j + 2 ] = z;

                        currentCoord += 1;

                        if( doFrames ) continue;

                    }

                    var element = line.substr( 31, 3 ).trim();
                    var atomname = element + ( idx + 1 );

                    var a;

                    if( atomArray ){

                        a = new NGL.ProxyAtom( atomArray, idx );

                        atomArray.setResname( idx, "HET" );
                        atomArray.x[ idx ] = x;
                        atomArray.y[ idx ] = y;
                        atomArray.z[ idx ] = z;
                        atomArray.setElement( idx, element );
                        atomArray.setChainname( idx, '' );
                        atomArray.resno[ idx ] = 1;
                        atomArray.serial[ idx ] = idx;
                        atomArray.setAtomname( idx, atomname );
                        atomArray.ss[ idx ] = 'c'.charCodeAt( 0 );
                        atomArray.setAltloc( idx, '' );
                        atomArray.vdw[ idx ] = vdwRadii[ element ];
                        atomArray.covalent[ idx ] = covRadii[ element ];
                        atomArray.modelindex[ idx ] = modelIdx;

                        atomArray.usedLength += 1;

                    }else{

                        a = new NGL.Atom();
                        a.index = idx;

                        a.resname = "HET";
                        a.x = x;
                        a.y = y;
                        a.z = z;
                        a.element = element;
                        a.hetero = 1
                        a.chainname = '';
                        a.resno = 1;
                        a.serial = idx;
                        a.atomname = atomname;
                        a.ss = 'c';
                        a.altloc = '';
                        a.vdw = vdwRadii[ element ];
                        a.covalent = covRadii[ element ];
                        a.modelindex = modelIdx;

                    }

                    idx += 1;
                    atoms.push( a );

                }

                if( lineNo >= bondStart && lineNo < bondEnd ){

                    if( firstModelOnly && modelIdx > 0 ) continue;
                    if( asTrajectory && modelIdx > 0 ) continue;

                    var from = parseInt( line.substr( 0, 3 ) ) - 1 + modelAtomIdxStart;
                    var to = parseInt( line.substr( 3, 3 ) ) - 1 + modelAtomIdxStart;
                    var order = parseInt( line.substr( 6, 3 ) );

                    bondSet.addBond( atoms[ from ], atoms[ to ], false, order );

                }

                ++lineNo;

            };

        };

        this.streamer.eachChunkOfLinesAsync(

            _parseChunkOfLines,

            function(){

                s._dontAutoBond = true;
                callback();

            }

        );

    }

} );


NGL.Mol2Parser = function( streamer, params ){

    NGL.StructureParser.call( this, streamer, params );

};

NGL.Mol2Parser.prototype = NGL.createObject(

    NGL.StructureParser.prototype, {

    constructor: NGL.Mol2Parser,

    type: "mol2",

    _parse: function( callback ){

        // http://www.tripos.com/data/support/mol2.pdf

        var reWhitespace = /\s+/;

        var s = this.structure;
        var firstModelOnly = this.firstModelOnly;
        var asTrajectory = this.asTrajectory;

        var frames = s.frames;
        var boxes = s.boxes;
        var doFrames = false;
        var currentFrame, currentCoord;

        var atoms = s.atoms;
        var bondSet = s.bondSet;

        var covRadii = NGL.CovalentRadii;
        var vdwRadii = NGL.VdwRadii;

        var atomArray;
        var lineCount = this.streamer.lineCount();
        if( lineCount > NGL.useAtomArrayThreshold ){
            atomArray = new NGL.AtomArray( lineCount );
            s.atomArray = atomArray;
        }

        var idx = 0;
        var moleculeLineNo = 0;
        var modelAtomIdxStart = 0;
        var modelIdx = -1;
        var numAtoms = 0;

        var currentRecordType = 0;
        var moleculeRecordType = 1;
        var atomRecordType = 2;
        var bondRecordType = 3;

        var bondTypes = {
            "1": 1,
            "2": 2,
            "3": 3,
            "am": 1,  // amide
            "ar": 1,  // aromatic
            "du": 1,  // dummy
            "un": 1,  // unknown
            "nc": 0,  // not connected
        };

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                var line = lines[ i ].trim();

                if( line === "" || line[ 0 ] === "#" ) continue;

                if( line[ 0 ] === "@" ){

                    if( line === "@<TRIPOS>MOLECULE" ){

                        currentRecordType = moleculeRecordType;
                        moleculeLineNo = 0;

                        ++modelIdx;

                    }else if( line === "@<TRIPOS>ATOM" ){

                        currentRecordType = atomRecordType;
                        modelAtomIdxStart = atoms.length;

                        if( asTrajectory ){

                            currentCoord = 0;
                            currentFrame = new Float32Array( numAtoms * 3 );
                            frames.push( currentFrame );

                            if( modelIdx > 0 ) doFrames = true;

                        }

                    }else if( line === "@<TRIPOS>BOND" ){

                        currentRecordType = bondRecordType;

                    }else{

                        currentRecordType = 0;

                    }

                }else if( currentRecordType === moleculeRecordType ){

                    if( moleculeLineNo === 0 ){

                        s.title = line;
                        s.id = line;

                    }else if( moleculeLineNo === 1 ){

                        var ls = line.split( reWhitespace );
                        numAtoms = parseInt( ls[ 0 ] );
                        // num_atoms [num_bonds [num_subst [num_feat [num_sets]]]]

                    }else if( moleculeLineNo === 2 ){

                        var molType = line;
                        // SMALL, BIOPOLYMER, PROTEIN, NUCLEIC_ACID, SACCHARIDE

                    }else if( moleculeLineNo === 3 ){

                        var chargeType = line;
                        // NO_CHARGES, DEL_RE, GASTEIGER, GAST_HUCK, HUCKEL,
                        // PULLMAN, GAUSS80_CHARGES, AMPAC_CHARGES,
                        // MULLIKEN_CHARGES, DICT_ CHARGES, MMFF94_CHARGES,
                        // USER_CHARGES

                    }else if( moleculeLineNo === 4 ){

                        var statusBits = line;

                    }else if( moleculeLineNo === 5 ){

                        var molComment = line;

                    }

                    ++moleculeLineNo;

                }else if( currentRecordType === atomRecordType ){

                    var ls = line.split( reWhitespace );

                    if( firstModelOnly && modelIdx > 0 ) continue;

                    var x = parseFloat( ls[ 2 ] );
                    var y = parseFloat( ls[ 3 ] );
                    var z = parseFloat( ls[ 4 ] );

                    if( asTrajectory ){

                        var j = currentCoord * 3;

                        currentFrame[ j + 0 ] = x;
                        currentFrame[ j + 1 ] = y;
                        currentFrame[ j + 2 ] = z;

                        currentCoord += 1;

                        if( doFrames ) continue;

                    }

                    var serial = ls[ 0 ];
                    var atomname = ls[ 1 ];
                    var element = ls[ 5 ].split( "." )[ 0 ];
                    var resno = ls[ 6 ] ? parseInt( ls[ 6 ] ) : 1;
                    var resname = ls[ 7 ] ? ls[ 7 ] : "";
                    var bfactor = ls[ 8 ] ? parseFloat( ls[ 8 ] ) : 0.0;

                    var a;

                    if( atomArray ){

                        a = new NGL.ProxyAtom( atomArray, idx );

                        atomArray.setResname( idx, resname );
                        atomArray.x[ idx ] = x;
                        atomArray.y[ idx ] = y;
                        atomArray.z[ idx ] = z;
                        atomArray.setElement( idx, element );
                        atomArray.setChainname( idx, '' );
                        atomArray.resno[ idx ] = resno;
                        atomArray.serial[ idx ] = idx;
                        atomArray.setAtomname( idx, atomname );
                        atomArray.ss[ idx ] = 'c'.charCodeAt( 0 );
                        atomArray.setAltloc( idx, '' );
                        atomArray.bfactor[ idx ] = bfactor;
                        atomArray.vdw[ idx ] = vdwRadii[ element ];
                        atomArray.covalent[ idx ] = covRadii[ element ];
                        atomArray.modelindex[ idx ] = modelIdx;

                        atomArray.usedLength += 1;

                    }else{

                        a = new NGL.Atom();
                        a.index = idx;

                        a.resname = resname;
                        a.x = x;
                        a.y = y;
                        a.z = z;
                        a.element = element;
                        a.hetero = 1
                        a.chainname = '';
                        a.resno = resno;
                        a.serial = idx;
                        a.atomname = atomname;
                        a.ss = 'c';
                        a.altloc = '';
                        a.bfactor = bfactor;
                        a.vdw = vdwRadii[ element ];
                        a.covalent = covRadii[ element ];
                        a.modelindex = modelIdx;

                    }

                    idx += 1;
                    atoms.push( a );

                }else if( currentRecordType === bondRecordType ){

                    if( firstModelOnly && modelIdx > 0 ) continue;
                    if( asTrajectory && modelIdx > 0 ) continue;

                    var ls = line.split( reWhitespace );

                    // ls[ 0 ] is bond id
                    var from = parseInt( ls[ 1 ] ) - 1 + modelAtomIdxStart;
                    var to = parseInt( ls[ 2 ] ) - 1 + modelAtomIdxStart;
                    var order = bondTypes[ ls[ 3 ] ];

                    bondSet.addBond( atoms[ from ], atoms[ to ], false, order );

                }

            };

        };

        this.streamer.eachChunkOfLinesAsync(

            _parseChunkOfLines,

            function(){

                s._dontAutoBond = true;
                callback();

            }

        );

    }

} );


//////////////////////
// Trajectory parser

NGL.TrajectoryParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.frames = new NGL.Frames( this.name, this.path );

};

NGL.TrajectoryParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.TrajectoryParser,

    type: "trajectory",

    __objName: "frames"

} );


NGL.DcdParser = function( streamer, params ){

    var p = params || {};

    NGL.TrajectoryParser.call( this, streamer, p );

};

NGL.DcdParser.prototype = NGL.createObject(

    NGL.TrajectoryParser.prototype, {

    constructor: NGL.DcdParser,

    type: "dcd",

    _parse: function( callback ){

        // http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/dcdplugin.html

        // The DCD format is structured as follows
        //   (FORTRAN UNFORMATTED, with Fortran data type descriptions):
        // HDR     NSET    ISTRT   NSAVC   5-ZEROS NATOM-NFREAT    DELTA   9-ZEROS
        // `CORD'  #files  step 1  step    zeroes  (zero)          timestep  (zeroes)
        //                         interval
        // C*4     INT     INT     INT     5INT    INT             DOUBLE  9INT
        // ==========================================================================
        // NTITLE          TITLE
        // INT (=2)        C*MAXTITL
        //                 (=32)
        // ==========================================================================
        // NATOM
        // #atoms
        // INT
        // ==========================================================================
        // X(I), I=1,NATOM         (DOUBLE)
        // Y(I), I=1,NATOM
        // Z(I), I=1,NATOM
        // ==========================================================================

        var __timeName = "NGL.DcdParser._parse " + this.name;

        NGL.time( __timeName );

        var bin = this.streamer.data;
        if( bin instanceof Uint8Array ){
            bin = bin.buffer;
        }
        var dv = new DataView( bin );

        var f = this.frames;
        var coordinates = f.coordinates;
        var boxes = f.boxes;
        var header = {};
        var nextPos = 0;

        // header block

        var intView = new Int32Array( bin, 0, 23 );
        var ef = intView[ 0 ] !== dv.getInt32( 0 );  // endianess flag
        // swap byte order when big endian (84 indicates little endian)
        if( intView[ 0 ] !== 84 ){
            var n = bin.byteLength;
            for( var i = 0; i < n; i+=4 ){
                dv.setFloat32( i, dv.getFloat32( i ), true );
            }
        }
        if( intView[ 0 ] !== 84 ){
            NGL.error( "dcd bad format, header block start" );
        }
        // format indicator, should read 'CORD'
        var formatString = String.fromCharCode(
            dv.getUint8( 4 ), dv.getUint8( 5 ),
            dv.getUint8( 6 ), dv.getUint8( 7 )
        );
        if( formatString !== "CORD" ){
            NGL.error( "dcd bad format, format string" );
        }
        var isCharmm = false;
        var extraBlock = false;
        var fourDims = false;
        // version field in charmm, unused in X-PLOR
        if( intView[ 22 ] !== 0 ){
            isCharmm = true;
            if( intView[ 12 ] !== 0 ) extraBlock = true;
            if( intView[ 13 ] === 1 ) fourDims = true;
        }
        header.NSET = intView[ 2 ];
        header.ISTART = intView[ 3 ];
        header.NSAVC = intView[ 4 ];
        header.NAMNF = intView[ 10 ];
        if( isCharmm ){
            header.DELTA = dv.getFloat32( 44, ef );
        }else{
            header.DELTA = dv.getFloat64( 44, ef );
        }
        if( intView[ 22 ] !== 84 ){
            NGL.error( "dcd bad format, header block end" );
        }
        nextPos = nextPos + 21 * 4 + 8;

        // title block

        var titleLength = dv.getInt32( nextPos, ef );
        var titlePos = nextPos + 1;
        if( ( titleLength - 4 ) % 80 !== 0 ){
            NGL.error( "dcd bad format, title block start" );
        }
        header.TITLE = NGL.Uint8ToString(
            new Uint8Array( bin, titlePos, titleLength )
        );
        if( dv.getInt32( titlePos + titleLength + 4 - 1, ef ) !== titleLength ){
            NGL.error( "dcd bad format, title block end" );
        }
        nextPos = nextPos + titleLength + 8;

        // natom block

        if( dv.getInt32( nextPos, ef ) !== 4 ){
            NGL.error( "dcd bad format, natom block start" );
        }
        header.NATOM = dv.getInt32( nextPos + 4, ef );
        if( dv.getInt32( nextPos + 8, ef ) !== 4 ){
            NGL.error( "dcd bad format, natom block end" );
        }
        nextPos = nextPos + 4 + 8;

        // fixed atoms block

        if( header.NAMNF > 0 ){
            // TODO read coordinates and indices of fixed atoms
            NGL.error( "dcd format with fixed atoms unsupported, aborting" );
            callback();
            return;
        }

        // frames

        var natom = header.NATOM;
        var natom4 = natom * 4;

        for( var i = 0, n = header.NSET; i < n; ++i ){

            if( extraBlock ){
                nextPos += 4;  // block start
                // unitcell: A, alpha, B, beta, gamma, C (doubles)
                var box = new Float32Array( 9 );
                box[ 0 ] = dv.getFloat64( nextPos        , ef );
                box[ 4 ] = dv.getFloat64( nextPos + 2 * 8, ef );
                box[ 8 ] = dv.getFloat64( nextPos + 5 * 8, ef );
                boxes.push( box );
                nextPos += 48;
                nextPos += 4;  // block end
            }

            // xyz coordinates
            var coord = new Float32Array( natom * 3 );
            for( var j = 0; j < 3; ++j ){
                if( dv.getInt32( nextPos, ef ) !== natom4 ){
                    NGL.error( "dcd bad format, coord block start", i, j );
                }
                nextPos += 4;  // block start
                var c = new Float32Array( bin, nextPos, natom );
                for( var k = 0; k < natom; ++k ){
                    coord[ 3 * k + j ] = c[ k ];
                }
                nextPos += natom4;
                if( dv.getInt32( nextPos, ef ) !== natom4 ){
                    NGL.error( "dcd bad format, coord block end", i, j );
                }
                nextPos += 4;  // block end
            }
            coordinates.push( coord );

            if( fourDims ){
                var bytes = dv.getInt32( nextPos, ef );
                nextPos += 4 + bytes + 4;  // block start + skip + block end
            }

        }

        // console.log( header );
        // console.log( header.TITLE );
        // console.log( "isCharmm", isCharmm, "extraBlock", extraBlock, "fourDims", fourDims );

        NGL.timeEnd( __timeName );

        callback();

        return;

    },

} );


//////////////////
// Volume parser

NGL.VolumeParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.volume = new NGL.Volume( this.name, this.path );

};

NGL.VolumeParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.VolumeParser,

    type: "volume",

    __objName: "volume",

    _afterParse: function( callback ){

        this.volume.setMatrix( this.getMatrix() );

        callback();

    },

    getMatrix: function(){

        return new THREE.Matrix4();

    }

} );


NGL.MrcParser = function( streamer, params ){

    NGL.VolumeParser.call( this, streamer, params );

};

NGL.MrcParser.prototype = NGL.createObject(

    NGL.VolumeParser.prototype, {

    constructor: NGL.MrcParser,

    type: "mrc",

    _parse: function( callback ){

        // MRC
        // http://ami.scripps.edu/software/mrctools/mrc_specification.php
        // http://www2.mrc-lmb.cam.ac.uk/research/locally-developed-software/image-processing-software/#image
        // http://bio3d.colorado.edu/imod/doc/mrc_format.txt

        // CCP4 (MAP)
        // http://www.ccp4.ac.uk/html/maplib.html

        // MRC format does not use the skew transformation header records (words 25-37)
        // CCP4 format does not use the ORIGIN header records (words 50-52)

        var __timeName = "NGL.MrcParser._parse " + this.name;

        NGL.time( __timeName );

        var bin = this.streamer.data;

        if( bin instanceof Uint8Array ){
            bin = bin.buffer;
        }

        var v = this.volume;
        var header = {};

        var intView = new Int32Array( bin, 0, 56 );
        var floatView = new Float32Array( bin, 0, 56 );

        var dv = new DataView( bin );

        // 53  MAP         Character string 'MAP ' to identify file type
        header.MAP = String.fromCharCode(
            dv.getUint8( 52 * 4 ), dv.getUint8( 52 * 4 + 1 ),
            dv.getUint8( 52 * 4 + 2 ), dv.getUint8( 52 * 4 + 3 )
        );

        // 54  MACHST      Machine stamp indicating machine type which wrote file
        //                 17 and 17 for big-endian or 68 and 65 for little-endian
        header.MACHST = [ dv.getUint8( 53 * 4 ), dv.getUint8( 53 * 4 + 1 ) ];

        // swap byte order when big endian
        if( header.MACHST[ 0 ] === 17 && header.MACHST[ 1 ] === 17 ){
            var n = bin.byteLength;
            for( var i = 0; i < n; i+=4 ){
                dv.setFloat32( i, dv.getFloat32( i ), true );
            }
        }

        header.NX = intView[ 0 ];  // NC - columns (fastest changing)
        header.NY = intView[ 1 ];  // NR - rows
        header.NZ = intView[ 2 ];  // NS - sections (slowest changing)

        // mode
        //  0 image : signed 8-bit bytes range -128 to 127
        //  1 image : 16-bit halfwords
        //  2 image : 32-bit reals
        //  3 transform : complex 16-bit integers
        //  4 transform : complex 32-bit reals
        //  6 image : unsigned 16-bit range 0 to 65535
        // 16 image: unsigned char * 3 (for rgb data, non-standard)
        //
        // Note: Mode 2 is the normal mode used in the CCP4 programs.
        //       Other modes than 2 and 0 may NOT WORK
        header.MODE = intView[ 3 ];

        // start
        header.NXSTART = intView[ 4 ];  // NCSTART - first column
        header.NYSTART = intView[ 5 ];  // NRSTART - first row
        header.NZSTART = intView[ 6 ];  // NSSTART - first section

        // intervals
        header.MX = intView[ 7 ];  // intervals along x
        header.MY = intView[ 8 ];  // intervals along y
        header.MZ = intView[ 9 ];  // intervals along z

        // cell length (Angstroms in CCP4)
        header.xlen = floatView[ 10 ];
        header.ylen = floatView[ 11 ];
        header.zlen = floatView[ 12 ];

        // cell angle (Degrees)
        header.alpha = floatView[ 13 ];
        header.beta  = floatView[ 14 ];
        header.gamma = floatView[ 15 ];

        // axis correspondence (1,2,3 for X,Y,Z)
        header.MAPC = intView[ 16 ];  // column
        header.MAPR = intView[ 17 ];  // row
        header.MAPS = intView[ 18 ];  // section

        // density statistics
        header.DMIN  = floatView[ 19 ];
        header.DMAX  = floatView[ 20 ];
        header.DMEAN = floatView[ 21 ];

        // space group number 0 or 1 (default=0)
        header.ISPG = intView[ 22 ];

        // number of bytes used for symmetry data (0 or 80)
        header.NSYMBT = intView[ 23 ];

        // Flag for skew transformation, =0 none, =1 if foll
        header.LSKFLG = intView[ 24 ];

        // 26-34  SKWMAT  Skew matrix S (in order S11, S12, S13, S21 etc) if
        //                LSKFLG .ne. 0.
        // 35-37  SKWTRN  Skew translation t if LSKFLG != 0.
        //                Skew transformation is from standard orthogonal
        //                coordinate frame (as used for atoms) to orthogonal
        //                map frame, as Xo(map) = S * (Xo(atoms) - t)

        // 38      future use       (some of these are used by the MSUBSX routines
        //  .          "              in MAPBRICK, MAPCONT and FRODO)
        //  .          "   (all set to zero by default)
        //  .          "
        // 52          "

        // 50-52 origin in X,Y,Z used for transforms
        header.originX = floatView[ 49 ];
        header.originY = floatView[ 50 ];
        header.originZ = floatView[ 51 ];

        // 53  MAP         Character string 'MAP ' to identify file type
        // => see top of this parser

        // 54  MACHST      Machine stamp indicating machine type which wrote file
        // => see top of this parser

        // Rms deviation of map from mean density
        header.ARMS = floatView[ 54 ];

        // 56      NLABL           Number of labels being used
        // 57-256  LABEL(20,10)    10  80 character text labels (ie. A4 format)

        v.header = header;

        // NGL.log( header )

        // FIXME depends on mode
        var data = new Float32Array(
            bin, 256 * 4 + header.NSYMBT,
            header.NX * header.NY * header.NZ
        );

        v.setData( data, header.NX, header.NY, header.NZ );

        NGL.timeEnd( __timeName );

        callback();

    },

    getMatrix: function(){

        var h = this.volume.header;

        var basisX = [
            h.xlen,
            0,
            0
        ];

        var basisY = [
            h.ylen * Math.cos( Math.PI / 180.0 * h.gamma ),
            h.ylen * Math.sin( Math.PI / 180.0 * h.gamma ),
            0
        ];

        var basisZ = [
            h.zlen * Math.cos( Math.PI / 180.0 * h.beta ),
            h.zlen * (
                    Math.cos( Math.PI / 180.0 * h.alpha )
                    - Math.cos( Math.PI / 180.0 * h.gamma )
                    * Math.cos( Math.PI / 180.0 * h.beta )
                ) / Math.sin( Math.PI / 180.0 * h.gamma ),
            0
        ];
        basisZ[ 2 ] = Math.sqrt(
            h.zlen * h.zlen * Math.sin( Math.PI / 180.0 * h.beta ) *
            Math.sin( Math.PI / 180.0 * h.beta ) - basisZ[ 1 ] * basisZ[ 1 ]
        );

        var basis = [ 0, basisX, basisY, basisZ ];
        var nxyz = [ 0, h.MX, h.MY, h.MZ ];
        var mapcrs = [ 0, h.MAPC, h.MAPR, h.MAPS ];

        var matrix = new THREE.Matrix4();

        matrix.set(

            basis[ mapcrs[1] ][0] / nxyz[ mapcrs[1] ],
            basis[ mapcrs[2] ][0] / nxyz[ mapcrs[2] ],
            basis[ mapcrs[3] ][0] / nxyz[ mapcrs[3] ],
            0,

            basis[ mapcrs[1] ][1] / nxyz[ mapcrs[1] ],
            basis[ mapcrs[2] ][1] / nxyz[ mapcrs[2] ],
            basis[ mapcrs[3] ][1] / nxyz[ mapcrs[3] ],
            0,

            basis[ mapcrs[1] ][2] / nxyz[ mapcrs[1] ],
            basis[ mapcrs[2] ][2] / nxyz[ mapcrs[2] ],
            basis[ mapcrs[3] ][2] / nxyz[ mapcrs[3] ],
            0,

            0, 0, 0, 1

        );

        matrix.multiply(
            new THREE.Matrix4().makeTranslation(
                h.NXSTART + h.originX,
                h.NYSTART + h.originY,
                h.NZSTART + h.originZ
            )
        );

        return matrix;

    }

} );


NGL.CubeParser = function( streamer, params ){

    // @author Johanna Tiemann <johanna.tiemann@googlemail.com>
    // @author Alexander Rose <alexander.rose@weirdbyte.de>

    NGL.VolumeParser.call( this, streamer, params );

};

NGL.CubeParser.prototype = NGL.createObject(

    NGL.VolumeParser.prototype, {

    constructor: NGL.CubeParser,

    type: "cube",

    _parse: function( callback ){

        // http://paulbourke.net/dataformats/cube/

        var __timeName = "NGL.CubeParser._parse " + this.name;

        NGL.time( __timeName );

        var v = this.volume;
        var headerLines = this.streamer.peekLines( 6 );
        var header = {};
        var reWhitespace = /\s+/;
        var bohrToAngstromFactor = 0.529177210859;

        function headerhelper( k, l ) {
            var field = headerLines[ k ].trim().split( reWhitespace )[ l ];
            return parseFloat( field );
        }

        header.atomCount = Math.abs( headerhelper( 2, 0 ) ); //Number of atoms
        header.originX = headerhelper( 2, 1 ) * bohrToAngstromFactor; //Position of origin of volumetric data
        header.originY = headerhelper( 2, 2 ) * bohrToAngstromFactor;
        header.originZ = headerhelper( 2, 3 ) * bohrToAngstromFactor;
        header.NVX = headerhelper( 3, 0 ); //Number of voxels
        header.NVY = headerhelper( 4, 0 );
        header.NVZ = headerhelper( 5, 0 );
        header.AVX = headerhelper( 3, 1 ) * bohrToAngstromFactor; //Axis vector
        header.AVY = headerhelper( 4, 2 ) * bohrToAngstromFactor;
        header.AVZ = headerhelper( 5, 3 ) * bohrToAngstromFactor;

        var data = new Float32Array( header.NVX * header.NVY * header.NVZ );
        var count = 0;
        var lineNo = 0;

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                var line = lines[ i ].trim();

                if( line !== "" && lineNo >= header.atomCount + 6 ){

                    line = line.split( reWhitespace );
                    for( var j = 0, lj = line.length; j < lj; ++j ){
                        if ( line.length !==1 ) {
                            data[ count ] = parseFloat( line[ j ] );
                            ++count;
                        };
                    };

                }

                ++lineNo;

            };

        };

        this.streamer.eachChunkOfLinesAsync(

            _parseChunkOfLines,

            function(){

                v.header = header;
                v.setData( data, header.NVZ, header.NVY, header.NVX );
                NGL.timeEnd( __timeName );
                callback();

            }

        );

    },

    getMatrix: function(){

        var h = this.volume.header;
        var matrix = new THREE.Matrix4();

        matrix.multiply(
            new THREE.Matrix4().makeRotationY( THREE.Math.degToRad( 90 ) )
        );

        matrix.multiply(
            new THREE.Matrix4().makeTranslation(
                -h.originZ, h.originY, h.originX
            )
        );

        matrix.multiply(
            new THREE.Matrix4().makeScale(
                -h.AVZ, h.AVY, h.AVX
            )
        );

        return matrix;

    }

} );


NGL.DxParser = function( streamer, params ){

    NGL.VolumeParser.call( this, streamer, params );

};

NGL.DxParser.prototype = NGL.createObject(

    NGL.VolumeParser.prototype, {

    constructor: NGL.DxParser,

    type: "dx",

    _parse: function( callback ){

        // http://www.poissonboltzmann.org/docs/file-format-info/

        var __timeName = "NGL.DxParser._parse " + this.name;

        NGL.time( __timeName );

        var v = this.volume;
        var headerLines = this.streamer.peekLines( 30 );
        var header = {};
        var reWhitespace = /\s+/;

        var dataLineStart = 0;
        var deltaLineCount = 0;

        for( var i = 0; i < 30; ++i ){

            var line = headerLines[ i ];

            if( line.startsWith( "object 1" ) ){

                var ls = line.split( reWhitespace );

                header.nx = parseInt( ls[ 5 ] );
                header.ny = parseInt( ls[ 6 ] );
                header.nz = parseInt( ls[ 7 ] );

            }else if( line.startsWith( "origin" ) ){

                var ls = line.split( reWhitespace );

                header.xmin = parseFloat( ls[ 1 ] );
                header.ymin = parseFloat( ls[ 2 ] );
                header.zmin = parseFloat( ls[ 3 ] );

            }else if( line.startsWith( "delta" ) ){

                var ls = line.split( reWhitespace );

                if( deltaLineCount === 0 ){
                    header.hx = parseFloat( ls[ 1 ] );
                }else if( deltaLineCount === 1 ){
                    header.hy = parseFloat( ls[ 2 ] );
                }else if( deltaLineCount === 2 ){
                    header.hz = parseFloat( ls[ 3 ] );
                }

                deltaLineCount += 1;

            }else if( line.startsWith( "object 3" ) ){

                dataLineStart = i;

            }

        }

        var size = header.nx * header.ny * header.nz;
        var data = new Float32Array( size );
        var count = 0;
        var lineNo = 0;

        function _parseChunkOfLines( _i, _n, lines ){

            for( var i = _i; i < _n; ++i ){

                if( count < size && lineNo > dataLineStart ){

                    var line = lines[ i ].trim();

                    if( line !== "" ){

                        var ls = line.split( reWhitespace );

                        for( var j = 0, lj = ls.length; j < lj; ++j ){
                            data[ count ] = parseFloat( ls[ j ] );
                            ++count;
                        };

                    }

                }

                ++lineNo;

            };

        };

        this.streamer.eachChunkOfLinesAsync(

            _parseChunkOfLines,

            function(){

                v.header = header;
                v.setData( data, header.nz, header.ny, header.nx );
                NGL.timeEnd( __timeName );
                callback();

            }

        );

    },

    getMatrix: function(){

        var h = this.volume.header;
        var matrix = new THREE.Matrix4();

        matrix.multiply(
            new THREE.Matrix4().makeRotationY( THREE.Math.degToRad( 90 ) )
        );

        matrix.multiply(
            new THREE.Matrix4().makeTranslation(
                -h.zmin, h.ymin, h.xmin
            )
        );

        matrix.multiply(
            new THREE.Matrix4().makeScale(
                -h.hz, h.hy, h.hx
            )
        );

        return matrix;

    }

} );


///////////////////
// Surface parser

NGL.SurfaceParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.loader = undefined;
    this.surface = new NGL.Surface( this.name, this.path );

};

NGL.SurfaceParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.SurfaceParser,

    type: "surface",

    __objName: "surface",

    _parse: function( callback ){

        var text = NGL.Uint8ToString( this.streamer.data );
        var geometry = this.loader.parse( text );

        this.surface.fromGeometry( geometry );

        callback();

    }

} );


NGL.PlyParser = function( streamer, params ){

    var p = params || {};

    NGL.SurfaceParser.call( this, streamer, p );

    this.loader = new THREE.PLYLoader();

};

NGL.PlyParser.prototype = NGL.createObject(

    NGL.SurfaceParser.prototype, {

    constructor: NGL.PlyParser,

    type: "ply"

} );


NGL.ObjParser = function( streamer, params ){

    var p = params || {};

    NGL.SurfaceParser.call( this, streamer, p );

    this.loader = new THREE.OBJLoader();

};

NGL.ObjParser.prototype = NGL.createObject(

    NGL.SurfaceParser.prototype, {

    constructor: NGL.ObjParser,

    type: "obj"

} );


////////////////
// Text parser

NGL.TextParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.text = {

        name: this.name,
        path: this.path,
        data: ""

    };

};

NGL.TextParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.TextParser,

    type: "text",

    __objName: "text",

    _parse: function( callback ){

        this.text.data = NGL.Uint8ToString( this.streamer.data );

        callback();

    }

} );


///////////////
// Csv parser

NGL.CsvParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.table = {

        name: this.name,
        path: this.path,
        colNames: [],
        data: []

    };

};

NGL.CsvParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.CsvParser,

    type: "csv",

    __objName: "table",

    _parse: function( callback ){

        var data = this.table.data;
        var reDelimiter = /\s*,\s*/;

        this.streamer.eachChunkOfLines( function( chunk, chunkNo, chunkCount ){

            var n = chunk.length;

            for( var i = 0; i < n; ++i ){

                var line = chunk[ i ].trim();
                var values = line.split( reDelimiter );

                if( chunkNo === 0 && i === 0 ){

                    this.table.colNames = values;

                }else if( line ){

                    data.push( values );

                }

            }

        }.bind( this ) );

        callback();

    }

} );


////////////////
// Json parser

NGL.JsonParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.json = {

        name: this.name,
        path: this.path,
        data: {}

    };

};

NGL.JsonParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.JsonParser,

    type: "json",

    __objName: "json",

    _parse: function( callback ){

        var text = NGL.Uint8ToString( this.streamer.data );

        this.json.data = JSON.parse( text );

        callback();

    }

} );


////////////////
// Xml parser

NGL.XmlParser = function( streamer, params ){

    var p = params || {};

    NGL.Parser.call( this, streamer, p );

    this.xml = {

        name: this.name,
        path: this.path,
        data: {}

    };

};

NGL.XmlParser.prototype = NGL.createObject(

    NGL.Parser.prototype, {

    constructor: NGL.XmlParser,

    type: "xml",

    __objName: "xml",

    _parse: function( callback ){

        var text = NGL.Uint8ToString( this.streamer.data );

        // https://github.com/segmentio/xml-parser
        // MIT license

        function parse( xml ){

            xml = xml.trim();

            // strip comments
            xml = xml.replace( /<!--[\s\S]*?-->/g, '' );

            return document();

            function document(){

                return {
                    declaration: declaration(),
                    root: tag()
                }

            }

            function declaration(){

                var m = match(/^<\?xml\s*/);
                if (!m) return;

                // tag
                var node = {
                    attributes: {}
                };

                // attributes
                while (!(eos() || is('?>'))) {
                    var attr = attribute();
                    if (!attr) return node;
                    node.attributes[attr.name] = attr.value;
                }

                match(/\?>\s*/);
                return node;

            }

            function tag(){

                var m = match(/^<([\w-:.]+)\s*/);
                if (!m) return;

                // name
                var node = {
                    name: m[1],
                    attributes: {},
                    children: []
                };

                // attributes
                while (!(eos() || is('>') || is('?>') || is('/>'))) {
                    var attr = attribute();
                    if (!attr) return node;
                    node.attributes[attr.name] = attr.value;
                }

                // self closing tag
                if (match(/^\s*\/>\s*/)) {
                    return node;
                }

                match(/\??>\s*/);

                // content
                node.content = content();

                // children
                var child;
                while (child = tag()) {
                    node.children.push(child);
                }

                // closing
                match(/^<\/[\w-:.]+>\s*/);

                return node;

            }

            function content(){

                var m = match(/^([^<]*)/);
                if (m) return m[1];
                return '';

            }

            function attribute(){

                var m = match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);
                if (!m) return;
                return { name: m[1], value: strip(m[2]) }

            }

            function strip( val ){

                return val.replace(/^['"]|['"]$/g, '');

            }

            function match( re ){

                var m = xml.match(re);
                if (!m) return;
                xml = xml.slice(m[0].length);
                return m;

            }

            function eos(){

                return 0 == xml.length;

            }

            function is( prefix ){

                return 0 == xml.indexOf(prefix);

            }

        }

        this.xml.data = parse( text );

        callback();

    }

} );

// File:js/ngl/writer.js

/**
 * @file Writer
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


///////////////
// PDB Writer

NGL.PdbWriter = function( structure, params ){

    var p = Object.assign( {}, params );

    var renumberSerial = p.renumberSerial !== undefined ? p.renumberSerial : true;
    var remarks = p.remarks || [];
    if( !Array.isArray( remarks ) ) remarks = [ remarks ];

    var records;

    function writeRecords(){

        records = [];

        writeTitle();
        writeRemarks();
        writeAtoms();

    }

    // http://www.wwpdb.org/documentation/file-format

    // Sample PDB line, the coords X,Y,Z are fields 5,6,7 on each line.
    // ATOM      1  N   ARG     1      29.292  13.212 -12.751  1.00 33.78      1BPT 108

    function DEF( x, y ){
        return x !== undefined ? x : y;
    }

    var atomFormat =
        "ATOM  %5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s";

    var hetatmFormat =
        "HETATM%5d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s";

    function writeTitle(){

        // FIXME multiline if title line longer than 80 chars
        records.push( sprintf( "TITEL %-74s", structure.name ) );

    }

    function writeRemarks(){

        remarks.forEach( function( str ){
            records.push( sprintf( "REMARK %-73s", str ) );
        } );

        if( structure.trajectory ){
            records.push( sprintf(
                "REMARK %-73s",
                "Trajectory '" + structure.trajectory.name + "'"
            ) );
            records.push( sprintf(
                "REMARK %-73s",
                "Frame " + structure.trajectory.frame + ""
            ) );
        }

    }

    function writeAtoms(){

        var ia = 1;
        var im = 1;

        structure.eachModel( function( m ){

            records.push( sprintf( "MODEL %-74d", im++ ) );

            m.eachAtom( function( a ){

                var formatString = a.hetero ? hetatmFormat : atomFormat;
                var serial = renumberSerial ? ia : a.serial;

                // Alignment of one-letter atom name such as C starts at column 14,
                // while two-letter atom name such as FE starts at column 13.
                var atomname = a.atomname;
                if( atomname.length === 1 ) atomname = " " + atomname;

                records.push( sprintf(
                    formatString,

                    a.serial,
                    atomname,
                    a.resname,
                    DEF( a.chainname, " " ),
                    a.resno,
                    a.x, a.y, a.z,
                    DEF( a.occurence, 1.0 ),
                    DEF( a.bfactor, 0.0 ),
                    DEF( a.segid, "" ),
                    DEF( a.element, "" )
                ) );
                ia += 1;

            } );

            records.push( sprintf( "%-80s", "ENDMDL" ) );
            im += 1;

        } );

        records.push( sprintf( "%-80s", "END" ) );

    }

    function getString(){

        writeRecords();
        return records.join( "\n" );

    }

    function getBlob(){

        return new Blob(
            [ getString() ],
            { type: 'text/plain' }
        );

    }

    function download( name, ext ){

        name = name || "structure"
        ext = ext || "pdb";

        var file = name + "." + ext;
        var blob = getBlob();

        NGL.download( blob, file );

    }

    // API

    this.getString = getString;
    this.getBlob = getBlob;
    this.download = download;

};

// File:js/ngl/loader.js

/**
 * @file Loader
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


///////////////
// Datasource

NGL.DatasourceRegistry = {

    sourceDict: {},

    listing: undefined,
    trajectory: undefined,

    __passThrough: {
        getUrl: function( path ){
            return path;
        }
    },

    add: function( name, datasource ){
        name = name.toLowerCase();
        if( name in this.sourceDict ){
            NGL.warn( "overwriting datasource named '" + name + "'" );
        }
        this.sourceDict[ name ] = datasource;
    },

    get: function( name ){
        name = name || "";
        name = name.toLowerCase();
        if( name in this.sourceDict ){
            return this.sourceDict[ name ];
        }else if( [ "http", "https", "ftp" ].indexOf( name ) !== -1 ){
            return this.__passThrough;
        }else if( !name ){
            return this.__passThrough;
        }else{
            NGL.error( "no datasource named '" + name + "' found" );
        }
    }

};


NGL.getDataInfo = function( src ){

    var info = NGL.getFileInfo( src );
    var datasource = NGL.DatasourceRegistry.get( info.protocol );
    var url = datasource.getUrl( info.src );

    return NGL.getFileInfo( url );

};


NGL.StaticDatasource = function( baseUrl ){

    baseUrl = baseUrl || "";

    this.getUrl = function( src ){
        var info = NGL.getFileInfo( src );
        return NGL.getAbsolutePath( baseUrl + info.path );
    };

};


NGL.RcsbDatasource = function(){

    var baseUrl = "http://www.rcsb.org/pdb/files/";

    this.getUrl = function( src ){
        // valid path are
        // XXXX.pdb, XXXX.pdb.gz, XXXX.cif, XXXX.cif.gz
        // XXXX defaults to XXXX.cif.gz
        var info = NGL.getFileInfo( src );
        var file;
        if( [ "pdb", "cif" ].indexOf( info.ext ) !== -1 &&
            ( info.compressed === false || info.compressed === "gz" )
        ){
            file = info.path;
        }else{
            file = info.name + ".cif.gz";
        }
        return baseUrl + file;
    };

};

NGL.DatasourceRegistry.add(
    "rcsb", new NGL.RcsbDatasource()
);


///////////
// Loader

NGL.Loader = function( src, params ){

    var p = Object.assign( {}, params );

    this.compressed = p.compressed || false;
    this.name = p.name || "";
    this.ext = p.ext || "";
    this.dir = p.dir || "";
    this.path = p.path || "";
    this.protocol = p.protocol || "";

    this.params = params;

    //

    var streamerParams = {

        compressed: this.compressed

    };

    if( src instanceof File || src instanceof Blob ){

        this.streamer = new NGL.FileStreamer( src, streamerParams );

    }else{

        this.streamer = new NGL.NetworkStreamer( src, streamerParams );

    }

    if( typeof p.onProgress === "function" ){

        this.streamer.onprogress = p.onprogress;

    }

};

NGL.Loader.prototype = {

    constructor: NGL.Loader,

    load: function(){

        return new Promise( function( resolve, reject ){

            this.streamer.onerror = reject;

            try{

                this._load( resolve, reject );

            }catch( e ){

                reject( e );

            }

        }.bind( this ) );

    },

    _load: function( resolve, reject ){

        reject( "not implemented" );

    }

};


NGL.ParserLoader = function( src, params ){

    NGL.Loader.call( this, src, params );

    this.noWorker = this.params.noWorker || false;

};

NGL.ParserLoader.prototype = NGL.createObject(

    NGL.Loader.prototype, {

    constructor: NGL.ParserLoader,

    _load: function( resolve, reject ){

        var parsersClasses = {

            "gro": NGL.GroParser,
            "pdb": NGL.PdbParser,
            "ent": NGL.PdbParser,
            "pqr": NGL.PqrParser,
            "cif": NGL.CifParser,
            "mcif": NGL.CifParser,
            "mmcif": NGL.CifParser,
            "sdf": NGL.SdfParser,
            "mol2": NGL.Mol2Parser,

            "dcd": NGL.DcdParser,

            "mrc": NGL.MrcParser,
            "ccp4": NGL.MrcParser,
            "map": NGL.MrcParser,
            "cube": NGL.CubeParser,
            "dx": NGL.DxParser,

            "ply": NGL.PlyParser,
            "obj": NGL.ObjParser,

            "txt": NGL.TextParser,
            "text": NGL.TextParser,
            "csv": NGL.CsvParser,
            "json": NGL.JsonParser,
            "xml": NGL.XmlParser

        };

        var parser = new parsersClasses[ this.ext ](
            this.streamer, this.params
        );

        if( this.noWorker ){

            parser.parse( resolve );

        }else{

            parser.parseWorker( resolve );

        }

    }

} );


NGL.ScriptLoader = function( src, params ){

    NGL.Loader.call( this, src, params );

};

NGL.ScriptLoader.prototype = NGL.createObject(

    NGL.Loader.prototype, {

    constructor: NGL.ScriptLoader,

    _load: function( resolve, reject ){

        this.streamer.read( function(){

            var text = NGL.Uint8ToString( this.streamer.data );

            var script = new NGL.Script( text, this.name, this.path );

            resolve( script );

        }.bind( this ) );

    }

} );


NGL.PluginLoader = function( src, params ){

    NGL.Loader.call( this, src, params );

};

NGL.PluginLoader.prototype = NGL.createObject(

    NGL.Loader.prototype, {

    constructor: NGL.PluginLoader,

    _load: function( resolve, reject ){

        var basePath;
        if( this.protocol ){
            basePath = this.protocol + "://" + this.dir;
        }else{
            basePath = this.dir;
        }

        this.streamer.read( function(){

            var text = NGL.Uint8ToString( this.streamer.data );
            var manifest = JSON.parse( text );
            var promiseList = [];

            manifest.files.map( function( name ){

                promiseList.push(
                    NGL.autoLoad( basePath + name, {
                        ext: "text", noWorker: true
                    } )
                );

            } );

            Promise.all( promiseList ).then( function( dataList ){

                var text = dataList.reduce( function( text, value ){
                    return text + "\n\n" + value.data;
                }, "" );
                text += manifest.source || "";

                var script = new NGL.Script( text, this.name, this.path );
                resolve( script );

            }.bind( this ) );

        }.bind( this ) );

    }

} );


NGL.loaderMap = {

    "gro": NGL.ParserLoader,
    "pdb": NGL.ParserLoader,
    "ent": NGL.ParserLoader,
    "pqr": NGL.ParserLoader,
    "cif": NGL.ParserLoader,
    "mcif": NGL.ParserLoader,
    "mmcif": NGL.ParserLoader,
    "sdf": NGL.ParserLoader,
    "mol2": NGL.ParserLoader,

    "dcd": NGL.ParserLoader,

    "mrc": NGL.ParserLoader,
    "ccp4": NGL.ParserLoader,
    "map": NGL.ParserLoader,
    "cube": NGL.ParserLoader,
    "dx": NGL.ParserLoader,

    "obj": NGL.ParserLoader,
    "ply": NGL.ParserLoader,

    "txt": NGL.ParserLoader,
    "text": NGL.ParserLoader,
    "csv": NGL.ParserLoader,
    "json": NGL.ParserLoader,
    "xml": NGL.ParserLoader,

    "ngl": NGL.ScriptLoader,
    "plugin": NGL.PluginLoader,

};


NGL.autoLoad = function( file, params ){

    var p = Object.assign( NGL.getDataInfo( file ), params );
    var loader = new NGL.loaderMap[ p.ext ]( p.src, p );

    if( loader ){
        return loader.load();
    }else{
        return Promise.reject( "NGL.autoLoading: ext '" + p.ext + "' unknown" );
    }

};

// File:js/ngl/viewer.js

/**
 * @file Viewer
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


/**
 * [Resources description]
 * @type {Object}
 * @private
 */
NGL.Resources = {

    // fonts
    // 'fonts/Arial.fnt': null,
    // 'fonts/Arial.png': 'image',
    // 'fonts/DejaVu.fnt': null,
    // 'fonts/DejaVu.png': 'image',
    'fonts/LatoBlack.fnt': null,
    'fonts/LatoBlack.png': 'image',

    // sprites
    // 'img/circle.png': 'image',
    // 'img/spark1.png': 'image',
    'img/radial.png': 'image',

    // shaders
    'shader/CylinderImpostor.vert': null,
    'shader/CylinderImpostor.frag': null,
    'shader/HyperballStickImpostor.vert': null,
    'shader/HyperballStickImpostor.frag': null,
    'shader/Line.vert': null,
    'shader/Line.frag': null,
    'shader/LineSprite.vert': null,
    'shader/LineSprite.frag': null,
    'shader/Mesh.vert': null,
    'shader/Mesh.frag': null,
    'shader/ParticleSprite.vert': null,
    'shader/ParticleSprite.frag': null,
    'shader/Quad.vert': null,
    'shader/Quad.frag': null,
    'shader/Ribbon.vert': null,
    'shader/Ribbon.frag': null,
    'shader/SDFFont.vert': null,
    'shader/SDFFont.frag': null,
    'shader/SphereHalo.vert': null,
    'shader/SphereHalo.frag': null,
    'shader/SphereImpostor.vert': null,
    'shader/SphereImpostor.frag': null,

    // shader chunks
    'shader/chunk/fog.glsl': null,
    'shader/chunk/fog_params.glsl': null,
    'shader/chunk/light.glsl': null,
    'shader/chunk/light_params.glsl': null,

};


/**
 * [Utils description]
 * @namespace NGL.Utils
 * @type {Object}
 */
NGL.Utils = {

    /**
     * Converted to JavaScript from
     * {@link http://paulbourke.net/geometry/pointlineplane/lineline.c}
     *
     * @param  {THREE.Vector3} p1
     * @param  {THREE.Vector3} p2
     * @param  {THREE.Vector3} p3
     * @param  {THREE.Vector3} p4
     * @return {Array.<THREE.Vector3, THREE.Vector3>}
     */
    lineLineIntersect: function( p1, p2, p3, p4 ){

        var EPS = NGL.EPS;

        var p13 = new THREE.Vector3(),
            p43 = new THREE.Vector3(),
            p21 = new THREE.Vector3();
        var d1343, d4321, d1321, d4343, d2121;
        var denom, numer;

        p13.x = p1.x - p3.x;
        p13.y = p1.y - p3.y;
        p13.z = p1.z - p3.z;
        p43.x = p4.x - p3.x;
        p43.y = p4.y - p3.y;
        p43.z = p4.z - p3.z;
        if( Math.abs(p43.x) < EPS && Math.abs(p43.y) < EPS && Math.abs(p43.z) < EPS )
            return null;

        p21.x = p2.x - p1.x;
        p21.y = p2.y - p1.y;
        p21.z = p2.z - p1.z;
        if( Math.abs(p21.x) < EPS && Math.abs(p21.y) < EPS && Math.abs(p21.z) < EPS )
            return null;

        d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z;
        d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z;
        d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z;
        d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z;
        d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;

        denom = d2121 * d4343 - d4321 * d4321;
        if( Math.abs(denom) < EPS )
            return null;
        numer = d1343 * d4321 - d1321 * d4343;

        var mua = numer / denom;
        var mub = ( d1343 + d4321 * mua ) / d4343;

        var pa = new THREE.Vector3(
            p1.x + mua * p21.x,
            p1.y + mua * p21.y,
            p1.z + mua * p21.z
        );
        var pb = new THREE.Vector3(
            p3.x + mub * p43.x,
            p3.y + mub * p43.y,
            p3.z + mub * p43.z
        );

        return [ pa, pb ];

    },

    circularMean: function(){

        // http://en.wikipedia.org/wiki/Center_of_mass#Systems_with_periodic_boundary_conditions

        // Bai, Linge; Breen, David (2008). Calculating Center of Mass in an Unbounded 2D Environment. Journal of Graphics, GPU, and Game Tools 13 (4): 53â60.

        // http://stackoverflow.com/questions/18166507/using-fft-to-find-the-center-of-mass-under-periodic-boundary-conditions

        var twoPi = 2 * Math.PI;

        return function( array, max, stride, offset, indices ){

            stride = stride || 1;
            offset = offset || 0;

            var n = indices ? indices.length : array.length;
            var angle, i, c;

            var cosMean = 0;
            var sinMean = 0;

            if( indices ){

                for( i = 0; i < n; ++i ){

                    // NGL.log( indices[ i ], stride, offset, indices[ i ] * stride + offset, array.length, array[ indices[ i ] * stride + offset ] );

                    c = ( array[ indices[ i ] * stride + offset ] + max ) % max;

                    angle = ( c / max ) * twoPi - Math.PI;

                    cosMean += Math.cos( angle );
                    sinMean += Math.sin( angle );

                }

            }else{

                for( i = offset; i < n; i += stride ){

                    c = ( array[ i ] + max ) % max;

                    angle = ( c / max ) * twoPi - Math.PI;

                    cosMean += Math.cos( angle );
                    sinMean += Math.sin( angle );

                }

            }

            cosMean /= n;
            sinMean /= n;

            var meanAngle = Math.atan2( sinMean, cosMean );

            var mean = ( meanAngle + Math.PI ) / twoPi * max;

            return mean;

        }

    }(),

    calculateCenterArray: function( array1, array2, center, offset ){

        var n = array1.length;
        center = center || new Float32Array( n );
        offset = offset || 0;

        for( var i = 0; i < n; i+=3 ){

            center[ offset + i + 0 ] = ( array1[ i + 0 ] + array2[ i + 0 ] ) / 2.0;
            center[ offset + i + 1 ] = ( array1[ i + 1 ] + array2[ i + 1 ] ) / 2.0;
            center[ offset + i + 2 ] = ( array1[ i + 2 ] + array2[ i + 2 ] ) / 2.0;

        }

        return center;

    },

    calculateDirectionArray: function( array1, array2 ){

        var n = array1.length;
        var direction = new Float32Array( n );

        for( var i = 0; i < n; i+=3 ){

            direction[ i + 0 ] = array2[ i + 0 ] - array1[ i + 0 ];
            direction[ i + 1 ] = array2[ i + 1 ] - array1[ i + 1 ];
            direction[ i + 2 ] = array2[ i + 2 ] - array1[ i + 2 ];

        }

        return direction;

    },

    positionFromGeometry: function( geometry ){

        var vertices = geometry.vertices;

        var j, v3;
        var n = vertices.length;
        var position = new Float32Array( n * 3 );

        for( var v = 0; v < n; v++ ){

            j = v * 3;
            v3 = vertices[ v ];

            position[ j + 0 ] = v3.x;
            position[ j + 1 ] = v3.y;
            position[ j + 2 ] = v3.z;

        }

        return position;

    },

    colorFromGeometry: function( geometry ){

        var faces = geometry.faces;
        var vn = geometry.vertices.length;

        var j, f, c;
        var n = faces.length;
        var color = new Float32Array( vn * 3 );

        for( var v = 0; v < n; v++ ){

            f = faces[ v ];
            c = f.color;

            j = f.a * 3;
            color[ j + 0 ] = c.r;
            color[ j + 1 ] = c.g;
            color[ j + 2 ] = c.b;

            j = f.b * 3;
            color[ j + 0 ] = c.r;
            color[ j + 1 ] = c.g;
            color[ j + 2 ] = c.b;

            j = f.c * 3;
            color[ j + 0 ] = c.r;
            color[ j + 1 ] = c.g;
            color[ j + 2 ] = c.b;

        }

        return color;

    },

    indexFromGeometry: function( geometry ){

        var faces = geometry.faces;

        var j, f;
        var n = faces.length;
        var index = new Uint32Array( n * 3 );

        for( var v = 0; v < n; v++ ){

            j = v * 3;
            f = faces[ v ];

            index[ j + 0 ] = f.a;
            index[ j + 1 ] = f.b;
            index[ j + 2 ] = f.c;

        }

        return index;

    },

    normalFromGeometry: function( geometry ){

        var faces = geometry.faces;
        var vn = geometry.vertices.length;

        var j, f, nn, n1, n2, n3;
        var n = faces.length;
        var normal = new Float32Array( vn * 3 );

        for( var v = 0; v < n; v++ ){

            f = faces[ v ];
            nn = f.vertexNormals;
            n1 = nn[ 0 ];
            n2 = nn[ 1 ];
            n3 = nn[ 2 ];

            j = f.a * 3;
            normal[ j + 0 ] = n1.x;
            normal[ j + 1 ] = n1.y;
            normal[ j + 2 ] = n1.z;

            j = f.b * 3;
            normal[ j + 0 ] = n2.x;
            normal[ j + 1 ] = n2.y;
            normal[ j + 2 ] = n2.z;

            j = f.c * 3;
            normal[ j + 0 ] = n3.x;
            normal[ j + 1 ] = n3.y;
            normal[ j + 2 ] = n3.z;

        }

        return normal;

    },

    uniformArray: function( n, a ){

        var array = new Float32Array( n );

        for( var i = 0; i < n; ++i ){

            array[ i ] = a;

        }

        return array;

    },

    uniformArray3: function( n, a, b, c ){

        var array = new Float32Array( n * 3 );

        var j;

        for( var i = 0; i < n; ++i ){

            j = i * 3;

            array[ j + 0 ] = a;
            array[ j + 1 ] = b;
            array[ j + 2 ] = c;

        }

        return array;

    },

    randomColorArray: function( n ){

        var array = new Float32Array( n * 3 );

        var j;

        for( var i = 0; i < n; ++i ){

            j = i * 3;

            array[ j + 0 ] = Math.random();
            array[ j + 1 ] = Math.random();
            array[ j + 2 ] = Math.random();

        }

        return array;

    },

    replicateArray3Entries: function( array, m ){

        var n = array.length / 3;

        var repArr = new Float32Array( n * m * 3 );

        var i, j, k, l, v;
        var a, b, c;

        for( i = 0; i < n; ++i ){

            v = i * 3;
            k = i * m * 3;

            a = array[ v + 0 ];
            b = array[ v + 1 ];
            c = array[ v + 2 ];

            for( j = 0; j < m; ++j ){

                l = k + j * 3;

                repArr[ l + 0 ] = a;
                repArr[ l + 1 ] = b;
                repArr[ l + 2 ] = c;

            }

        }

        return repArr;

    },

    calculateMeanArray: function( array1, array2 ){

        var n = array1.length;
        var mean = new Float32Array( n );

        for( var i = 0; i < n; i++ ){

            mean[ i ] = ( array1[ i ] + array2[ i ] ) / 2.0;

        }

        return mean;

    },

    calculateMinArray: function( array1, array2 ){

        var n = array1.length;
        var min = new Float32Array( n );

        for( var i = 0; i < n; i++ ){

            min[ i ] = Math.min( array1[ i ],  array2[ i ] );

        }

        return min;

    },

    calculateMeanVector3: function( array ){

        var n = array.length;
        var m = array.length / 3;

        var x = 0;
        var y = 0;
        var z = 0;

        var i;

        for( i = 0; i < n; i += 3 ){

            x += array[ i + 0 ];
            y += array[ i + 1 ];
            z += array[ i + 2 ];

        }

        return new THREE.Vector3( x / m, y / m, z / m );

    },

    isPointOnSegment: function( p, l1, l2 ){

        var len = l1.distanceTo( l2 );

        return p.distanceTo( l1 ) <= len && p.distanceTo( l2 ) <= len;

    },

    pointVectorIntersection: function(){

        var v = new THREE.Vector3();
        var v1 = new THREE.Vector3();

        return function( point, origin, vector ){

            v.copy( vector );
            v1.subVectors( point, origin );
            var distOriginI = Math.cos( v.angleTo( v1 ) ) * v1.length();
            var vectorI = v.normalize().multiplyScalar( distOriginI );
            var pointI = new THREE.Vector3().addVectors( vectorI, origin );

            return pointI;

        }

    }(),

    copyArray: function( src, dst, srcOffset, dstOffset, length ){

        var i;
        var n = length;

        for( i = 0; i < n; ++i ){

            dst[ dstOffset + i ] = src[ srcOffset + i ];

        }

    }

};


NGL.init = function( onload ){

    var debug = NGL.GET( "debug" );
    if( debug !== undefined ) NGL.debug = debug;

    var useWorker = NGL.GET( "useWorker" );
    if( useWorker !== undefined ) NGL.useWorker = useWorker;

    var disableImpostor = NGL.GET( "disableImpostor" );
    if( disableImpostor !== undefined ) NGL.disableImpostor = disableImpostor;

    this.textures = [];

    NGL.initResources( onload );

    return this;

};


NGL.dataURItoImage = function( dataURI ){

    if( typeof importScripts !== 'function' ){

        var img = document.createElement( "img" );
        img.src = dataURI;

        return img;

    }

};


NGL.initResources = function( onLoad ){

    var onLoadFn = function(){

        NGL.log( "NGL initialized" );

        if( onLoad !== undefined ){

            onLoad();

        }

    };

    var loadingManager = new THREE.LoadingManager( onLoadFn );

    var imageLoader = new THREE.ImageLoader( loadingManager );

    var xhrLoader = new THREE.XHRLoader( loadingManager );
    xhrLoader.setResponseType( "text" );

    var resourceKeys = Object.keys( NGL.Resources );
    var i = 0;

    resourceKeys.forEach( function( url ){

        var v = NGL.Resources[ url ];
        var url2 = NGL.assetsDirectory + url;

        if( v==="image" ){

            imageLoader.load( url2, function( image ){

                NGL.Resources[ url ] = image;

            });

        }else if( v!==null ){

            i += 1;
            return;

        }else{

            xhrLoader.load( url2, function( data ){

                NGL.Resources[ url ] = data;

            });

        }

    });

    if( resourceKeys.length === i ){

        onLoadFn();

    }

};


NGL.getShader = function(){

    var re = /^(?!\/\/)\s*#include\s+(\S+)/gmi;
    var cache = {};

    function getDefines( defines ){

        if( defines === undefined ) return "";

        var lines = [];

        for ( var name in defines ) {

            var value = defines[ name ];

            if ( value === false ) continue;

            lines.push( '#define ' + name + ' ' + value );

        }

        return lines.join( '\n' );

    }

    //

    return function( name, defines ){

        defines = defines || {};

        var hash = name + "|";
        for( var key in defines ){
            hash += key + ":" + defines[ key ];
        }

        if( !cache[ hash ] ){

            var definesText = getDefines( defines );

            var shaderText = NGL.Resources[ 'shader/' + name ];
            shaderText = shaderText.replace( re, function( match, p1 ){

                var path = 'shader/chunk/' + p1 + '.glsl';
                var chunk = NGL.Resources[ path ] || THREE.ShaderChunk[ p1 ];

                return chunk ? chunk : "";

            });

            cache[ hash ] = definesText + shaderText;

        }

        return cache[ hash ];

    }

}();


NGL.trimCanvas = function( canvas, r, g, b, a ){

    var canvasHeight = canvas.height;
    var canvasWidth = canvas.width;

    var ctx = canvas.getContext( '2d' );
    var pixels = ctx.getImageData(0, 0, canvasWidth, canvasHeight ).data;

    var x, y, doBreak;

    doBreak = false;
    for( y = 0; y < canvasHeight; y++ ) {
        for( x = 0; x < canvasWidth; x++ ) {
            var off = ( y * canvasWidth + x ) * 4;
            if( pixels[ off ] !== r || pixels[ off + 1 ] !== g ||
                    pixels[ off + 2 ] !== b || pixels[ off + 3 ] !== a ){
                doBreak = true;
                break;
            }
        }
        if( doBreak ){
            break;
        }
    }
    var topY = y;

    doBreak = false;
    for( x = 0; x < canvasWidth; x++ ) {
        for( y = 0; y < canvasHeight; y++ ) {
            var off = ( y * canvasWidth + x ) * 4;
            if( pixels[ off ] !== r || pixels[ off + 1 ] !== g ||
                    pixels[ off + 2 ] !== b || pixels[ off + 3 ] !== a ){
                doBreak = true;
                break;
            }
        }
        if( doBreak ){
            break;
        }
    }
    var topX = x;

    doBreak = false;
    for( y = canvasHeight-1; y >= 0; y-- ) {
        for( x = canvasWidth-1; x >= 0; x-- ) {
            var off = ( y * canvasWidth + x ) * 4;
            if( pixels[ off ] !== r || pixels[ off + 1 ] !== g ||
                    pixels[ off + 2 ] !== b || pixels[ off + 3 ] !== a ){
                doBreak = true;
                break;
            }
        }
        if( doBreak ){
            break;
        }
    }
    var bottomY = y;

    doBreak = false;
    for( x = canvasWidth-1; x >= 0; x-- ) {
        for( y = canvasHeight-1; y >= 0; y-- ) {
            var off = ( y * canvasWidth + x ) * 4;
            if( pixels[ off ] !== r || pixels[ off + 1 ] !== g ||
                    pixels[ off + 2 ] !== b || pixels[ off + 3 ] !== a ){
                doBreak = true;
                break;
            }
        }
        if( doBreak ){
            break;
        }
    }
    var bottomX = x;

    var trimedCanvas = document.createElement( 'canvas' );
    trimedCanvas.style.display = "hidden";
    document.body.appendChild( trimedCanvas );

    trimedCanvas.width = bottomX - topX;
    trimedCanvas.height = bottomY - topY;

    var trimedCtx = trimedCanvas.getContext( '2d' );

    trimedCtx.drawImage(
        canvas,
        topX, topY,
        trimedCanvas.width, trimedCanvas.height,
        0, 0,
        trimedCanvas.width, trimedCanvas.height
    );

    return trimedCanvas;

}


//////////
// Stats

NGL.Stats = function(){

    var SIGNALS = signals;

    this.signals = {

        updated: new SIGNALS.Signal(),

    };

    this.begin();

    this.maxDuration = -Infinity;
    this.minDuration = Infinity;
    this.lastDuration = Infinity;

    this.lastFps = Infinity;

}

NGL.Stats.prototype = {

    update: function(){

        this.startTime = this.end();

        this.signals.updated.dispatch();

    },

    begin: function(){

        this.startTime = Date.now();
        this.prevFpsTime = this.startTime;

    },

    end: function(){

        var time = Date.now();

        this.lastDuration = time - this.startTime;

        this.minDuration = Math.min( this.minDuration, this.lastDuration );
        this.maxDuration = Math.max( this.maxDuration, this.lastDuration );

        this.frames += 1;

        if( time > this.prevFpsTime + 1000 ) {

            this.lastFps = Math.round(
                ( this.frames * 1000 ) / ( time - this.startTime )
            );

            this.prevFpsTime = time;

        }

        this.frames = 0;

        return time;

    }

};


///////////
// Viewer

/**
 * [Viewer description]
 * @class
 * @param {String} eid
 */
NGL.Viewer = function( eid ){

    var SIGNALS = signals;

    this.signals = {

        orientationChanged: new SIGNALS.Signal(),

    };

    if( eid ){
        this.container = document.getElementById( eid );
    }else{
        this.container = document.createElement( 'div' );
    }

    if ( this.container === document ) {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
    } else {
        var box = this.container.getBoundingClientRect();
        this.width = box.width;
        this.height = box.height;
    }

    this.aspect = this.width / this.height;

    this.initParams();
    this.initCamera();
    this.initScene();
    this.initRenderer();
    this.initControls();
    this.initStats();

    // fog & background
    this.setBackground();
    this.setFog();

    this.boundingBox = new THREE.Box3();
    this.distVector = new THREE.Vector3();

    this.info = {

        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },

        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }

    };

};

NGL.Viewer.prototype = {

    constructor: NGL.Viewer,

    initParams: function(){

        this.params = {

            fogColor: new THREE.Color( 0x000000 ),
            fogNear: 50,
            fogFar: 100,

            backgroundColor: new THREE.Color( 0x000000 ),

            cameraType: 1,
            cameraFov: 40,
            cameraZ: -80, // FIXME initial value should be automatically determined

            clipNear: 0,
            clipFar: 100,
            clipDist: 10,

        };

    },

    initCamera: function(){

        var p = this.params;
        var lookAt = new THREE.Vector3( 0, 0, 0 );

        this.perspectiveCamera = new THREE.PerspectiveCamera(
            p.cameraFov, this.aspect, 0.1, 10000
        );
        this.perspectiveCamera.position.z = p.cameraZ;
        this.perspectiveCamera.lookAt( lookAt );

        this.camera = this.perspectiveCamera;

        this.camera.updateProjectionMatrix();

    },

    initRenderer: function(){

        this.renderer = new THREE.WebGLRenderer( {
            preserveDrawingBuffer: true,
            alpha: true,
            antialias: true
        } );
        this.renderer.setPixelRatio( window.devicePixelRatio );
        this.renderer.setSize( this.width, this.height );
        this.renderer.autoClear = false;
        this.renderer.sortObjects = true;

        var gl = this.renderer.context;

        NGL.extensionFragDepth = gl.getExtension( 'EXT_frag_depth' );
        if( !NGL.extensionFragDepth ){
            NGL.info( "EXT_frag_depth not supported" );
        }

        if( !this.renderer.extensions.get( 'OES_standard_derivatives' ) ){
            NGL.warn( "OES_standard_derivatives not supported" );
        }

        if( !gl.getExtension( 'OES_element_index_uint' ) ){
            NGL.indexUint16 = true;
            NGL.info( "OES_element_index_uint not supported" );
        }

        this.container.appendChild( this.renderer.domElement );

        //

        var scope = this;

        var originalSetProgram = this.renderer.setProgram;

        this.renderer.setProgram = function( camera, lights, fog, material, object ){

            var program = originalSetProgram(
                camera, lights, fog, material, object
            );

            scope.updateObjectUniforms( object, material, camera );

            scope.renderer.loadUniformsGeneric(
                scope.renderer.properties.get( material ).uniformsList
            );

            return program;

        };

        // picking texture

        if( !this.renderer.extensions.get( 'OES_texture_float' ) ){
            NGL.warn( "OES_texture_float not supported" );
        }

        if( !gl.getExtension( "WEBGL_color_buffer_float" ) ){
            NGL.warn( "WEBGL_color_buffer_float not supported" );
        }

        this.pickingTexture = new THREE.WebGLRenderTarget(
            this.width * window.devicePixelRatio,
            this.height * window.devicePixelRatio,
            {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                stencilBuffer: false,
                format: THREE.RGBAFormat,
                type: this.supportsReadPixelsFloat() ? THREE.FloatType : THREE.UnsignedByteType
            }
        );
        this.pickingTexture.generateMipmaps = false;

    },

    supportsReadPixelsFloat: function(){

        var value = undefined;

        return function(){

            if( value === undefined ){

                var gl = this.renderer.context;

                value = (

                    ( NGL.browser === "Chrome" &&
                        this.renderer.extensions.get( 'OES_texture_float' ) ) ||

                    ( this.renderer.extensions.get( 'OES_texture_float' ) &&
                        gl.getExtension( "WEBGL_color_buffer_float" ) )

                );

            }

            return value;

        }

    }(),

    initScene: function(){

        if( !this.scene ){
            this.scene = new THREE.Scene();
        }

        this.rotationGroup = new THREE.Group();
        this.rotationGroup.name = "rotationGroup";
        this.scene.add( this.rotationGroup );

        this.modelGroup = new THREE.Group();
        this.modelGroup.name = "modelGroup";
        this.rotationGroup.add( this.modelGroup );

        this.pickingGroup = new THREE.Group();
        this.pickingGroup.name = "pickingGroup";
        this.rotationGroup.add( this.pickingGroup );

        this.backgroundGroup = new THREE.Group();
        this.backgroundGroup.name = "backgroundGroup";
        this.rotationGroup.add( this.backgroundGroup );

        this.modelGroup.fog = new THREE.Fog();

    },

    initControls: function(){

        this.controls = new THREE.TrackballControls(
            this.camera, this.renderer.domElement
        );

        this.controls.rotateSpeed = 2.0;
        this.controls.zoomSpeed = 1.2;
        this.controls.panSpeed = 0.8;
        this.controls.staticMoving = true;
        // this.controls.dynamicDampingFactor = 0.3;
        this.controls.cylindricalRotation = true;
        this.controls.keys = [ 65, 83, 68 ];

        this.controls.addEventListener(
            'change', this.requestRender.bind( this )
        );

        document.addEventListener(
            'mousemove',
            this.controls.update.bind( this.controls ),
            false
        );

        document.addEventListener(
            'touchmove',
            this.controls.update.bind( this.controls ),
            false
        );

        this.controls.addEventListener(
            'change',
            function(){
                this.signals.orientationChanged.dispatch();
            }.bind( this ),
            false
        );

    },

    initStats: function(){

        this.stats = new NGL.Stats();

    },

    add: function( buffer, instanceList ){

        // NGL.time( "Viewer.add" );

        if( instanceList ){

            instanceList.forEach( function( instance ){

                this.addBuffer( buffer, instance );

            }, this );

        }else{

            this.addBuffer( buffer );

        }

        if( buffer.background ){
            this.backgroundGroup.add( buffer.group );
            this.backgroundGroup.add( buffer.wireframeGroup );
        }else{
            this.modelGroup.add( buffer.group );
            this.modelGroup.add( buffer.wireframeGroup );
        }

        if( buffer.pickable ){
            this.pickingGroup.add( buffer.pickingGroup );
        }

        this.rotationGroup.updateMatrixWorld();

        this.requestRender();

        // NGL.timeEnd( "Viewer.add" );

    },

    addBuffer: function( buffer, instance ){

        // NGL.time( "Viewer.addBuffer" );

        var mesh = buffer.getMesh();
        mesh.userData[ "buffer" ] = buffer;
        if( instance ){
            mesh.applyMatrix( instance.matrix );
        }
        buffer.group.add( mesh );

        var wireframeMesh = buffer.getWireframeMesh();
        wireframeMesh.userData[ "buffer" ] = buffer;
        if( instance ){
            // wireframeMesh.applyMatrix( instance.matrix );
            wireframeMesh.matrix.copy( mesh.matrix );
            wireframeMesh.position.copy( mesh.position );
            wireframeMesh.quaternion.copy( mesh.quaternion );
            wireframeMesh.scale.copy( mesh.scale );
        }
        buffer.wireframeGroup.add( wireframeMesh );

        if( buffer.pickable ){

            var pickingMesh = buffer.getPickingMesh();
            pickingMesh.userData[ "buffer" ] = buffer;
            if( instance ){
                // pickingMesh.applyMatrix( instance.matrix );
                pickingMesh.matrix.copy( mesh.matrix );
                pickingMesh.position.copy( mesh.position );
                pickingMesh.quaternion.copy( mesh.quaternion );
                pickingMesh.scale.copy( mesh.scale );
                pickingMesh.userData[ "instance" ] = instance;
            }
            buffer.pickingGroup.add( pickingMesh );

        }

        if( instance ){
            this.updateBoundingBox( buffer.geometry, instance.matrix );
        }else{
            this.updateBoundingBox( buffer.geometry );
        }

        // NGL.timeEnd( "Viewer.addBuffer" );

    },

    remove: function( buffer ){

        this.rotationGroup.children.forEach( function( group ){
            group.remove( buffer.group );
            group.remove( buffer.wireframeGroup );
        } );

        if( buffer.pickable ){
            this.pickingGroup.remove( buffer.pickingGroup );
        }

        this.updateBoundingBox();

        // this.requestRender();

    },

    updateBoundingBox: function( geometry, matrix ){

        var gbb;
        var bb = this.boundingBox;

        if( this.boundingBoxMesh ){
            this.modelGroup.remove( this.boundingBoxMesh );
            this.boundingBoxMesh.material.dispose();
            this.boundingBoxMesh.geometry.dispose();
        }

        if( geometry ){

            if( !geometry.boundingBox ){
                geometry.computeBoundingBox();
            }

            if( matrix ){
                gbb = geometry.boundingBox.clone();
                gbb.applyMatrix4( matrix );
            }else{
                gbb = geometry.boundingBox;
            }

            if( gbb.min.equals( gbb.max ) ){
                // mainly to give a single impostor geometry some volume
                // as it is only expanded in the shader on the GPU
                gbb.expandByScalar( 5 );
            }

            bb.expandByPoint( gbb.min );
            bb.expandByPoint( gbb.max );

        }else{

            bb.makeEmpty();

            this.rotationGroup.traverse( function ( node ){

                if ( node.geometry !== undefined ){

                    if( !node.geometry.boundingBox ){
                        node.geometry.computeBoundingBox();
                    }

                    if( node.userData[ "instance" ] ){
                        gbb = node.geometry.boundingBox.clone();
                        gbb.applyMatrix4( node.userData[ "instance" ].matrix );
                    }else{
                        gbb = node.geometry.boundingBox;
                    }

                    if( gbb.min.equals( gbb.max ) ){
                        // mainly to give a single impostor geometry some volume
                        // as it is only expanded in the shader on the GPU
                        gbb.expandByScalar( 5 );
                    }

                    bb.expandByPoint( gbb.min );
                    bb.expandByPoint( gbb.max );

                }

            } );

        }

        this.controls.maxDistance = bb.size().length() * 10;

        if( NGL.debug ){

            var bbSize = bb.size();
            var boxGeometry = new THREE.BoxGeometry(
                bbSize.x, bbSize.y, bbSize.z
            );
            var wireframeBox = new THREE.WireframeGeometry( boxGeometry );
            this.boundingBoxMesh = new THREE.LineSegments( wireframeBox );
            bb.center( this.boundingBoxMesh.position );
            this.modelGroup.add( this.boundingBoxMesh );

        }

    },

    getImage: function( type, quality ){

        return this.renderer.domElement.toBlob( type, quality );

    },

    setFog: function( color, near, far ){

        var p = this.params;

        if( color ) p.fogColor.set( color );
        if( near ) p.fogNear = near;
        if( far ) p.fogFar = far;

        this.requestRender();

    },

    setBackground: function( color ){

        var p = this.params;

        if( color ) p.backgroundColor.set( color );

        this.setFog( p.backgroundColor );
        this.renderer.setClearColor( p.backgroundColor, 1 );

        this.requestRender();

    },

    setCamera: function( type, fov, near, far ){

        var p = this.params;

        if( type!==null ) p.cameraType = type;
        if( fov ) p.cameraFov = fov;
        if( near ) p.cameraNear = near;
        if( far ) p.cameraFar = far;

        this.camera = this.perspectiveCamera;

        this.perspectiveCamera.fov = p.cameraFov;
        this.perspectiveCamera.near = p.cameraNear;
        this.perspectiveCamera.far = p.cameraFar;

        this.controls.object = this.camera;
        this.camera.updateProjectionMatrix();

        this.requestRender();

    },

    setClip: function( near, far ){

        var p = this.params;

        if( near ) p.clipNear = near;
        if( far ) p.clipFar = far;

        this.requestRender();

    },

    handleResize: function(){

        if( this.container === document ){

            this.width = window.innerWidth;
            this.height = window.innerHeight;

        }else{

            var box = this.container.getBoundingClientRect();
            this.width = box.width;
            this.height = box.height;

        }

        this.aspect = this.width / this.height;
        this.perspectiveCamera.aspect = this.aspect;
        this.camera.updateProjectionMatrix();

        this.renderer.setPixelRatio( window.devicePixelRatio );
        this.renderer.setSize( this.width, this.height );

        this.pickingTexture.setSize(
            this.width * window.devicePixelRatio,
            this.height * window.devicePixelRatio
        );

        this.controls.handleResize();

        this.requestRender();

    },

    updateInfo: function( reset ){

        var info = this.info;
        var memory = info.memory;
        var render = info.render;

        if( reset ){

            memory.programs = 0;
            memory.geometries = 0;
            memory.textures = 0;

            render.calls = 0;
            render.vertices = 0;
            render.faces = 0;
            render.points = 0;

        }else{

            var rInfo = this.renderer.info;
            var rMemory = rInfo.memory;
            var rRender = rInfo.render;

            memory.programs = rMemory.programs;
            memory.geometries = rMemory.geometries;
            memory.textures = rMemory.textures;

            render.calls += rRender.calls;
            render.vertices += rRender.vertices;
            render.faces += rRender.faces;
            render.points += rRender.points;

        }

    },

    animate: function(){

        requestAnimationFrame( this.animate.bind( this ) );

        this.controls.update();
        // this.stats.update();

    },

    screenshot: function( params ){

        NGL.screenshot( this, params );

    },

    pick: function(){

        var pixelBufferFloat = new Float32Array( 4 );
        var pixelBufferUint = new Uint8Array( 4 );

        return function( x, y ){

            var gid, object, instance, bondId;

            var pixelBuffer = this.supportsReadPixelsFloat() ? pixelBufferFloat : pixelBufferUint;

            this.render( null, true );

            var gl = this.renderer.context;

            this.renderer.setRenderTarget( this.pickingTexture );

            gl.readPixels(
                x * window.devicePixelRatio,
                y * window.devicePixelRatio,
                1,
                1,
                gl.RGBA,
                this.supportsReadPixelsFloat() ? gl.FLOAT : gl.UNSIGNED_BYTE,
                pixelBuffer
            );

            this.renderer.setRenderTarget();

            if( this.supportsReadPixelsFloat() ){

                gid =
                    ( ( Math.round( pixelBuffer[0] * 255 ) << 16 ) & 0xFF0000 ) |
                    ( ( Math.round( pixelBuffer[1] * 255 ) << 8 ) & 0x00FF00 ) |
                    ( ( Math.round( pixelBuffer[2] * 255 ) ) & 0x0000FF );

            }else{

                gid =
                    ( pixelBuffer[0] << 16 ) |
                    ( pixelBuffer[1] << 8 ) |
                    ( pixelBuffer[2] );

            }

            object = this.pickingGroup.getObjectById(
                Math.round( pixelBuffer[ 3 ] )
            );

            if( object && object.userData.instance ){

                instance = object.userData.instance;

            }

            if( NGL.debug ){

                var rgba = Array.apply( [], pixelBuffer );

                NGL.log( pixelBuffer );

                NGL.log(
                    "picked color",
                    [
                        ( rgba[0] ).toPrecision(2),
                        ( rgba[1] ).toPrecision(2),
                        ( rgba[2] ).toPrecision(2),
                        ( rgba[3] ).toPrecision(2)
                    ]
                );
                NGL.log( "picked gid", gid );
                NGL.log( "picked instance", instance );
                NGL.log( "picked position", x, y );
                NGL.log( "devicePixelRatio", window.devicePixelRatio );

            }

            return {
                "gid": gid,
                "instance": instance
            };

        };

    }(),

    requestRender: function(){

        if( this._renderPending ){
            // NGL.info( "there is still a 'render' call pending" );
            return;
        }

        this._renderPending = true;
        requestAnimationFrame( this.render.bind( this ) );

    },

    render: function( e, picking, tileing ){

        // NGL.time( "Viewer.render" );

        if( this._rendering ){
            NGL.warn( "tried to call 'render' from within 'render'" );
            return;
        }

        this._rendering = true;

        // clipping

        var cDist = this.camera.position.length();
        if( !cDist ){
            // recover from a broken (NaN) camera position
            this.camera.position.set( 0, 0, this.params.cameraZ );
            cDist = Math.abs( this.params.cameraZ );
        }

        var bRadius = Math.max( 10, this.boundingBox.size().length() * 0.5 );
        if( bRadius === Infinity || bRadius === -Infinity ){
            // console.warn( "something wrong with bRadius" );
            bRadius = 50;
        }
        bRadius += this.boundingBox.center( this.distVector )
            .add( this.rotationGroup.position )
            .length();

        var nearFactor = ( 50 - this.params.clipNear ) / 50;
        var farFactor = - ( 50 - this.params.clipFar ) / 50;
        var nearClip = cDist - ( bRadius * nearFactor );
        this.camera.near = Math.max(
            0.1,
            // cDist - ( bRadius * nearFactor ),
            this.params.clipDist
        );
        this.camera.far = Math.max(
            1,
            cDist + ( bRadius * farFactor )
        );
        this.nearClip = nearClip;

        // fog

        var fogNearFactor = ( 50 - this.params.fogNear ) / 50;
        var fogFarFactor = - ( 50 - this.params.fogFar ) / 50;
        var fog = this.modelGroup.fog;
        fog.color.set( this.params.fogColor );
        fog.near = Math.max( 0.1, cDist - ( bRadius * fogNearFactor ) );
        fog.far = Math.max( 1, cDist + ( bRadius * fogFarFactor ) );

        //

        this.camera.updateMatrix();
        this.camera.updateMatrixWorld( true );
        this.camera.matrixWorldInverse.getInverse( this.camera.matrixWorld );
        if( !tileing ) this.camera.updateProjectionMatrix();

        this.updateMaterialUniforms( this.scene, this.camera );
        this.sortProjectedPosition( this.scene, this.camera );

        // render

        this.updateInfo( true );

        if( picking ){

            this.renderer.clearTarget( this.pickingTexture );

            this.renderer.render(
                this.pickingGroup, this.camera, this.pickingTexture
            );
            this.updateInfo();

            // FIXME required, maybe a three.js bug
            this.renderer.setRenderTarget();

            if( NGL.debug ){

                this.renderer.clear();
                this.renderer.render( this.pickingGroup, this.camera );

            }

        }else{

            this.renderer.clear();

            this.renderer.render( this.backgroundGroup, this.camera );
            this.renderer.clearDepth();
            this.updateInfo();

            this.renderer.render( this.modelGroup, this.camera );
            this.updateInfo();

        }

        this._rendering = false;
        this._renderPending = false;

        // NGL.timeEnd( "Viewer.render" );
        // NGL.log( this.info.memory, this.info.render );

    },

    updateMaterialUniforms: function(){

        var projectionMatrixInverse = new THREE.Matrix4();
        var projectionMatrixTranspose = new THREE.Matrix4();

        return function( group, camera ){

            var nearClip = this.nearClip;

            projectionMatrixInverse.getInverse(
                camera.projectionMatrix
            );

            projectionMatrixTranspose.copy(
                camera.projectionMatrix
            ).transpose();

            group.traverse( function ( o ){

                if( !o.material ) return;

                var u = o.material.uniforms;
                if( !u ) return;

                if( u.nearClip ){
                    u.nearClip.value = nearClip;
                }

                if( u.projectionMatrixInverse ){
                    u.projectionMatrixInverse.value.copy(
                        projectionMatrixInverse
                    );
                }

                if( u.projectionMatrixTranspose ){
                    u.projectionMatrixTranspose.value.copy(
                        projectionMatrixTranspose
                    );
                }

            } );

        }

    }(),

    updateObjectUniforms: function(){

        var matrix = new THREE.Matrix4();

        return function( object, material, camera ){

            var o = object;

            if( !o.material ) return;

            var u = o.material.uniforms;
            if( !u ) return;

            if( u.objectId ){
                u.objectId.value = this.supportsReadPixelsFloat() ? o.id : o.id / 255;
            }

            if( u.modelViewMatrixInverse ){
                u.modelViewMatrixInverse.value.getInverse(
                    o.modelViewMatrix
                );
            }

            if( u.modelViewMatrixInverseTranspose ){
                if( u.modelViewMatrixInverse ){
                    u.modelViewMatrixInverseTranspose.value.copy(
                        u.modelViewMatrixInverse.value
                    ).transpose();
                }else{
                    u.modelViewMatrixInverseTranspose.value
                        .getInverse( o.modelViewMatrix )
                        .transpose();
                }
            }

            if( u.modelViewProjectionMatrix ){
                u.modelViewProjectionMatrix.value.multiplyMatrices(
                    camera.projectionMatrix, o.modelViewMatrix
                );
            }

            if( u.modelViewProjectionMatrixInverse ){
                if( u.modelViewProjectionMatrix ){
                    matrix.copy(
                        u.modelViewProjectionMatrix.value
                    );
                    u.modelViewProjectionMatrixInverse.value.getInverse(
                        matrix
                    );
                }else{
                    matrix.multiplyMatrices(
                        camera.projectionMatrix, o.modelViewMatrix
                    );
                    u.modelViewProjectionMatrixInverse.value.getInverse(
                        matrix
                    );
                }
            }

        }

    }(),

    sortProjectedPosition: function(){

        var lastCall = 0;

        var vertex = new THREE.Vector3();
        var matrix = new THREE.Matrix4();
        var modelViewProjectionMatrix = new THREE.Matrix4();

        return function( scene, camera ){

            // NGL.time( "sort" );

            scene.traverseVisible( function ( o ){

                if( ! ( o instanceof THREE.PointCloud ) || ! o.sortParticles ){

                    return;

                }

                matrix.multiplyMatrices(
                    camera.matrixWorldInverse, o.matrixWorld
                );
                modelViewProjectionMatrix.multiplyMatrices(
                    camera.projectionMatrix, matrix
                )

                var attributes = o.geometry.attributes;
                var n = attributes.position.count;

                if( !o.userData.sortData ){
                    o.userData.sortData = {};
                }

                var sortData = o.userData.sortData;

                if( !sortData.__sortArray ){
                    sortData.__sortArray = new Float32Array( n * 2 );
                }

                var sortArray = sortData.__sortArray;

                for( var i = 0; i < n; ++i ){

                    var i2 = 2 * i;

                    vertex.fromArray( attributes.position.array, i * 3 );
                    vertex.applyProjection( modelViewProjectionMatrix );

                    // negate, so that sorting order is reversed
                    sortArray[ i2 ] = -vertex.z;
                    sortArray[ i2 + 1 ] = i;

                }

                THREE.TypedArrayUtils.quicksortIP( sortArray, 2, 0 );

                var index, indexSrc, indexDst, tmpTab;

                for( var name in attributes ){

                    var attr = attributes[ name ];
                    var array = attr.array;
                    var itemSize = attr.itemSize;

                    if( !sortData[ name ] ){
                        sortData[ name ] = new Float32Array(
                            itemSize * n
                        );
                    }

                    tmpTab = sortData[ name ];
                    sortData[ name ] = array;

                    for( var i = 0; i < n; ++i ){

                        index = sortArray[ i * 2 + 1 ];

                        for( var j = 0; j < itemSize; ++j ){
                            indexSrc = index * itemSize + j;
                            indexDst = i * itemSize + j;
                            tmpTab[ indexDst ] = array[ indexSrc ];
                        }

                    }

                    attributes[ name ].array = tmpTab;
                    attributes[ name ].needsUpdate = true;

                }

            } );

            // NGL.timeEnd( "sort" );

        }

    }(),

    clear: function(){

        NGL.log( "scene cleared" );

        this.scene.remove( this.rotationGroup );

        this.initScene();

        this.renderer.clear();

    },

    centerView: function(){

        var t = new THREE.Vector3();

        return function( zoom, center ){

            center = center || this.boundingBox.center();

            // remove any paning/translation
            this.controls.object.position.sub( this.controls.target );
            this.controls.target.copy( this.controls.target0 );

            t.copy( center ).multiplyScalar( -1 );

            if( zoom ){

                if( zoom === true ){

                    // automatic zoom that shows
                    // everything inside the bounding box

                    zoom = this.boundingBox.size().length() /
                        2 / Math.tan( Math.PI * this.camera.fov / 360 );

                }

                zoom = Math.max( zoom, 1.2 * this.params.clipDist );

                this.camera.position.multiplyScalar(
                    zoom / this.camera.position.length()
                );

            }

            this.rotationGroup.position.copy( t );
            this.rotationGroup.updateMatrixWorld();

            this.requestRender();

            this.signals.orientationChanged.dispatch();

        }

    }(),

    getOrientation: function(){

        return [
            this.camera.position.toArray(),
            this.camera.up.toArray(),
            this.rotationGroup.position.toArray(),
            this.controls.target.toArray()
        ];

    },

    setOrientation: function( orientation ){

        console.log( "setOrientation" );

        // remove any paning/translation
        this.controls.object.position.sub( this.controls.target );
        this.controls.target.copy( this.controls.target0 );

        this.controls.target.fromArray( orientation[ 3 ] );

        this.rotationGroup.position.fromArray( orientation[ 2 ] );
        this.rotationGroup.updateMatrixWorld();

        this.camera.up.fromArray( orientation[ 1 ] );
        this.camera.position.fromArray( orientation[ 0 ] );

        this.requestRender();

        this.signals.orientationChanged.dispatch();

    }

};


/////////////
// Renderer

NGL.TiledRenderer = function( renderer, camera, viewer, params ){

    var p = params || {};

    this.renderer = renderer;
    this.camera = camera;
    this.viewer = viewer;

    this.factor = p.factor!==undefined ? p.factor : 2;
    this.antialias = p.antialias!==undefined ? p.antialias : false;

    this.onProgress = p.onProgress;
    this.onFinish = p.onFinish;

    this.init();

};

NGL.TiledRenderer.prototype = {

    init: function(){

        if( this.antialias ) this.factor *= 2;

        this.n = this.factor * this.factor;

        // canvas

        var canvas = document.createElement( 'canvas' );
        canvas.style.display = "hidden";
        document.body.appendChild( canvas );

        if( this.antialias ){

            canvas.width = this.viewer.width * this.factor / 2;
            canvas.height = this.viewer.height * this.factor / 2;

        }else{

            canvas.width = this.viewer.width * this.factor;
            canvas.height = this.viewer.height * this.factor;

        }

        this.ctx = canvas.getContext( '2d' );
        this.canvas = canvas;

        //

        this.shearMatrix = new THREE.Matrix4();
        this.scaleMatrix = new THREE.Matrix4();

        var halfFov = THREE.Math.degToRad( this.camera.fov * 0.5 );

        this.near = this.camera.near;
        this.top = Math.tan( halfFov ) * this.near;
        this.bottom = -this.top;
        this.left = this.camera.aspect * this.bottom;
        this.right = this.camera.aspect * this.top;
        this.width = Math.abs( this.right - this.left );
        this.height = Math.abs( this.top - this.bottom );

    },

    makeAsymmetricFrustum: function( projectionMatrix, i ){

        var factor = this.factor;
        var near = this.near;
        var width = this.width;
        var height = this.height;

        var x = i % factor;
        var y = Math.floor( i / factor );

        this.shearMatrix.set(
            1, 0, ( x - ( factor - 1 ) * 0.5 ) * width / near, 0,
            0, 1, -( y - ( factor - 1 ) * 0.5 ) * height / near, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );

        this.scaleMatrix.set(
            factor, 0, 0, 0,
            0, factor, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );

        projectionMatrix
            .multiply( this.shearMatrix )
            .multiply( this.scaleMatrix );

        return projectionMatrix;

    },

    renderTile: function( i ){

        this.viewer.renderer.setPixelRatio(
            window.devicePixelRatio * this.factor
        );

        this.makeAsymmetricFrustum( this.camera.projectionMatrix, i );

        this.viewer.render( null, null, true );

        var x = ( i % this.factor ) * this.viewer.width;
        var y = Math.floor( i / this.factor ) * this.viewer.height;

        if( this.antialias ){

            this.ctx.drawImage(
                this.renderer.domElement,
                Math.floor( x / 2 ),
                Math.floor( y / 2 ),
                Math.ceil( this.viewer.width / 2 ),
                Math.ceil( this.viewer.height / 2 )
            );

        }else{

            this.ctx.drawImage(
                this.renderer.domElement,
                Math.floor( x ),
                Math.floor( y ),
                Math.ceil( this.viewer.width ),
                Math.ceil( this.viewer.height )
            );

        }

        this.camera.updateProjectionMatrix();

        if( typeof this.onProgress === "function" ){

            this.onProgress( i + 1, this.n, false );

        }

        this.viewer.renderer.setPixelRatio(
            window.devicePixelRatio
        );

    },

    render: function(){

        var n = this.n;

        for( var i = 0; i <= n; ++i ){

            if( i === n ){

                if( typeof this.onFinish === "function" ){

                    this.onFinish( i + 1, n, false );

                }

            }else{

                this.renderTile( i );

            }

        }

    },

    renderAsync: function(){

        var n = this.n;
        var renderTile = this.renderTile.bind( this );
        var onFinish = this.onFinish;

        for( var i = 0; i <= n; ++i ){

            setTimeout( function( i ){

                if( i === n ){

                    if( typeof onFinish === "function" ){

                        onFinish( i + 1, n, false );

                    }

                }else{

                    renderTile( i );

                }

            }, 0, i );

        }

    },

    dispose: function(){

        document.body.removeChild( this.canvas );

    }

};


NGL.screenshot = function( viewer, params ){

    var p = params || {};

    var trim = p.trim!==undefined ? p.trim : false;
    var type = p.type!==undefined ? p.type : "image/png";
    var quality = p.quality!==undefined ? p.quality : 1.0;
    var transparent = p.transparent!==undefined ? p.transparent : false;

    var factor = p.factor!==undefined ? p.factor : false;
    var antialias = p.antialias!==undefined ? p.antialias : false;

    var renderer = viewer.renderer;
    var camera = viewer.camera;

    var originalClearAlpha = renderer.getClearAlpha();
    var backgroundColor = renderer.getClearColor();

    if( transparent ){

        renderer.setClearAlpha( 0 );

    }

    var tiledRenderer = new NGL.TiledRenderer(

        renderer, camera, viewer,
        {
            factor: factor,
            antialias: antialias,
            onProgress: onProgress,
            onFinish: onFinish
        }

    );

    tiledRenderer.renderAsync();

    //

    function onProgress( i, n, finished ){

        if( typeof p.onProgress === "function" ){

            p.onProgress( i, n, finished );

        }

    }

    function onFinish( i, n ){

        save( n );

        if( transparent ){

            renderer.setClearAlpha( originalClearAlpha );

        }

        viewer.requestRender();

    }

    function save( n ){

        var canvas;
        var ext = type.split( "/" )[ 1 ];

        if( trim ){

            var bg = backgroundColor;
            var r = ( bg.r * 255 ) | 0;
            var g = ( bg.g * 255 ) | 0;
            var b = ( bg.b * 255 ) | 0;
            var a = transparent ? 0 : 255;

            canvas = NGL.trimCanvas( tiledRenderer.canvas, r, g, b, a );

        }else{

            canvas = tiledRenderer.canvas;

        }

        canvas.toBlob(

            function( blob ){

                NGL.download( blob, "screenshot." + ext );
                onProgress( n, n, true );

                tiledRenderer.dispose();

            },
            type, quality

        );

    }

};

// File:js/ngl/buffer.js

/**
 * @file Buffer
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


////////////////
// Buffer Core

NGL.DoubleSidedBuffer = function( buffer ){

    this.size = buffer.size;
    this.side = buffer.side;
    this.wireframe = buffer.wireframe;
    this.visible = buffer.visible;
    this.geometry = buffer.geometry;
    this.pickable = buffer.pickable;

    this.group = new THREE.Group();
    this.wireframeGroup = new THREE.Group();
    this.pickingGroup = new THREE.Group();

    var frontMeshes = [];
    var backMeshes = [];

    var frontBuffer = buffer;
    var backBuffer = new buffer.constructor();

    frontBuffer.makeMaterial();
    backBuffer.makeMaterial();

    backBuffer.geometry = buffer.geometry;
    backBuffer.wireframeGeometry = buffer.wireframeGeometry;
    backBuffer.size = buffer.size;
    backBuffer.attributeSize = buffer.attributeSize;
    backBuffer.pickable = buffer.pickable;
    backBuffer.setParameters( buffer.getParameters() );
    backBuffer.updateShader();

    frontBuffer.setParameters( {
        side: THREE.FrontSide
    } );
    backBuffer.setParameters( {
        side: THREE.BackSide,
        opacity: backBuffer.opacity
    } );

    this.getMesh = function( picking ){

        var front, back;

        if( picking ){
            back = backBuffer.getPickingMesh();
            front = frontBuffer.getPickingMesh();
        }else{
            back = backBuffer.getMesh();
            front = frontBuffer.getMesh();
        }

        frontMeshes.push( front );
        backMeshes.push( back );

        this.setParameters( { side: this.side } );

        return new THREE.Group().add( back, front );

    };

    this.getWireframeMesh = function(){

        return buffer.getWireframeMesh();

    };

    this.getPickingMesh = function(){

        return this.getMesh( true );

    };

    this.setAttributes = function( data ){

        buffer.setAttributes( data );

    };

    this.setParameters = function( data ){

        data = Object.assign( {}, data );

        if( data.side === THREE.FrontSide ){

            frontMeshes.forEach( function( m ){ m.visible = true; } );
            backMeshes.forEach( function( m ){ m.visible = false; } );

        }else if( data.side === THREE.BackSide ){

            frontMeshes.forEach( function( m ){ m.visible = false; } );
            backMeshes.forEach( function( m ){ m.visible = true; } );

        }else if( data.side === THREE.DoubleSide ){

            frontMeshes.forEach( function( m ){ m.visible = true; } );
            backMeshes.forEach( function( m ){ m.visible = true; } );

        }

        if( data.side !== undefined ){
            this.side = data.side;
        }
        delete data.side;

        frontBuffer.setParameters( data );

        if( data.wireframe !== undefined ){
            this.wireframe = data.wireframe;
            this.setVisibility( this.visible );
        }
        delete data.wireframe;

        backBuffer.setParameters( data );

    };

    this.setVisibility = NGL.Buffer.prototype.setVisibility;

    this.dispose = function(){

        frontBuffer.dispose();
        backBuffer.dispose();

    };

};


/**
 * The core buffer class.
 * @class
 * @private
 */
NGL.Buffer = function( position, color, index, pickingColor, params ){

    var p = params || {};

    // required properties:
    // - size
    // - attributeSize
    // - vertexShader
    // - fragmentShader

    this.pickable = false;
    this.dynamic = true;

    this.opaqueBack = p.opaqueBack !== undefined ? p.opaqueBack : false;
    this.dullInterior = p.dullInterior !== undefined ? p.dullInterior : false;
    this.side = p.side !== undefined ? p.side : THREE.DoubleSide;
    this.opacity = p.opacity !== undefined ? p.opacity : 1.0;
    this.nearClip = p.nearClip !== undefined ? p.nearClip : true;
    this.flatShaded = p.flatShaded !== undefined ? p.flatShaded : false;
    this.background = p.background !== undefined ? p.background : false;
    this.linewidth = p.linewidth !== undefined ? p.linewidth : 1;
    this.wireframe = p.wireframe !== undefined ? p.wireframe : false;
    this.wireframeLinewidth = p.wireframeLinewidth || 1;

    this.geometry = new THREE.BufferGeometry();

    this.addAttributes( {
        "position": { type: "v3", value: position },
        "color": { type: "c", value: color },
    } );

    if( index ){
        this.geometry.addIndex(
            new THREE.BufferAttribute( index, 1 )
        );
        this.geometry.index.setDynamic( this.dynamic );
    }

    if( pickingColor ){
        this.addAttributes( {
            "pickingColor": { type: "c", value: pickingColor },
        } );
        this.pickable = true;
    }

    this.uniforms = {
        "fogColor": { type: "c", value: null },
        "fogNear": { type: "f", value: 0.0 },
        "fogFar": { type: "f", value: 0.0 },
        "opacity": { type: "f", value: this.opacity },
        "nearClip": { type: "f", value: 0.0 }
    };

    this.pickingUniforms = {
        "nearClip": { type: "f", value: 0.0 },
        "objectId": { type: "f", value: 0.0 },
    };

    this.group = new THREE.Group();
    this.wireframeGroup = new THREE.Group();
    this.pickingGroup = new THREE.Group();

    this.makeWireframeGeometry();

};

NGL.Buffer.prototype = {

    constructor: NGL.Buffer,

    parameters: {

        opaqueBack: { updateShader: true },
        dullInterior: { updateShader: true },
        side: { updateShader: true, property: true },
        opacity: { uniform: true },
        nearClip: { updateShader: true },
        flatShaded: { updateShader: true },
        background: { updateShader: true },
        linewidth: { property: true },
        wireframe: { updateVisibility: true }

    },

    get transparent () {

        return this.opacity < 1;

    },

    makeMaterial: function(){

        this.material = new THREE.RawShaderMaterial( {
            uniforms: this.uniforms,
            vertexShader: "",
            fragmentShader: "",
            depthTest: true,
            transparent: this.transparent,
            depthWrite: true,
            lights: false,
            fog: true,
            side: this.side,
            linewidth: this.linewidth
        } );

        this.wireframeMaterial = new THREE.RawShaderMaterial( {
            uniforms: this.uniforms,
            vertexShader: "Line.vert",
            fragmentShader: "Line.frag",
            depthTest: true,
            transparent: this.transparent,
            depthWrite: true,
            lights: false,
            fog: true,
            side: this.side,
            linewidth: this.linewidth
        } );

        this.pickingMaterial = new THREE.RawShaderMaterial( {
            uniforms: this.pickingUniforms,
            vertexShader: "",
            fragmentShader: "",
            depthTest: true,
            transparent: false,
            depthWrite: true,
            lights: false,
            fog: false,
            side: this.side,
            linewidth: this.linewidth
        } );

        this.updateShader();

    },

    makeWireframeGeometry: function(){

        this.makeWireframeIndex();

        var geometry = this.geometry;
        var wireframeIndex = this.wireframeIndex;
        var wireframeGeometry = new THREE.BufferGeometry();

        wireframeGeometry.attributes = geometry.attributes;
        if( wireframeIndex ){
            wireframeGeometry.addIndex(
                new THREE.BufferAttribute( wireframeIndex, 1 )
                    .setDynamic( this.dynamic )
            );
            wireframeGeometry.addGroup( 0, this.wireframeIndexCount );
        }

        this.wireframeGeometry = wireframeGeometry;

    },

    makeWireframeIndex: function(){

        var edges = [];

        function checkEdge( a, b ) {

            if ( a > b ){

                var tmp = a;
                a = b;
                b = tmp;

            }

            var list = edges[ a ];

            if( list === undefined ){

                edges[ a ] = [ b ];
                return true;

            }else if( list.indexOf( b ) === -1 ){

                list.push( b );
                return true;

            }

            return false;

        }

        return function(){

            var index = this.geometry.index;

            if( index ){

                var array = index.array;
                var n = array.length;
                if( this.geometry.groups.length ){
                    n = this.geometry.groups[ 0 ].count;
                }
                var wireframeIndex;
                if( this.wireframeIndex && this.wireframeIndex.length > n * 2 ){
                    wireframeIndex = this.wireframeIndex;
                }else{
                    wireframeIndex = new Uint32Array( n * 2 );
                }

                var j = 0;
                edges.length = 0;

                for( var i = 0; i < n; i += 3 ){

                    var a = array[ i + 0 ];
                    var b = array[ i + 1 ];
                    var c = array[ i + 2 ];

                    if( checkEdge( a, b ) ){
                        wireframeIndex[ j + 0 ] = a;
                        wireframeIndex[ j + 1 ] = b;
                        j += 2;
                    }
                    if( checkEdge( b, c ) ){
                        wireframeIndex[ j + 0 ] = b;
                        wireframeIndex[ j + 1 ] = c;
                        j += 2;
                    }
                    if( checkEdge( c, a ) ){
                        wireframeIndex[ j + 0 ] = c;
                        wireframeIndex[ j + 1 ] = a;
                        j += 2;
                    }

                }

                this.wireframeIndex = wireframeIndex;
                this.wireframeIndexCount = j;

            }

        }

    }(),

    updateWireframeIndex: function(){

        this.wireframeGeometry.clearGroups();
        this.makeWireframeIndex();

        if( this.wireframeIndex.length > this.wireframeGeometry.index.array.length ){

            this.wireframeGeometry.addIndex(
                new THREE.BufferAttribute( this.wireframeIndex, 1 )
                    .setDynamic( this.dynamic )
            );

        }else{

            this.wireframeGeometry.index.set( this.wireframeIndex );
            this.wireframeGeometry.index.needsUpdate = this.wireframeIndexCount > 0;
            this.wireframeGeometry.index.updateRange.count = this.wireframeIndexCount;

        }

        this.wireframeGeometry.addGroup( 0, this.wireframeIndexCount );

    },

    getRenderOrder: function(){

        var renderOrder = 0;

        if( this instanceof NGL.TextBuffer ){

            renderOrder = 1;

        }else if( this.transparent ){

            if( this instanceof NGL.SurfaceBuffer ){
                renderOrder = 3;
            }else{
                renderOrder = 2;
            }

        }

        return renderOrder;

    },

    getMesh: function(){

        var mesh;

        if( !this.material ) this.makeMaterial();

        if( this.line ){

            mesh = new THREE.LineSegments( this.geometry, this.material );

        }else if( this.point ){

            mesh = new THREE.PointCloud( this.geometry, this.material );
            if( this.sort ) mesh.sortParticles = true;

        }else{

            mesh = new THREE.Mesh( this.geometry, this.material );

        }

        mesh.frustumCulled = false;
        mesh.renderOrder = this.getRenderOrder();

        return mesh;

    },

    getWireframeMesh: function(){

        var mesh;

        if( !this.material ) this.makeMaterial();
        if( !this.wireframeGeometry ) this.makeWireframeGeometry();

        mesh = new THREE.LineSegments(
            this.wireframeGeometry, this.wireframeMaterial
        );

        mesh.frustumCulled = false;
        mesh.renderOrder = this.getRenderOrder();

        return mesh;

    },

    getPickingMesh: function(){

        var mesh;

        if( !this.material ) this.makeMaterial();

        mesh = new THREE.Mesh( this.geometry, this.pickingMaterial );

        mesh.frustumCulled = false;
        mesh.renderOrder = this.getRenderOrder();

        return mesh;

    },

    getShader: function( name, type ){

        return NGL.getShader( name, this.getDefines( type ) );

    },

    getVertexShader: function( type ){

        return this.getShader( this.vertexShader, type );

    },

    getFragmentShader: function( type ){

        return this.getShader( this.fragmentShader, type );

    },

    getDefines: function( type ){

        var defines = {};

        if( this.nearClip ){
            defines[ "NEAR_CLIP" ] = 1;
        }

        if( type === "picking" ){

            if( this.side === THREE.DoubleSide ){
                defines[ "DOUBLE_SIDED" ] = 1;
            }else if( this.side === THREE.BackSide ){
                defines[ "FLIP_SIDED" ] = 1;
            }
            defines[ "PICKING" ] = 1;

        }else{

            if( this.side === THREE.DoubleSide ){
                defines[ "DOUBLE_SIDED" ] = 1;
            }else if( this.side === THREE.BackSide ){
                defines[ "FLIP_SIDED" ] = 1;
            }
            if( type === "background" || this.background ){
                defines[ "NOLIGHT" ] = 1;
            }
            if( this.flatShaded ){
                defines[ "FLAT_SHADED" ] = 1;
            }
            if( this.opaqueBack ){
                defines[ "OPAQUE_BACK" ] = 1;
            }
            if( this.dullInterior ){
                defines[ "DULL_INTERIOR" ] = 1;
            }
            defines[ "USE_FOG" ] = 1;

        }

        return defines;

    },

    getParameters: function(){

        var params = {};

        for( var name in this.parameters ){
            params[ name ] = this[ name ];
        }

        return params;

    },

    addUniforms: function( uniforms ){

        this.uniforms = THREE.UniformsUtils.merge(
            [ this.uniforms, uniforms ]
        );

        this.pickingUniforms = THREE.UniformsUtils.merge(
            [ this.pickingUniforms, uniforms ]
        );

    },

    addAttributes: function( attributes ){

        var itemSize = {
            "f": 1, "v2": 2, "v3": 3, "c": 3
        };

        for( var name in attributes ){

            var buf;
            var a = attributes[ name ];

            if( a.value ){

                if( this.attributeSize * itemSize[ a.type ] !== a.value.length ){
                    NGL.error( "attribute value has wrong length", name );
                }

                buf = a.value;

            }else{

                buf = new Float32Array(
                    this.attributeSize * itemSize[ a.type ]
                );

            }

            this.geometry.addAttribute(
                name,
                new THREE.BufferAttribute( buf, itemSize[ a.type ] )
                    .setDynamic( this.dynamic )
            );

        }

    },

    updateRenderOrder: function(){

        var renderOrder = this.getRenderOrder();
        function setRenderOrder( mesh ){
            mesh.renderOrder = renderOrder;
        }

        this.group.children.forEach( setRenderOrder );
        if( this.pickingGroup ){
            this.pickingGroup.children.forEach( setRenderOrder );
        }

    },

    updateShader: function(){

        var m = this.material;
        var wm = this.wireframeMaterial;
        var pm = this.pickingMaterial;

        m.vertexShader = this.getVertexShader();
        m.fragmentShader = this.getFragmentShader();
        m.needsUpdate = true;

        wm.vertexShader = this.getShader( "Line.vert" );
        wm.fragmentShader = this.getShader( "Line.frag" );
        wm.needsUpdate = true;

        pm.vertexShader = this.getVertexShader( "picking" );
        pm.fragmentShader = this.getFragmentShader( "picking" );
        pm.needsUpdate = true;

    },

    setParameters: function( params ){

        if( !params ) return;

        var p = params;
        var tp = this.parameters;

        var propertyData = {};
        var uniformData = {};
        var doShaderUpdate = false;
        var doVisibilityUpdate = false;

        for( var name in p ){

            if( p[ name ] === undefined ) continue;
            if( tp[ name ] === undefined ) continue;

            this[ name ] = p[ name ];

            if( tp[ name ].property ){
                if( tp[ name ].property !== true ){
                    propertyData[ tp[ name ].property ] = p[ name ];
                }else{
                    propertyData[ name ] = p[ name ];
                }
            }

            if( tp[ name ].uniform ){
                uniformData[ name ] = p[ name ];
            }

            if( tp[ name ].updateShader ){
                doShaderUpdate = true;
            }

            if( tp[ name ].updateVisibility ){
                doVisibilityUpdate = true;
            }

            if( this.dynamic && name === "wireframe" && p[ name ] === true ){
                this.updateWireframeIndex();
            }

        }

        this.setProperties( propertyData );
        this.setUniforms( uniformData );
        if( doShaderUpdate ) this.updateShader();
        if( doVisibilityUpdate ) this.setVisibility( this.visible );

    },

    setAttributes: function( data ){

        /**
         * Sets buffer attributes
         * @param {Object} data - An object where the keys are the attribute names
         *      and the values are the attribute data.
         * @example
         * var buffer = new NGL.Buffer();
         * buffer.setAttributes({ attrName: attrData });
         */

        var geometry = this.geometry;
        var attributes = geometry.attributes;

        for( var name in data ){

            var array = data[ name ];
            var length = array.length;

            if( name === "index" ){

                geometry.clearGroups();

                if( length > geometry.index.array.length ){

                    geometry.addIndex(
                        new THREE.BufferAttribute( array, 1 )
                            .setDynamic( this.dynamic )
                    );

                }else{

                    geometry.index.set( array );
                    geometry.index.needsUpdate = length > 0;
                    geometry.index.updateRange.count = length;
                    geometry.addGroup( 0, length );

                }

                if( this.wireframe ) this.updateWireframeIndex();

            }else{

                var attribute = attributes[ name ];

                if( length > attribute.array.length ){

                    geometry.addAttribute(
                        name,
                        new THREE.BufferAttribute( array, attribute.itemSize )
                            .setDynamic( this.dynamic )
                    );

                }else{

                    attributes[ name ].set( array );
                    attributes[ name ].needsUpdate = length > 0;
                    attributes[ name ].updateRange.count = length;

                }

            }

        }

    },

    setUniforms: function( data ){

        if( !data ) return;

        var u = this.material.uniforms;
        var wu = this.wireframeMaterial.uniforms;
        var pu = this.pickingMaterial.uniforms;

        for( var name in data ){

            if( name === "opacity" ){
                this.setProperties( { transparent: data[ name ] < 1 } );
            }

            if( u[ name ] !== undefined ){
                u[ name ].value = data[ name ];
            }

            if( wu[ name ] !== undefined ){
                wu[ name ].value = data[ name ];
            }

            if( pu[ name ] !== undefined ){
                pu[ name ].value = data[ name ];
            }

        }

    },

    setProperties: function( data ){

        if( !data ) return;

        var m = this.material;
        var wm = this.wireframeMaterial;
        var pm = this.pickingMaterial;

        for( var name in data ){

            if( name === "transparent" ){
                this.updateRenderOrder();
            }

            if( m[ name ] !== undefined ){
                m[ name ] = data[ name ];
            }

            if( wm[ name ] !== undefined ){
                wm[ name ] = data[ name ];
            }

            if( pm[ name ] !== undefined ){
                pm[ name ] = data[ name ];
            }

        }

        m.needsUpdate = true;
        wm.needsUpdate = true;
        pm.needsUpdate = true;

    },

    setVisibility: function( value ){

        this.visible = value;

        if( this.wireframe ){

            this.group.visible = false;
            this.wireframeGroup.visible = value;
            if( this.pickable ){
                this.pickingGroup.visible = false;
            }

        }else{

            this.group.visible = value;
            this.wireframeGroup.visible = false;
            if( this.pickable ){
                this.pickingGroup.visible = value;
            }

        }

    },

    dispose: function(){

        if( this.material ) this.material.dispose();
        if( this.wireframeMaterial ) this.wireframeMaterial.dispose();
        if( this.pickingMaterial ) this.pickingMaterial.dispose();

        this.geometry.dispose();
        if( this.wireframeGeometry ) this.wireframeGeometry.dispose();

    }

};


NGL.MeshBuffer = function( position, color, index, normal, pickingColor, params ){

    var p = params || {};

    this.size = position ? position.length / 3 : 0;
    this.attributeSize = this.size;
    this.vertexShader = 'Mesh.vert';
    this.fragmentShader = 'Mesh.frag';

    NGL.Buffer.call( this, position, color, index, pickingColor, p );

    this.addAttributes( {
        "normal": { type: "v3", value: normal },
    } );

    if( normal === undefined ){
        this.geometry.computeVertexNormals();
    }

};

NGL.MeshBuffer.prototype = Object.create( NGL.Buffer.prototype );

NGL.MeshBuffer.prototype.constructor = NGL.MeshBuffer;


NGL.MappedBuffer = function( params ){

    // required
    // - mapping
    // - mappingType
    // - mappingSize
    // - mappingItemSize
    // - mappingIndices
    // - mappingIndicesSize

    this.size = this.count;
    this.attributeSize = this.count * this.mappingSize;

    this.index = new Uint32Array( this.count * this.mappingIndicesSize );

    this.makeIndex();

    NGL.Buffer.call( this, null, null, this.index, null, params );

    this.addAttributes( {
        "mapping": { type: this.mappingType, value: null },
    } );

};

NGL.MappedBuffer.prototype = Object.create( NGL.Buffer.prototype );

NGL.MappedBuffer.prototype.constructor = NGL.MappedBuffer;

NGL.MappedBuffer.prototype.setAttributes = function( data ){

    var count = this.count;
    var mappingSize = this.mappingSize;
    var attributes = this.geometry.attributes;

    var a, d, itemSize, array, n, i, j;

    for( var name in data ){

        d = data[ name ];
        a = attributes[ name ];
        itemSize = a.itemSize;
        array = a.array;

        for( var k = 0; k < count; ++k ) {

            n = k * itemSize;
            i = n * mappingSize;

            for( var l = 0; l < mappingSize; ++l ) {

                j = i + ( itemSize * l );

                for( var m = 0; m < itemSize; ++m ) {

                    array[ j + m ] = d[ n + m ];

                }

            }

        }

        a.needsUpdate = true;

    }

};

NGL.MappedBuffer.prototype.makeMapping = function(){

    var count = this.count;
    var mapping = this.mapping;
    var mappingSize = this.mappingSize;
    var mappingItemSize = this.mappingItemSize;

    var aMapping = this.geometry.attributes[ "mapping" ].array;

    for( var v = 0; v < count; v++ ) {

        aMapping.set( mapping, v * mappingItemSize * mappingSize );

    }

};

NGL.MappedBuffer.prototype.makeIndex = function(){

    var count = this.count;
    var mappingSize = this.mappingSize;
    var mappingIndices = this.mappingIndices;
    var mappingIndicesSize = this.mappingIndicesSize;
    var mappingItemSize = this.mappingItemSize;

    var index = this.index;

    var i, ix, it;

    for( var v = 0; v < count; v++ ) {

        i = v * mappingItemSize * mappingSize;
        ix = v * mappingIndicesSize;
        it = v * mappingSize;

        index.set( mappingIndices, ix );

        for( var s = 0; s < mappingIndicesSize; ++s ){
            index[ ix + s ] += it;
        }

    }

};


NGL.QuadBuffer = function( params ){

    this.mapping = new Float32Array([
        -1.0,  1.0,
        -1.0, -1.0,
         1.0,  1.0,
         1.0, -1.0
    ]);

    this.mappingIndices = new Uint32Array([
        0, 1, 2,
        1, 3, 2
    ]);

    this.mappingIndicesSize = 6;
    this.mappingType = "v2";
    this.mappingSize = 4;
    this.mappingItemSize = 2;

    NGL.MappedBuffer.call( this, params );

};

NGL.QuadBuffer.prototype = Object.create( NGL.MappedBuffer.prototype );

NGL.QuadBuffer.prototype.constructor = NGL.QuadBuffer;


NGL.BoxBuffer = function( params ){

    this.mapping = new Float32Array([
        -1.0, -1.0, -1.0,
         1.0, -1.0, -1.0,
         1.0, -1.0,  1.0,
        -1.0, -1.0,  1.0,
        -1.0,  1.0, -1.0,
         1.0,  1.0, -1.0,
         1.0,  1.0,  1.0,
        -1.0,  1.0,  1.0
    ]);

    this.mappingIndices = new Uint32Array([
        0, 1, 2,
        0, 2, 3,
        1, 5, 6,
        1, 6, 2,
        4, 6, 5,
        4, 7, 6,
        0, 7, 4,
        0, 3, 7,
        0, 5, 1,
        0, 4, 5,
        3, 2, 6,
        3, 6, 7
    ]);

    this.mappingIndicesSize = 36;
    this.mappingType = "v3";
    this.mappingSize = 8;
    this.mappingItemSize = 3;

    NGL.MappedBuffer.call( this, params );

};

NGL.BoxBuffer.prototype = Object.create( NGL.MappedBuffer.prototype );

NGL.BoxBuffer.prototype.constructor = NGL.BoxBuffer;


NGL.AlignedBoxBuffer = function( params ){

    this.mapping = new Float32Array([
        -1.0,  1.0, -1.0,
        -1.0, -1.0, -1.0,
         1.0,  1.0, -1.0,
         1.0,  1.0,  1.0,
         1.0, -1.0, -1.0,
         1.0, -1.0,  1.0
    ]);

    this.mappingIndices = new Uint32Array([
        0, 1, 2,
        1, 4, 2,
        2, 4, 3,
        4, 5, 3
    ]);

    this.mappingIndicesSize = 12;
    this.mappingType = "v3";
    this.mappingSize = 6;
    this.mappingItemSize = 3;

    NGL.MappedBuffer.call( this, params );

};

NGL.AlignedBoxBuffer.prototype = Object.create( NGL.MappedBuffer.prototype );

NGL.AlignedBoxBuffer.prototype.constructor = NGL.AlignedBoxBuffer;


////////////////////////
// Impostor Primitives

NGL.SphereImpostorBuffer = function( position, color, radius, pickingColor, params ){

    this.count = position.length / 3;
    this.vertexShader = 'SphereImpostor.vert';
    this.fragmentShader = 'SphereImpostor.frag';

    NGL.QuadBuffer.call( this, params );

    this.addUniforms( {
        'projectionMatrixInverse': { type: "m4", value: new THREE.Matrix4() },
    } );

    this.addAttributes( {
        "radius": { type: "f", value: null },
    } );

    this.setAttributes( {
        "position": position,
        "color": color,
        "radius": radius,
    } );

    if( pickingColor ){

        this.addAttributes( {
            "pickingColor": { type: "c", value: null },
        } );

        this.setAttributes( {
            "pickingColor": pickingColor,
        } );

        this.pickable = true;

    }

    this.makeMapping();

};

NGL.SphereImpostorBuffer.prototype = Object.create( NGL.QuadBuffer.prototype );

NGL.SphereImpostorBuffer.prototype.constructor = NGL.SphereImpostorBuffer;


NGL.CylinderImpostorBuffer = function( from, to, color, color2, radius, pickingColor, pickingColor2, params ){

    var p = params || p;

    // Moves the cylinder in camera space to get, for example,
    // one of multiple shifted screen-aligned cylinders.
    this.shift = p.shift !== undefined ? p.shift : 0;

    this.cap = p.cap !== undefined ? p.cap : true;

    this.count = from.length / 3;
    this.vertexShader = 'CylinderImpostor.vert';
    this.fragmentShader = 'CylinderImpostor.frag';

    NGL.AlignedBoxBuffer.call( this, p );

    this.addUniforms( {
        'modelViewMatrixInverse': { type: "m4", value: new THREE.Matrix4() },
        'shift': { type: "f", value: this.shift },
    } );

    this.addAttributes( {
        "position1": { type: "v3", value: null },
        "position2": { type: "v3", value: null },
        "color2": { type: "c", value: null },
        "radius": { type: "f", value: null },
    } );

    this.setAttributes( {
        "position": NGL.Utils.calculateCenterArray( from, to ),

        "position1": from,
        "position2": to,
        "color": color,
        "color2": color2,
        "radius": radius,
    } );

    if( pickingColor ){

        this.addAttributes( {
            "pickingColor": { type: "c", value: null },
            "pickingColor2": { type: "c", value: null },
        } );

        this.setAttributes( {
            "pickingColor": pickingColor,
            "pickingColor2": pickingColor2,
        } );

        this.pickable = true;

    }

    this.makeMapping();

    // FIXME
    // if( this.cap ){
    //     this.material.defines[ "CAP" ] = 1;
    // }

};

NGL.CylinderImpostorBuffer.prototype = Object.create( NGL.AlignedBoxBuffer.prototype );

NGL.CylinderImpostorBuffer.prototype.constructor = NGL.CylinderImpostorBuffer;

NGL.CylinderImpostorBuffer.prototype.getMaterial = function( type ){

    var material = NGL.Buffer.prototype.getMaterial.call( this, type );

    if( this.cap ){
        material.defines[ "CAP" ] = 1;
    }

    return material;

}


NGL.HyperballStickImpostorBuffer = function( position1, position2, color, color2, radius1, radius2, pickingColor, pickingColor2, params ){

    var p = params || p;

    var shrink = p.shrink !== undefined ? p.shrink : 0.14;

    this.count = position1.length / 3;
    this.vertexShader = 'HyperballStickImpostor.vert';
    this.fragmentShader = 'HyperballStickImpostor.frag';

    NGL.BoxBuffer.call( this, p );

    this.addUniforms( {
        'modelViewProjectionMatrix': { type: "m4", value: new THREE.Matrix4() },
        'modelViewProjectionMatrixInverse': { type: "m4", value: new THREE.Matrix4() },
        'modelViewMatrixInverseTranspose': { type: "m4", value: new THREE.Matrix4() },
        'shrink': { type: "f", value: shrink },
    } );

    this.addAttributes( {
        "color": { type: "c", value: null },
        "color2": { type: "c", value: null },
        "radius": { type: "f", value: null },
        "radius2": { type: "f", value: null },
        "position1": { type: "v3", value: null },
        "position2": { type: "v3", value: null },
    } );

    this.setAttributes( {
        "color": color,
        "color2": color2,
        "radius": radius1,
        "radius2": radius2,
        "position1": position1,
        "position2": position2,

        "position": NGL.Utils.calculateCenterArray( position1, position2 ),
    } );

    if( pickingColor ){

        this.addAttributes( {
            "pickingColor": { type: "c", value: null },
            "pickingColor2": { type: "c", value: null },
        } );

        this.setAttributes( {
            "pickingColor": pickingColor,
            "pickingColor2": pickingColor2,
        } );

        this.pickable = true;

    }

    this.makeMapping();

};

NGL.HyperballStickImpostorBuffer.prototype = Object.create( NGL.BoxBuffer.prototype );

NGL.HyperballStickImpostorBuffer.prototype.constructor = NGL.HyperballStickImpostorBuffer;

NGL.HyperballStickImpostorBuffer.prototype.parameters = Object.assign( {

    shrink: { uniform: true }

}, NGL.BoxBuffer.prototype.parameters );


////////////////////////
// Geometry Primitives

NGL.GeometryBuffer = function( position, color, pickingColor, params ){

    var p = params || {};

    // required properties:
    // - geo

    var geo = this.geo;

    var n = position.length / 3;
    var m = geo.vertices.length;
    var o = geo.faces.length;

    this.size = n * m;
    this.positionCount = n;

    this.geoPosition = NGL.Utils.positionFromGeometry( geo );
    this.geoNormal = NGL.Utils.normalFromGeometry( geo );
    this.geoIndex = NGL.Utils.indexFromGeometry( geo );

    this.transformedGeoPosition = new Float32Array( m * 3 );
    this.transformedGeoNormal = new Float32Array( m * 3 );

    this.meshPosition = new Float32Array( this.size * 3 );
    this.meshNormal = new Float32Array( this.size * 3 );
    this.meshIndex = new Uint32Array( n * o * 3 );
    this.meshColor = new Float32Array( this.size * 3 );
    this.meshPickingColor = new Float32Array( this.size * 3 );

    this.makeIndex();

    NGL.MeshBuffer.call(
        this, this.meshPosition, this.meshColor, this.meshIndex,
        this.meshNormal, this.meshPickingColor, p
    );

    this.initNormals = true;

    this.setAttributes( {
        position: position,
        color: color,
        pickingColor: pickingColor
    } );

    this.initNormals = false;

};

NGL.GeometryBuffer.prototype = Object.create( NGL.MeshBuffer.prototype );

NGL.GeometryBuffer.prototype.constructor = NGL.GeometryBuffer;

NGL.GeometryBuffer.prototype.applyPositionTransform = function(){};

NGL.GeometryBuffer.prototype.setAttributes = function(){

    var matrix = new THREE.Matrix4();
    var normalMatrix = new THREE.Matrix3();

    return function( data ){

        var attributes = this.geometry.attributes;

        var position, color, pickingColor;
        var geoPosition, geoNormal;
        var transformedGeoPosition, transformedGeoNormal;
        var meshPosition, meshColor, meshPickingColor, meshNormal;

        if( data[ "position" ] ){
            position = data[ "position" ];
            geoPosition = this.geoPosition;
            meshPosition = this.meshPosition;
            transformedGeoPosition = this.transformedGeoPosition;
            attributes[ "position" ].needsUpdate = true;
        }

        if( data[ "color" ] ){
            color = data[ "color" ];
            meshColor = this.meshColor;
            attributes[ "color" ].needsUpdate = true;
        }

        if( data[ "pickingColor" ] ){
            pickingColor = data[ "pickingColor" ];
            meshPickingColor = this.meshPickingColor;
            attributes[ "pickingColor" ].needsUpdate = true;
        }

        var updateNormals = !!( this.updateNormals && position );
        var initNormals = !!( this.initNormals && position );

        if( updateNormals || initNormals ){
            geoNormal = this.geoNormal;
            meshNormal = this.meshNormal;
            transformedGeoNormal = this.transformedGeoNormal;
            attributes[ "normal" ].needsUpdate = true;
        }

        var n = this.positionCount;
        var m = this.geo.vertices.length;

        var i, j, k, l, i3;

        for( i = 0; i < n; ++i ){

            k = i * m * 3;
            i3 = i * 3;

            if( position ){

                transformedGeoPosition.set( geoPosition );
                matrix.makeTranslation(
                    position[ i3 ], position[ i3 + 1 ], position[ i3 + 2 ]
                );
                this.applyPositionTransform( matrix, i, i3 );
                matrix.applyToVector3Array( transformedGeoPosition );

                meshPosition.set( transformedGeoPosition, k );

            }

            if( updateNormals ){

                transformedGeoNormal.set( geoNormal );
                normalMatrix.getNormalMatrix( matrix );
                normalMatrix.applyToVector3Array( transformedGeoNormal );

                meshNormal.set( transformedGeoNormal, k );

            }else if( initNormals ){

                meshNormal.set( geoNormal, k );

            }

            if( color ){

                for( j = 0; j < m; ++j ){

                    l = k + 3 * j;

                    meshColor[ l     ] = color[ i3     ];
                    meshColor[ l + 1 ] = color[ i3 + 1 ];
                    meshColor[ l + 2 ] = color[ i3 + 2 ];

                }

            }

            if( pickingColor ){

                for( j = 0; j < m; ++j ){

                    l = k + 3 * j;

                    meshPickingColor[ l     ] = pickingColor[ i3     ];
                    meshPickingColor[ l + 1 ] = pickingColor[ i3 + 1 ];
                    meshPickingColor[ l + 2 ] = pickingColor[ i3 + 2 ];

                }

            }

        }

    }

}();

NGL.GeometryBuffer.prototype.makeIndex = function(){

    var geoIndex = this.geoIndex;
    var meshIndex = this.meshIndex;

    var n = this.positionCount;
    var m = this.geo.vertices.length;
    var o = this.geo.faces.length;

    var p, i, j, q;
    var o3 = o * 3;

    for( i = 0; i < n; ++i ){

        j = i * o3;
        q = j + o3;

        meshIndex.set( geoIndex, j );
        for( p = j; p < q; ++p ) meshIndex[ p ] += i * m;

    }

};


NGL.SphereGeometryBuffer = function( position, color, radius, pickingColor, params ){

    var detail = params.sphereDetail !== undefined ? params.sphereDetail : 1;

    this.geo = new THREE.IcosahedronGeometry( 1, detail );

    this.setPositionTransform( radius );

    NGL.GeometryBuffer.call( this, position, color, pickingColor, params );

};

NGL.SphereGeometryBuffer.prototype = Object.create( NGL.GeometryBuffer.prototype );

NGL.SphereGeometryBuffer.prototype.constructor = NGL.SphereGeometryBuffer;

NGL.SphereGeometryBuffer.prototype.setPositionTransform = function( radius ){

    var r;
    var scale = new THREE.Vector3();

    this.applyPositionTransform = function( matrix, i ){

        r = radius[ i ];
        scale.set( r, r, r );
        matrix.scale( scale );

    }

};

NGL.SphereGeometryBuffer.prototype.setAttributes = function( data ){

    if( data[ "radius" ] ){
        this.setPositionTransform( data[ "radius" ] );
    }

    NGL.GeometryBuffer.prototype.setAttributes.call( this, data );

}


NGL.CylinderGeometryBuffer = function( from, to, color, color2, radius, pickingColor, pickingColor2, params ){

    var radiusSegments = params.radiusSegments !== undefined ? params.radiusSegments : 10;

    this.updateNormals = true;

    var matrix = new THREE.Matrix4().makeRotationX( Math.PI/ 2  );

    // FIXME params.cap
    this.geo = new THREE.CylinderGeometry( 1, 1, 1, radiusSegments, 1, true );
    this.geo.applyMatrix( matrix );

    var n = from.length;
    var m = radius.length;

    this._position = new Float32Array( n * 2 );
    this._color = new Float32Array( n * 2 );
    this._pickingColor = new Float32Array( n * 2 );
    this._from = new Float32Array( n * 2 );
    this._to = new Float32Array( n * 2 );
    this._radius = new Float32Array( m * 2 );

    this.__center = new Float32Array( n );

    NGL.GeometryBuffer.call(
        this, this._position, this._color, this._pickingColor, params
    );

    this.setPositionTransform( this._from, this._to, this._radius );

    this.setAttributes( {
        "position1": from,
        "position2": to,
        "color": color,
        "color2": color2,
        "radius": radius,
        "pickingColor": pickingColor,
        "pickingColor2": pickingColor2
    } );

};

NGL.CylinderGeometryBuffer.prototype = Object.create( NGL.GeometryBuffer.prototype );

NGL.CylinderImpostorBuffer.prototype.constructor = NGL.CylinderImpostorBuffer;

NGL.CylinderGeometryBuffer.prototype.setPositionTransform = function( from, to, radius ){

    var r;
    var scale = new THREE.Vector3();
    var eye = new THREE.Vector3();
    var target = new THREE.Vector3();
    var up = new THREE.Vector3( 0, 1, 0 );

    this.applyPositionTransform = function( matrix, i, i3 ){

        eye.fromArray( from, i3 );
        target.fromArray( to, i3 );
        matrix.lookAt( eye, target, up );

        r = radius[ i ];
        scale.set( r, r, eye.distanceTo( target ) );
        matrix.scale( scale );

    }

};

NGL.CylinderGeometryBuffer.prototype.setAttributes = function( data ){

    var n = this._position.length / 2;
    var m = this._radius.length / 2;
    var geoData = {};

    if( data[ "position1" ] && data[ "position2" ] ){

        NGL.Utils.calculateCenterArray(
            data[ "position1" ], data[ "position2" ], this.__center
        );
        NGL.Utils.calculateCenterArray(
            data[ "position1" ], this.__center, this._position
        );
        NGL.Utils.calculateCenterArray(
            this.__center, data[ "position2" ], this._position, n
        );

        this._from.set( data[ "position1" ] );
        this._from.set( this.__center, n );

        this._to.set( this.__center );
        this._to.set( data[ "position2" ], n );

        geoData[ "position" ] = this._position;

    }

    if( data[ "color" ] && data[ "color2" ] ){

        this._color.set( data[ "color" ] );
        this._color.set( data[ "color2" ], n );

        geoData[ "color" ] = this._color;

    }

    if( data[ "pickingColor" ] && data[ "pickingColor2" ] ){

        this._pickingColor.set( data[ "pickingColor" ] );
        this._pickingColor.set( data[ "pickingColor2" ], n );

        geoData[ "pickingColor" ] = this._pickingColor;

    }

    if( data[ "radius" ] ){

        this._radius.set( data[ "radius" ] );
        this._radius.set( data[ "radius" ], m );

    }

    if( ( data[ "position1" ] && data[ "position2" ] ) || data[ "radius" ] ){

        this.setPositionTransform( this._from, this._to, this._radius );

    }

    NGL.GeometryBuffer.prototype.setAttributes.call( this, geoData );

}


//////////////////////
// Pixel Primitives

NGL.PointBuffer = function( position, color, params ){

    var p = params || {};

    this.point = true;
    this.pointSize = p.pointSize !== undefined ? p.pointSize : 1;
    this.sizeAttenuation = p.sizeAttenuation !== undefined ? p.sizeAttenuation : true;
    this.sort = p.sort !== undefined ? p.sort : false;

    this.size = position.length / 3;
    this.attributeSize = this.size;
    // this.vertexShader = 'Point.vert';
    // this.fragmentShader = 'Point.frag';

    this.tex = new THREE.Texture(
        NGL.Resources[ '../img/radial.png' ]
        // NGL.Resources[ '../img/spark1.png' ]
        // NGL.Resources[ '../img/circle.png' ]
    );
    this.tex.needsUpdate = true;
    if( !this.sort ) this.tex.premultiplyAlpha = true;

    NGL.Buffer.call( this, position, color, undefined, undefined, p );

};

NGL.PointBuffer.prototype = Object.create( NGL.Buffer.prototype );

NGL.PointBuffer.prototype.constructor = NGL.PointBuffer;

NGL.PointBuffer.prototype.parameters = Object.assign( {

    pointSize: { property: "size" },
    sizeAttenuation: { property: true },
    sort: {}

}, NGL.Buffer.prototype.parameters, {

    opacity: { property: true },

} );

NGL.PointBuffer.prototype.makeMaterial = function(){

    var material;

    if( this.sort ){

        material = new THREE.PointCloudMaterial({
            map: this.tex,
            blending: THREE.NormalBlending,
            // blending: THREE.AdditiveBlending,
            depthTest:      true,
            transparent:    true,

            vertexColors: true,
            size: this.pointSize,
            sizeAttenuation: this.sizeAttenuation,
            // transparent: this.transparent,
            opacity: this.opacity,
            fog: true
        });

    }else{

        material = new THREE.PointCloudMaterial({
            map: this.tex,
            // blending:       THREE.AdditiveBlending,
            depthTest:      false,
            // alphaTest:      0.001,
            transparent:    true,

            blending: THREE.CustomBlending,
            // blendSrc: THREE.SrcAlphaFactor,
            // blendDst: THREE.OneMinusSrcAlphaFactor,
            blendEquation: THREE.AddEquation,

            // requires premultiplied alpha
            blendSrc: THREE.OneFactor,
            blendDst: THREE.OneMinusSrcAlphaFactor,

            vertexColors: true,
            size: this.pointSize,
            sizeAttenuation: this.sizeAttenuation,
            // transparent: this.transparent,
            opacity: this.opacity,
            fog: true
        });

    }

    this.material = material;
    this.wireframeMaterial = material;
    this.pickingMaterial = material;

};

NGL.PointBuffer.prototype.dispose = function(){

    NGL.Buffer.prototype.dispose.call( this );

    this.tex.dispose();

};


NGL.LineBuffer = function( from, to, color, color2, params ){

    var p = params || {};

    this.size = from.length / 3;
    this.vertexShader = 'Line.vert';
    this.fragmentShader = 'Line.frag';
    this.line = true;

    var n = this.size;
    var n6 = n * 6;
    var nX = n * 2 * 2;

    this.attributeSize = nX;

    this.linePosition = new Float32Array( nX * 3 );
    this.lineColor = new Float32Array( nX * 3 );

    NGL.Buffer.call(
        this, this.linePosition, this.lineColor, undefined, undefined, p
    );

    this.setAttributes( {
        from: from,
        to: to,
        color: color,
        color2: color2
    } );

};

NGL.LineBuffer.prototype = Object.create( NGL.Buffer.prototype );

NGL.LineBuffer.prototype.constructor = NGL.LineBuffer;

NGL.LineBuffer.prototype.setAttributes = function( data ){

    var from, to, color, color2;
    var aPosition, aColor;

    var attributes = this.geometry.attributes;

    if( data[ "from" ] && data[ "to" ] ){
        from = data[ "from" ];
        to = data[ "to" ];
        aPosition = attributes[ "position" ].array;
        attributes[ "position" ].needsUpdate = true;
    }

    if( data[ "color" ] && data[ "color2" ] ){
        color = data[ "color" ];
        color2 = data[ "color2" ];
        aColor = attributes[ "color" ].array;
        attributes[ "color" ].needsUpdate = true;
    }

    var n = this.size;
    var n6 = n * 6;

    var i, j, i2;
    var x, y, z, x1, y1, z1, x2, y2, z2;

    for( var v = 0; v < n; v++ ){

        j = v * 3;
        i = v * 2 * 3;
        i2 = i + n6;

        if( from && to ){

            x1 = from[ j     ];
            y1 = from[ j + 1 ];
            z1 = from[ j + 2 ];

            x2 = to[ j     ];
            y2 = to[ j + 1 ];
            z2 = to[ j + 2 ];

            x = ( x1 + x2 ) / 2.0;
            y = ( y1 + y2 ) / 2.0;
            z = ( z1 + z2 ) / 2.0;

            aPosition[ i     ] = x1;
            aPosition[ i + 1 ] = y1;
            aPosition[ i + 2 ] = z1;
            aPosition[ i + 3 ] = x;
            aPosition[ i + 4 ] = y;
            aPosition[ i + 5 ] = z;

            aPosition[ i2     ] = x;
            aPosition[ i2 + 1 ] = y;
            aPosition[ i2 + 2 ] = z;
            aPosition[ i2 + 3 ] = x2;
            aPosition[ i2 + 4 ] = y2;
            aPosition[ i2 + 5 ] = z2;

        }

        if( color && color2 ){

            aColor[ i     ] = aColor[ i + 3 ] = color[ j     ];
            aColor[ i + 1 ] = aColor[ i + 4 ] = color[ j + 1 ];
            aColor[ i + 2 ] = aColor[ i + 5 ] = color[ j + 2 ];

            aColor[ i2     ] = aColor[ i2 + 3 ] = color2[ j     ];
            aColor[ i2 + 1 ] = aColor[ i2 + 4 ] = color2[ j + 1 ];
            aColor[ i2 + 2 ] = aColor[ i2 + 5 ] = color2[ j + 2 ];

        }

    }

};


NGL.TraceBuffer = function( position, color, params ){

    var p = params || {};

    this.size = position.length / 3;
    this.vertexShader = 'Line.vert';
    this.fragmentShader = 'Line.frag';
    this.line = true;

    var n = this.size;
    var n1 = n - 1;

    this.attributeSize = n1 * 2;

    this.linePosition = new Float32Array( n1 * 3 * 2 );
    this.lineColor = new Float32Array( n1 * 3 * 2 );

    NGL.Buffer.call(
        this, this.linePosition, this.lineColor, undefined, undefined, p
    );

    this.setAttributes( {
        position: position,
        color: color
    } );

};

NGL.TraceBuffer.prototype = Object.create( NGL.Buffer.prototype );

NGL.TraceBuffer.prototype.constructor = NGL.TraceBuffer;

NGL.TraceBuffer.prototype.setAttributes = function( data ){

    var position, color;
    var linePosition, lineColor;

    var attributes = this.geometry.attributes;

    if( data[ "position" ] ){
        position = data[ "position" ];
        linePosition = attributes[ "position" ].array;
        attributes[ "position" ].needsUpdate = true;
    }

    if( data[ "color" ] ){
        color = data[ "color" ];
        lineColor = attributes[ "color" ].array;
        attributes[ "color" ].needsUpdate = true;
    }

    if( !position && !color ){
        NGL.warn( "NGL.TraceBuffer.prototype.setAttributes no data" );
        return;
    }

    var v, v2;
    var n = this.size;
    var n1 = n - 1;

    for( var i = 0; i < n1; ++i ){

        v = 3 * i;
        v2 = 3 * i * 2;

        if( position ){

            linePosition[ v2     ] = position[ v     ];
            linePosition[ v2 + 1 ] = position[ v + 1 ];
            linePosition[ v2 + 2 ] = position[ v + 2 ];

            linePosition[ v2 + 3 ] = position[ v + 3 ];
            linePosition[ v2 + 4 ] = position[ v + 4 ];
            linePosition[ v2 + 5 ] = position[ v + 5 ];

        }

        if( color ){

            lineColor[ v2     ] = color[ v     ];
            lineColor[ v2 + 1 ] = color[ v + 1 ];
            lineColor[ v2 + 2 ] = color[ v + 2 ];

            lineColor[ v2 + 3 ] = color[ v + 3 ];
            lineColor[ v2 + 4 ] = color[ v + 4 ];
            lineColor[ v2 + 5 ] = color[ v + 5 ];

        }

    }

};


//////////////////////
// Sprite Primitives

NGL.ParticleSpriteBuffer = function( position, color, radius ){

    this.count = position.length / 3;
    this.vertexShader = 'ParticleSprite.vert';
    this.fragmentShader = 'ParticleSprite.frag';

    NGL.QuadBuffer.call( this );

    this.addUniforms({
        'projectionMatrixInverse': { type: "m4", value: new THREE.Matrix4() },
    });

    this.addAttributes( {
        "radius": { type: "f", value: null },
    } );

    this.setAttributes( {
        "position": position,
        "color": color,
        "radius": radius,
    } );

    this.material.lights = false;

};

NGL.ParticleSpriteBuffer.prototype = Object.create( NGL.QuadBuffer.prototype );

NGL.ParticleSpriteBuffer.prototype.constructor = NGL.ParticleSpriteBuffer;


NGL.RibbonBuffer = function( position, normal, dir, color, size, pickingColor, params ){

    var p = params || {};

    var n = ( position.length / 3 ) - 1;
    var n4 = n * 4;
    var x = n4 * 3;

    this.meshPosition = new Float32Array( x );
    this.meshColor = new Float32Array( x );
    this.meshNormal = new Float32Array( x );
    this.meshPickingColor = pickingColor ? new Float32Array( x ) : undefined;
    this.meshIndex = new Uint32Array( x );

    this.makeIndex();

    NGL.MeshBuffer.call(
        this, this.meshPosition, this.meshColor, this.meshIndex,
        this.meshNormal, this.meshPickingColor, p
    );

    this.vertexShader = 'Ribbon.vert';
    this.fragmentShader = 'Ribbon.frag';

    this.geometry.addAttribute(
        'dir', new THREE.BufferAttribute( new Float32Array( x ), 3 )
    );
    this.geometry.addAttribute(
        'size', new THREE.BufferAttribute( new Float32Array( n4 ), 1 )
    );

    this.setAttributes( {
        position: position,
        normal: normal,
        dir: dir,
        color: color,
        size: size,
        pickingColor: pickingColor
    } );

};

NGL.RibbonBuffer.prototype = Object.create( NGL.MeshBuffer.prototype );

NGL.RibbonBuffer.prototype.constructor = NGL.RibbonBuffer;

NGL.RibbonBuffer.prototype.setAttributes = function( data ){

    var n4 = this.size;
    var n = n4 / 4;

    var attributes = this.geometry.attributes;

    var position, normal, size, dir, color, pickingColor;
    var aPosition, aNormal, aSize, aDir, aColor, aPickingColor;

    if( data[ "position" ] ){
        position = data[ "position" ];
        aPosition = attributes[ "position" ].array;
        attributes[ "position" ].needsUpdate = true;
    }

    if( data[ "normal" ] ){
        normal = data[ "normal" ];
        aNormal = attributes[ "normal" ].array;
        attributes[ "normal" ].needsUpdate = true;
    }

    if( data[ "size" ] ){
        size = data[ "size" ];
        aSize = attributes[ "size" ].array;
        attributes[ "size" ].needsUpdate = true;
    }

    if( data[ "dir" ] ){
        dir = data[ "dir" ];
        aDir = attributes[ "dir" ].array;
        attributes[ "dir" ].needsUpdate = true;
    }

    if( data[ "color" ] ){
        color = data[ "color" ];
        aColor = attributes[ "color" ].array;
        attributes[ "color" ].needsUpdate = true;
    }

    if( data[ "pickingColor" ] ){
        pickingColor = data[ "pickingColor" ];
        aPickingColor = attributes[ "pickingColor" ].array;
        attributes[ "pickingColor" ].needsUpdate = true;
    }

    var v, i, k, p, l, v3;
    var currSize;
    var prevSize = size ? size[ 0 ] : null;

    for( v = 0; v < n; ++v ){

        v3 = v * 3;
        k = v * 3 * 4;
        l = v * 4;

        if( position ){

            aPosition[ k     ] = aPosition[ k + 3 ] = position[ v3     ];
            aPosition[ k + 1 ] = aPosition[ k + 4 ] = position[ v3 + 1 ];
            aPosition[ k + 2 ] = aPosition[ k + 5 ] = position[ v3 + 2 ];

            aPosition[ k + 6 ] = aPosition[ k +  9 ] = position[ v3 + 3 ];
            aPosition[ k + 7 ] = aPosition[ k + 10 ] = position[ v3 + 4 ];
            aPosition[ k + 8 ] = aPosition[ k + 11 ] = position[ v3 + 5 ];

        }

        if( normal ){

            aNormal[ k     ] = aNormal[ k + 3 ] = -normal[ v3     ];
            aNormal[ k + 1 ] = aNormal[ k + 4 ] = -normal[ v3 + 1 ];
            aNormal[ k + 2 ] = aNormal[ k + 5 ] = -normal[ v3 + 2 ];

            aNormal[ k + 6 ] = aNormal[ k +  9 ] = -normal[ v3 + 3 ];
            aNormal[ k + 7 ] = aNormal[ k + 10 ] = -normal[ v3 + 4 ];
            aNormal[ k + 8 ] = aNormal[ k + 11 ] = -normal[ v3 + 5 ];

        }


        for( i = 0; i<4; ++i ){

            p = k + 3 * i;

            if( color ){

                aColor[ p     ] = color[ v3     ];
                aColor[ p + 1 ] = color[ v3 + 1 ];
                aColor[ p + 2 ] = color[ v3 + 2 ];

            }

            if( pickingColor ){

                aPickingColor[ p     ] = pickingColor[ v3     ];
                aPickingColor[ p + 1 ] = pickingColor[ v3 + 1 ];
                aPickingColor[ p + 2 ] = pickingColor[ v3 + 2 ];

            }

        }

        if( size ){

            currSize = size[ v ];

            if( prevSize !== size[ v ] ){

                aSize[ l     ] = prevSize;
                aSize[ l + 1 ] = prevSize;
                aSize[ l + 2 ] = currSize;
                aSize[ l + 3 ] = currSize;

            }else{

                aSize[ l     ] = currSize;
                aSize[ l + 1 ] = currSize;
                aSize[ l + 2 ] = currSize;
                aSize[ l + 3 ] = currSize;

            }

            prevSize = currSize;

        }

        if( dir ){

            aDir[ k     ] = dir[ v3     ];
            aDir[ k + 1 ] = dir[ v3 + 1 ];
            aDir[ k + 2 ] = dir[ v3 + 2 ];

            aDir[ k + 3 ] = -dir[ v3     ];
            aDir[ k + 4 ] = -dir[ v3 + 1 ];
            aDir[ k + 5 ] = -dir[ v3 + 2 ];

            aDir[ k + 6 ] = dir[ v3 + 3 ];
            aDir[ k + 7 ] = dir[ v3 + 4 ];
            aDir[ k + 8 ] = dir[ v3 + 5 ];

            aDir[ k +  9 ] = -dir[ v3 + 3 ];
            aDir[ k + 10 ] = -dir[ v3 + 4 ];
            aDir[ k + 11 ] = -dir[ v3 + 5 ];

        }

    }

};

NGL.RibbonBuffer.prototype.makeIndex = function(){

    var meshIndex = this.meshIndex;
    var n = meshIndex.length / 4 / 3;

    var quadIndices = new Uint32Array([
        0, 1, 2,
        1, 3, 2
    ]);

    var s, v, ix, it;

    for( v = 0; v < n; ++v ){

        ix = v * 6;
        it = v * 4;

        meshIndex.set( quadIndices, ix );
        for( s = 0; s < 6; ++s ){
            meshIndex[ ix + s ] += it;
        }

    }

};


////////////////////
// Mesh Primitives

NGL.TubeMeshBuffer = function( position, normal, binormal, tangent, color, size, pickingColor, params ){

    var p = params || {};

    this.rx = p.rx !== undefined ? p.rx : 1.5;
    this.ry = p.ry !== undefined ? p.ry : 0.5;
    this.radialSegments = p.radialSegments !== undefined ? p.radialSegments : 4;
    this.capped = p.capped !== undefined ? p.capped : false;

    this.capVertices = this.capped ? this.radialSegments : 0;
    this.capTriangles = this.capped ? this.radialSegments - 2 : 0;

    var n = position.length / 3;
    var n1 = n - 1;
    var radialSegments1 = this.radialSegments + 1;

    var x = n * this.radialSegments * 3 + 2 * this.capVertices * 3;

    this.size2 = n;

    this.meshPosition = new Float32Array( x );
    this.meshColor = new Float32Array( x );
    this.meshNormal = new Float32Array( x );
    this.meshPickingColor = pickingColor ? new Float32Array( x ) : undefined;
    this.meshIndex = new Uint32Array(
        n1 * 2 * this.radialSegments * 3 + 2 * this.capTriangles * 3
    );

    this.makeIndex();

    NGL.MeshBuffer.call(
        this, this.meshPosition, this.meshColor, this.meshIndex,
        this.meshNormal, this.meshPickingColor, p
    );

    this.setAttributes( {
        position: position,
        normal: normal,
        binormal: binormal,
        tangent: tangent,
        color: color,
        size: size,
        pickingColor: pickingColor
    } );

}

NGL.TubeMeshBuffer.prototype = Object.create( NGL.MeshBuffer.prototype );

NGL.TubeMeshBuffer.prototype.constructor = NGL.TubeMeshBuffer;

NGL.TubeMeshBuffer.prototype.setAttributes = function(){

    var vTangent = new THREE.Vector3();
    var vMeshNormal = new THREE.Vector3();

    return function( data ){

        var rx = this.rx;
        var ry = this.ry;

        var n = this.size2;
        var n1 = n - 1;
        var capVertices = this.capVertices;
        var radialSegments = this.radialSegments;

        var attributes = this.geometry.attributes;

        var position, normal, binormal, tangent, color, size, pickingColor;
        var meshPosition, meshColor, meshNormal, meshPickingColor

        if( data[ "position" ] ){

            position = data[ "position" ];
            normal = data[ "normal" ];
            binormal = data[ "binormal" ];
            tangent = data[ "tangent" ];
            size = data[ "size" ];

            meshPosition = attributes[ "position" ].array;
            meshNormal = attributes[ "normal" ].array;

            attributes[ "position" ].needsUpdate = true;
            attributes[ "normal" ].needsUpdate = true;

        }

        if( data[ "color" ] ){

            color = data[ "color" ];
            meshColor = attributes[ "color" ].array;
            attributes[ "color" ].needsUpdate = true;

        }

        if( data[ "pickingColor" ] ){

            pickingColor = data[ "pickingColor" ];
            meshPickingColor = attributes[ "pickingColor" ].array;
            attributes[ "pickingColor" ].needsUpdate = true;

        }

        var i, j, k, l, s, t;
        var v, cx, cy;
        var cx1, cy1, cx2, cy2;
        var radius;
        var irs, irs1;

        var normX, normY, normZ;
        var biX, biY, biZ;
        var posX, posY, posZ;

        var cxArr = [];
        var cyArr = [];
        var cx1Arr = [];
        var cy1Arr = [];
        var cx2Arr = [];
        var cy2Arr = [];

        if( position ){

            for( j = 0; j < radialSegments; ++j ){

                v = ( j / radialSegments ) * 2 * Math.PI;

                cxArr[ j ] = rx * Math.cos( v );
                cyArr[ j ] = ry * Math.sin( v );

                cx1Arr[ j ] = rx * Math.cos( v - 0.01 );
                cy1Arr[ j ] = ry * Math.sin( v - 0.01 );
                cx2Arr[ j ] = rx * Math.cos( v + 0.01 );
                cy2Arr[ j ] = ry * Math.sin( v + 0.01 );

            }

        }

        for( i = 0; i < n; ++i ){

            k = i * 3;
            l = k * radialSegments;

            if( position ){

                vTangent.set(
                    tangent[ k ], tangent[ k + 1 ], tangent[ k + 2 ]
                );

                normX = normal[ k     ];
                normY = normal[ k + 1 ];
                normZ = normal[ k + 2 ];

                biX = binormal[ k     ];
                biY = binormal[ k + 1 ];
                biZ = binormal[ k + 2 ];

                posX = position[ k     ];
                posY = position[ k + 1 ];
                posZ = position[ k + 2 ];

                radius = size[ i ];

            }

            for( j = 0; j < radialSegments; ++j ){

                s = l + j * 3

                if( position ){

                    cx = -radius * cxArr[ j ]; // TODO: Hack: Negating it so it faces outside.
                    cy = radius * cyArr[ j ];

                    cx1 = -radius * cx1Arr[ j ];
                    cy1 = radius * cy1Arr[ j ];
                    cx2 = -radius * cx2Arr[ j ];
                    cy2 = radius * cy2Arr[ j ];

                    meshPosition[ s     ] = posX + cx * normX + cy * biX;
                    meshPosition[ s + 1 ] = posY + cx * normY + cy * biY;
                    meshPosition[ s + 2 ] = posZ + cx * normZ + cy * biZ;

                    // TODO half of these are symmetric
                    vMeshNormal.set(
                        // ellipse tangent approximated as vector from/to adjacent points
                        ( cx2 * normX + cy2 * biX ) -
                            ( cx1 * normX + cy1 * biX ),
                        ( cx2 * normY + cy2 * biY ) -
                            ( cx1 * normY + cy1 * biY ),
                        ( cx2 * normZ + cy2 * biZ ) -
                            ( cx1 * normZ + cy1 * biZ )
                    ).cross( vTangent );

                    meshNormal[ s     ] = vMeshNormal.x;
                    meshNormal[ s + 1 ] = vMeshNormal.y;
                    meshNormal[ s + 2 ] = vMeshNormal.z;

                }

                if( color ){

                    meshColor[ s     ] = color[ k     ];
                    meshColor[ s + 1 ] = color[ k + 1 ];
                    meshColor[ s + 2 ] = color[ k + 2 ];

                }

                if( pickingColor ){

                    meshPickingColor[ s     ] = pickingColor[ k     ];
                    meshPickingColor[ s + 1 ] = pickingColor[ k + 1 ];
                    meshPickingColor[ s + 2 ] = pickingColor[ k + 2 ];

                }

            }

        }

        // front cap

        k = 0;
        l = n * 3 * radialSegments;

        for( j = 0; j < radialSegments; ++j ){

            s = k + j * 3;
            t = l + j * 3;

            if( position ){

                meshPosition[ t     ] = meshPosition[ s     ];
                meshPosition[ t + 1 ] = meshPosition[ s + 1 ];
                meshPosition[ t + 2 ] = meshPosition[ s + 2 ];

                meshNormal[ t     ] = tangent[ k     ];
                meshNormal[ t + 1 ] = tangent[ k + 1 ];
                meshNormal[ t + 2 ] = tangent[ k + 2 ];

            }

            if( color ){

                meshColor[ t     ] = meshColor[ s     ];
                meshColor[ t + 1 ] = meshColor[ s + 1 ];
                meshColor[ t + 2 ] = meshColor[ s + 2 ];

            }

            if( pickingColor ){

                meshPickingColor[ t     ] = meshPickingColor[ s     ];
                meshPickingColor[ t + 1 ] = meshPickingColor[ s + 1 ];
                meshPickingColor[ t + 2 ] = meshPickingColor[ s + 2 ];

            }

        }

        // back cap

        k = ( n - 1 ) * 3 * radialSegments;
        l = ( n + 1 ) * 3 * radialSegments;

        for( j = 0; j < radialSegments; ++j ){

            s = k + j * 3;
            t = l + j * 3;

            if( position ){

                meshPosition[ t     ] = meshPosition[ s     ];
                meshPosition[ t + 1 ] = meshPosition[ s + 1 ];
                meshPosition[ t + 2 ] = meshPosition[ s + 2 ];

                meshNormal[ t     ] = tangent[ n1 * 3     ];
                meshNormal[ t + 1 ] = tangent[ n1 * 3 + 1 ];
                meshNormal[ t + 2 ] = tangent[ n1 * 3 + 2 ];

            }

            if( color ){

                meshColor[ t     ] = meshColor[ s     ];
                meshColor[ t + 1 ] = meshColor[ s + 1 ];
                meshColor[ t + 2 ] = meshColor[ s + 2 ];

            }

            if( pickingColor ){

                meshPickingColor[ t     ] = meshPickingColor[ s     ];
                meshPickingColor[ t + 1 ] = meshPickingColor[ s + 1 ];
                meshPickingColor[ t + 2 ] = meshPickingColor[ s + 2 ];

            }

        }

    }

}();

NGL.TubeMeshBuffer.prototype.makeIndex = function(){

    var meshIndex = this.meshIndex;

    var n = this.size2;
    var n1 = n - 1;
    var capTriangles = this.capTriangles;
    var radialSegments = this.radialSegments;
    var radialSegments1 = this.radialSegments + 1;

    var i, k, irs, irs1, l, j;

    for( i = 0; i < n1; ++i ){

        k = i * radialSegments * 3 * 2

        irs = i * radialSegments;
        irs1 = ( i + 1 ) * radialSegments;

        for( j = 0; j < radialSegments; ++j ){

            l = k + j * 3 * 2;

            // meshIndex[ l + 0 ] = irs + ( ( j + 0 ) % radialSegments );
            meshIndex[ l ] = irs + j;
            meshIndex[ l + 1 ] = irs + ( ( j + 1 ) % radialSegments );
            // meshIndex[ l + 2 ] = irs1 + ( ( j + 0 ) % radialSegments );
            meshIndex[ l + 2 ] = irs1 + j;

            // meshIndex[ l + 3 ] = irs1 + ( ( j + 0 ) % radialSegments );
            meshIndex[ l + 3 ] = irs1 + j;
            meshIndex[ l + 4 ] = irs + ( ( j + 1 ) % radialSegments );
            meshIndex[ l + 5 ] = irs1 + ( ( j + 1 ) % radialSegments );

        }

    }

    // capping

    var strip = [ 0 ];

    for( j = 1; j < radialSegments1 / 2; ++j ){

        strip.push( j );
        if( radialSegments - j !== j ){
            strip.push( radialSegments - j );
        }

    }

    // front cap

    l = n1 * radialSegments * 3 * 2;
    k = n * radialSegments;

    for( j = 0; j < strip.length - 2; ++j ){

        if( j % 2 === 0 ){
            meshIndex[ l + j * 3 + 0 ] = k + strip[ j + 0 ];
            meshIndex[ l + j * 3 + 1 ] = k + strip[ j + 1 ];
            meshIndex[ l + j * 3 + 2 ] = k + strip[ j + 2 ];
        }else{
            meshIndex[ l + j * 3 + 0 ] = k + strip[ j + 2 ];
            meshIndex[ l + j * 3 + 1 ] = k + strip[ j + 1 ];
            meshIndex[ l + j * 3 + 2 ] = k + strip[ j + 0 ];
        }

    }

    // back cap

    l = n1 * radialSegments * 3 * 2 + 3 * capTriangles;
    k = n * radialSegments + radialSegments;

    for( j = 0; j < strip.length - 2; ++j ){

        if( j % 2 === 0 ){
            meshIndex[ l + j * 3 + 0 ] = k + strip[ j + 0 ];
            meshIndex[ l + j * 3 + 1 ] = k + strip[ j + 1 ];
            meshIndex[ l + j * 3 + 2 ] = k + strip[ j + 2 ];
        }else{
            meshIndex[ l + j * 3 + 0 ] = k + strip[ j + 2 ];
            meshIndex[ l + j * 3 + 1 ] = k + strip[ j + 1 ];
            meshIndex[ l + j * 3 + 2 ] = k + strip[ j + 0 ];
        }

    }

};


NGL.SurfaceBuffer = function(){

    NGL.MeshBuffer.apply( this, arguments );

}

NGL.SurfaceBuffer.prototype = Object.create( NGL.MeshBuffer.prototype );

NGL.SurfaceBuffer.prototype.constructor = NGL.SurfaceBuffer;


///////////////////
// API Primitives

NGL.SphereBuffer = function( position, color, radius, pickingColor, params, disableImpostor ){

    if( !NGL.extensionFragDepth || disableImpostor ){

        return new NGL.SphereGeometryBuffer(
            position, color, radius, pickingColor, params
        );

    }else{

        return new NGL.SphereImpostorBuffer(
            position, color, radius, pickingColor, params
        );

    }

};


NGL.CylinderBuffer = function( from, to, color, color2, radius, pickingColor, pickingColor2, params, disableImpostor ){

    if( !NGL.extensionFragDepth || disableImpostor ){

        // FIXME cap support missing

        return new NGL.CylinderGeometryBuffer(
            from, to, color, color2, radius,
            pickingColor, pickingColor2, params
        );

    }else{

        return new NGL.CylinderImpostorBuffer(
            from, to, color, color2, radius,
            pickingColor, pickingColor2, params
        );

    }

};


NGL.HyperballStickBuffer = function( from, to, color, color2, radius1, radius2, pickingColor, pickingColor2, params, disableImpostor ){

    if( !NGL.extensionFragDepth || disableImpostor ){

        return new NGL.CylinderGeometryBuffer(
            from, to, color, color2,
            NGL.Utils.calculateMinArray( radius1, radius2 ),
            pickingColor, pickingColor2, params
        );

    }else{

        return new NGL.HyperballStickImpostorBuffer(
            from, to, color, color2,
            radius1, radius2,
            pickingColor, pickingColor2, params
        );

    }

};


////////////////
// Text & Font


NGL.getFont = function( name ){

    var fnt = NGL.Resources[ 'fonts/' + name + '.fnt' ].split('\n');
    var font = {};
    var m, tWidth, tHeight, base, lineHeight;

    fnt.forEach( function( line ){

        if( line.substr( 0, 5 ) === 'char ' ){

            var character = {};
            var ls = line.substr( 5 ).split( /\s+/ );
            ls.forEach( function( field ){
                var fs = field.split( '=' );
                character[ fs[ 0 ] ] = parseInt( fs[ 1 ] );
            });
            var x = character.x;
            var y = character.y;
            var width = character.width;
            var height = character.height;
            character.textureCoords = new Float32Array([
                x/tWidth            ,1 - y/tHeight,                 // top left
                x/tWidth            ,1 - (y+height)/tHeight,        // bottom left
                (x+width)/tWidth    ,1 - y/tHeight,                 // top right
                (x+width)/tWidth    ,1 - (y+height)/tHeight,        // bottom right
            ]);
            character.width2 = (10*width)/tWidth;
            character.height2 = (10*height)/tHeight;
            character.xadvance2 = (10*(character.xadvance))/tWidth;
            character.xoffset2 = (10*(character.xoffset))/tWidth;
            character.yoffset2 = (10*(character.yoffset))/tHeight;
            character.lineHeight = (10*lineHeight)/tHeight;
            font[ character[ 'id' ] ] = character;

        }else if( line.substr( 0, 7 ) === 'common ' ){

            // common lineHeight=38 base=30 scaleW=512 scaleH=512 pages=1 packed=0

            m = line.match( /scaleW=([0-9]+)/ );
            if( m !== null ) tWidth = m[ 1 ];

            m = line.match( /scaleH=([0-9]+)/ );
            if( m !== null ) tHeight = m[ 1 ];

            m = line.match( /base=([0-9]+)/ );
            if( m !== null ) base = m[ 1 ];

            m = line.match( /lineHeight=([0-9]+)/ );
            if( m !== null ) lineHeight = m[ 1 ];

        }else{

            //NGL.log( i, line );

        }

    })

    return font;

};


NGL.TextBuffer = function( position, size, color, text, params ){

    var p = params || {};

    var fontName = p.font !== undefined ? p.font : 'LatoBlack';
    this.font = NGL.getFont( fontName );

    this.tex = new THREE.Texture(
        NGL.Resources[ 'fonts/' + fontName + '.png' ]
    );
    this.tex.needsUpdate = true;

    var n = position.length / 3;

    var charCount = 0;
    for( var i = 0; i < n; ++i ){
        charCount += text[ i ].length;
    }

    this.text = text;
    this.count = charCount;
    this.positionCount = n;

    this.vertexShader = 'SDFFont.vert';
    this.fragmentShader = 'SDFFont.frag';

    NGL.QuadBuffer.call( this, p );

    this.addUniforms( {
        "fontTexture"  : { type: "t", value: this.tex }
    } );

    this.addAttributes( {
        "inputTexCoord": { type: "v2", value: null },
        "inputSize": { type: "f", value: null },
    } );

    this.setAttributes( {
        "position": position,
        "size": size,
        "color": color
    } );

    this.makeMapping();

};

NGL.TextBuffer.prototype = Object.create( NGL.QuadBuffer.prototype );

NGL.TextBuffer.prototype.constructor = NGL.TextBuffer;

NGL.TextBuffer.prototype.makeMaterial = function(){

    NGL.Buffer.prototype.makeMaterial.call( this );

    this.material.lights = false;
    this.material.transparent = true;
    this.material.uniforms.fontTexture.value = this.tex;
    this.material.needsUpdate = true;

};

NGL.TextBuffer.prototype.setAttributes = function( data ){

    var position, size, color;
    var aPosition, inputSize, aColor;

    var text = this.text;
    var attributes = this.geometry.attributes;

    if( data[ "position" ] ){
        position = data[ "position" ];
        aPosition = attributes[ "position" ].array;
        attributes[ "position" ].needsUpdate = true;
    }

    if( data[ "size" ] ){
        size = data[ "size" ];
        inputSize = attributes[ "inputSize" ].array;
        attributes[ "inputSize" ].needsUpdate = true;
    }

    if( data[ "color" ] ){
        color = data[ "color" ];
        aColor = attributes[ "color" ].array;
        attributes[ "color" ].needsUpdate = true;
    }

    var n = this.positionCount;

    var i, j, o;
    var iCharAll = 0;
    var txt, iChar, nChar;

    for( var v = 0; v < n; v++ ) {

        o = 3 * v;
        txt = text[ v ];
        nChar = txt.length;

        for( iChar = 0; iChar < nChar; iChar++, iCharAll++ ) {

            i = iCharAll * 2 * 4;

            for( var m = 0; m < 4; m++ ) {

                j = iCharAll * 4 * 3 + ( 3 * m );

                if( position ){

                    aPosition[ j     ] = position[ o     ];
                    aPosition[ j + 1 ] = position[ o + 1 ];
                    aPosition[ j + 2 ] = position[ o + 2 ];

                }

                if( size ){

                    inputSize[ ( iCharAll * 4 ) + m ] = size[ v ];

                }

                if( color ){

                    aColor[ j     ] = color[ o     ];
                    aColor[ j + 1 ] = color[ o + 1 ];
                    aColor[ j + 2 ] = color[ o + 2 ];

                }

            }

        }

    }

};

NGL.TextBuffer.prototype.setProperties = function( data ){

    // alpha channel must stay enabled for anti-aliasing
    if( data && data.transparent !== undefined ) data.transparent = true;

    NGL.QuadBuffer.prototype.setProperties.call( this, data );

};

NGL.TextBuffer.prototype.makeMapping = function(){

    var font = this.font;
    var text = this.text;

    var inputTexCoord = this.geometry.attributes[ "inputTexCoord" ].array;
    var inputMapping = this.geometry.attributes[ "mapping" ].array;

    var n = this.positionCount;

    var c;
    var i, j, o;
    var iCharAll = 0;
    var txt, xadvance, iChar, nChar;

    for( var v = 0; v < n; v++ ) {

        o = 3 * v;
        txt = text[ v ];
        xadvance = 0;
        nChar = txt.length;

        for( iChar = 0; iChar < nChar; iChar++, iCharAll++ ) {

            c = font[ txt.charCodeAt( iChar ) ];
            i = iCharAll * 2 * 4;

            // top left
            inputMapping[ i + 0 ] = xadvance + c.xoffset2;
            inputMapping[ i + 1 ] = c.lineHeight - c.yoffset2;
            // bottom left
            inputMapping[ i + 2 ] = xadvance + c.xoffset2;
            inputMapping[ i + 3 ] = c.lineHeight - c.yoffset2 - c.height2;
            // top right
            inputMapping[ i + 4 ] = xadvance + c.xoffset2 + c.width2;
            inputMapping[ i + 5 ] = c.lineHeight - c.yoffset2;
            // bottom right
            inputMapping[ i + 6 ] = xadvance + c.xoffset2 + c.width2;
            inputMapping[ i + 7 ] = c.lineHeight - c.yoffset2 - c.height2;

            inputTexCoord.set( c.textureCoords, i );

            xadvance += c.xadvance2;

        }

    }

};

NGL.TextBuffer.prototype.dispose = function(){

    NGL.Buffer.prototype.dispose.call( this );

    this.tex.dispose();

};


///////////
// Helper

NGL.VectorBuffer = function( position, vector, params ){

    var p = params || {};

    this.size = position.length / 3;
    this.vertexShader = 'Line.vert';
    this.fragmentShader = 'Line.frag';
    this.line = true;

    var n = this.size;
    var n2 = n * 2;

    this.attributeSize = n2;

    this.scale = p.scale || 1;
    var color = new THREE.Color( p.color || "grey" );

    this.linePosition = new Float32Array( n2 * 3 );
    this.lineColor = NGL.Utils.uniformArray3( n2, color.r, color.g, color.b );

    NGL.Buffer.call(
        this, this.linePosition, this.lineColor, undefined, undefined, p
    );

    this.setAttributes( {
        position: position,
        vector: vector
    } );

};

NGL.VectorBuffer.prototype = Object.create( NGL.Buffer.prototype );

NGL.VectorBuffer.prototype.constructor = NGL.VectorBuffer;

NGL.VectorBuffer.prototype.setAttributes = function( data ){

    var attributes = this.geometry.attributes;

    var position, vector;
    var aPosition;

    if( data[ "position" ] && data[ "vector" ] ){
        position = data[ "position" ];
        vector = data[ "vector" ];
        aPosition = attributes[ "position" ].array;
        attributes[ "position" ].needsUpdate = true;
    }

    var n = this.size;
    var scale = this.scale;

    var i, j;

    if( data[ "position" ] && data[ "vector" ] ){

        for( var v = 0; v < n; v++ ){

            i = v * 2 * 3;
            j = v * 3;

            aPosition[ i + 0 ] = position[ j + 0 ];
            aPosition[ i + 1 ] = position[ j + 1 ];
            aPosition[ i + 2 ] = position[ j + 2 ];
            aPosition[ i + 3 ] = position[ j + 0 ] + vector[ j + 0 ] * scale;
            aPosition[ i + 4 ] = position[ j + 1 ] + vector[ j + 1 ] * scale;
            aPosition[ i + 5 ] = position[ j + 2 ] + vector[ j + 2 ] * scale;

        }

    }

};

// File:js/ngl/representation.js

/**
 * @file Representation
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


NGL.SideTypes = {};
NGL.SideTypes[ THREE.FrontSide ] = "front";
NGL.SideTypes[ THREE.BackSide ] = "back";
NGL.SideTypes[ THREE.DoubleSide ] = "double";


NGL.makeRepresentation = function( type, object, viewer, params ){

    NGL.time( "NGL.makeRepresentation " + type );

    var ReprClass;

    if( type === "buffer" ){

        ReprClass = NGL.BufferRepresentation;

    }else if( object instanceof NGL.Structure ){

        ReprClass = NGL.representationTypes[ type ];

        if( !ReprClass ){

            NGL.error(
                "NGL.makeRepresentation: representation type " + type + " unknown"
            );
            return;

        }

    }else if( object instanceof NGL.Surface || object instanceof NGL.Volume ){

        if( type === "surface" ){

            ReprClass = NGL.SurfaceRepresentation;

        }else if( type === "dot" ){

            ReprClass = NGL.DotRepresentation;

        }else{

            NGL.error(
                "NGL.makeRepresentation: representation type " + type + " unknown"
            );
            return;

        }

    }else if( object instanceof NGL.Trajectory ){

        ReprClass = NGL.TrajectoryRepresentation;

    }else{

        NGL.error(
            "NGL.makeRepresentation: object " + object + " unknown"
        );
        return;

    }

    var repr = new ReprClass( object, viewer, params );

    NGL.timeEnd( "NGL.makeRepresentation " + type );

    return repr;

};


///////////////////
// Representation

NGL.Representation = function( object, viewer, params ){

    this.viewer = viewer;

    this.queue = async.queue( this.make.bind( this ), 1 );
    this.tasks = new NGL.Counter();
    this.bufferList = [];

    this.init( params );

};

NGL.Representation.prototype = {

    constructor: NGL.Representation,

    type: "",

    parameters: {

        nearClip: {
            type: "boolean", buffer: true
        },
        flatShaded: {
            type: "boolean", buffer: true
        },
        opacity: {
            type: "number", precision: 1, max: 1, min: 0, buffer: true
        },
        side: {
            type: "select", options: NGL.SideTypes, buffer: true,
            int: true
        },
        wireframe: {
            type: "boolean", buffer: true
        },
        linewidth: {
            type: "integer", max: 50, min: 1, buffer: true
        },

        colorScheme: {
            type: "select", update: "color",
            options: NGL.ColorMakerRegistry.getTypes()
        },
        colorScale: {
            type: "select", update: "color",
            options: NGL.ColorMakerRegistry.getScales()
        },
        colorValue: {
            type: "color", update: "color"
        },
        colorDomain: {
            type: "hidden", update: "color"
        },
        colorMode: {
            type: "select", update: "color",
            options: NGL.ColorMakerRegistry.getModes()
        },

    },

    init: function( params ){

        var p = params || {};

        this.nearClip = p.nearClip !== undefined ? p.nearClip : true;
        this.flatShaded = p.flatShaded || false;
        this.side = p.side !== undefined ? p.side : THREE.DoubleSide;
        this.opacity = p.opacity !== undefined ? p.opacity : 1.0;
        this.wireframe = p.wireframe || false;
        this.linewidth = p.linewidth || 1;

        this.setColor( p.color, p );

        this.colorScheme = p.colorScheme || "uniform";
        this.colorScale = p.colorScale || "";
        this.colorValue = p.colorValue || 0x909090;
        this.colorDomain = p.colorDomain || "";
        this.colorMode = p.colorMode || "hcl";

        this.visible = p.visible !== undefined ? p.visible : true;
        this.quality = p.quality;

    },

    getColorParams: function(){

        return {

            scheme: this.colorScheme,
            scale: this.colorScale,
            value: this.colorValue,
            domain: this.colorDomain,
            mode: this.colorMode,

        };

    },

    getBufferParams: function( p ){

        return Object.assign( {

            nearClip: this.nearClip,
            flatShaded: this.flatShaded,
            opacity: this.opacity,
            side: this.side,
            wireframe: this.wireframe,
            linewidth: this.linewidth,

        }, p );

    },

    setColor: function( value, p ){

        var types = Object.keys( NGL.ColorMakerRegistry.getTypes() );

        if( types.indexOf( value ) !== -1 ){

            if( p ){
                p.colorScheme = value;
            }else{
                this.setParameters( { colorScheme: value } );
            }

        }else if( value !== undefined ){

            value = new THREE.Color( value ).getHex();
            if( p ){
                p.colorScheme = "uniform";
                p.colorValue = value;
            }else{
                this.setParameters( {
                    colorScheme: "uniform", colorValue: value
                } );
            }

        }

        return this;

    },

    prepare: function( callback ){

        callback();

    },

    create: function(){

        // this.bufferList.length = 0;

    },

    update: function(){

        this.build();

    },

    build: function( params ){

        // don't let tasks accumulate
        if( this.queue.length() > 0 ){

            this.tasks.change( 1 - this.queue.length() );
            this.queue.kill();

        }else{

            this.tasks.increment();

        }

        if( !params ){
            params = this.getParameters();
            delete params.quality;
        }

        this.queue.push( params );

    },

    make: function( params, callback ){

        NGL.time( "NGL.Representation.make " + this.type );

        if( params && !params.__update ){
            this.init( params );
        }

        this.prepare( function(){

            if( params.__update ){

                this.update( params.__update );
                this.viewer.requestRender();

                this.tasks.decrement();
                callback();

            }else{

                this.clear();
                this.create();

                if( !this.manualAttach && !this.disposed ){

                    NGL.time( "NGL.Representation.attach " + this.type );

                    this.attach( function(){

                        NGL.timeEnd( "NGL.Representation.attach " + this.type );

                        this.tasks.decrement();
                        callback();

                    }.bind( this ) );

                }

            }

            NGL.timeEnd( "NGL.Representation.make " + this.type );

        }.bind( this ) );

    },

    attach: function( callback ){

        this.setVisibility( this.visible );

        callback();

    },

    setVisibility: function( value, noRenderRequest ){

        this.visible = value;

        this.bufferList.forEach( function( buffer ){

            buffer.setVisibility( value );

        } );

        if( !noRenderRequest ) this.viewer.requestRender();

        return this;

    },

    setParameters: function( params, what, rebuild ){

        var p = params || {};
        var tp = this.parameters;

        what = what || {};
        rebuild = rebuild || false;

        var bufferParams = {};

        for( var name in p ){

            if( p[ name ] === undefined ) continue;
            if( tp[ name ] === undefined ) continue;

            if( tp[ name ].int ) p[ name ] = parseInt( p[ name ] );
            if( tp[ name ].float ) p[ name ] = parseFloat( p[ name ] );

            // no value change
            if( p[ name ] === this[ name ] ) continue;

            this[ name ] = p[ name ];

            // buffer param
            if( tp[ name ].buffer ){
                if( tp[ name ].buffer === true ){
                    bufferParams[ name ] = p[ name ];
                }else{
                    bufferParams[ tp[ name ].buffer ] = p[ name ];
                }
            }

            // mark for update
            if( tp[ name ].update ){
                what[ tp[ name ].update ] = true;
            }

            // mark for rebuild
            if( tp[ name ].rebuild &&
                !( tp[ name ].rebuild === "impostor" &&
                    NGL.extensionFragDepth && !this.disableImpostor )
            ){
                rebuild = true;
            }

        }

        //

        if( rebuild ){

            this.build();

        }else{

            this.bufferList.forEach( function( buffer ){
                buffer.setParameters( bufferParams );
            } );

            if( Object.keys( what ).length ){
                this.update( what );  // update buffer attribute
            }

            this.viewer.requestRender();

        }

        return this;

    },

    getParameters: function(){

        // FIXME move specific parts to subclasses
        var params = {

            visible: this.visible,
            sele: this.selection ? this.selection.string : undefined,
            disableImpostor: this.disableImpostor,
            quality: this.quality

        };

        Object.keys( this.parameters ).forEach( function( name ){

            params[ name ] = this[ name ];

        }, this );

        // if( typeof this.radius === "string" ){

        //     params[ "radiusType" ] = this.radius;
        //     delete params[ "radius" ];

        // }

        return params;

    },

    clear: function(){

        this.bufferList.forEach( function( buffer ){

            this.viewer.remove( buffer );
            buffer.dispose();

        }, this );

        this.bufferList.length = 0;

        this.viewer.requestRender();

    },

    dispose: function(){

        this.disposed = true;
        this.queue.kill();
        this.tasks.dispose();
        this.clear();

    }

};


NGL.BufferRepresentation = function( buffer, viewer, params ){

    NGL.Representation.call( this, buffer, viewer, params );

    this.buffer = buffer;

    this.build();

};

NGL.BufferRepresentation.prototype = NGL.createObject(

    NGL.Representation.prototype, {

    constructor: NGL.BufferRepresentation,

    type: "buffer",

    parameters: Object.assign( {

    }, NGL.Representation.prototype.parameters, {

        colorScheme: null,
        colorScale: null,
        colorValue: null,
        colorDomain: null,
        colorMode: null

    } ),

    create: function(){

        this.bufferList.push( this.buffer );

    },

    attach: function( callback ){

        this.bufferList.forEach( function( buffer ){

            this.viewer.add( buffer );

        }, this );

        this.setVisibility( this.visible );

        callback();

    }

} );


/////////////////////////////
// Structure representation

NGL.StructureRepresentation = function( structure, viewer, params ){

    this.fiberList = [];

    this.selection = new NGL.Selection(
        params.sele, this.getAssemblySele( params.assembly, structure )
    );
    this.atomSet = new NGL.AtomSet();

    this.setStructure( structure );

    NGL.Representation.call( this, structure, viewer, params );

    if( structure.biomolDict ){
        var biomolOptions = { "__AU": "AU" };
        Object.keys( structure.biomolDict ).forEach( function( k ){
            biomolOptions[ k ] = k;
        } );
        biomolOptions[ "" ] = "";
        this.parameters.assembly = {
            type: "select",
            options: biomolOptions,
            rebuild: true
        };
    }else{
        this.parameters.assembly = null;
    }

    // must come after atomSet to ensure selection change signals
    // have already updated the atomSet
    this.selection.signals.stringChanged.add( function(){
        this.build();
    }.bind( this ) );

    this.build();

};

NGL.StructureRepresentation.prototype = NGL.createObject(

    NGL.Representation.prototype, {

    constructor: NGL.StructureRepresentation,

    type: "structure",

    parameters: Object.assign( {

        radiusType: {
            type: "select", options: NGL.RadiusFactory.types
        },
        radius: {
            type: "number", precision: 3, max: 10.0, min: 0.001
        },
        scale: {
            type: "number", precision: 3, max: 10.0, min: 0.001
        },
        assembly: null

    }, NGL.Representation.prototype.parameters ),

    defaultScale: {
        "vdw": 1.0,
        "covalent": 1.0,
        "bfactor": 0.01,
        "sstruc": 1.0
    },

    defaultSize: 1.0,

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "element";

        this.radius = p.radius || "vdw";
        this.scale = p.scale || 1.0;
        this.assembly = p.assembly || "";

        // TODO find a nicer way ...
        var combinedString = this.selection.combinedString;
        this.setSelection( p.sele, this.getAssemblySele( p.assembly ), true );
        if( combinedString !== this.selection.combinedString ){
            this.atomSet.applySelection();
        }

        NGL.Representation.prototype.init.call( this, p );

    },

    setStructure: function( structure ){

        this.structure = structure || this.structure;
        this.atomSet.fromStructure( this.structure, this.selection );

        return this;

    },

    getAssemblySele: function( assemblyName, structure ){

        structure = structure || this.structure;
        assemblyName = assemblyName || structure.defaultAssembly;

        var assembly = structure.biomolDict[ assemblyName ];
        var extraString = "";
        if( assembly && assembly.chainList &&
            assembly.chainList.length < structure.chainCount
        ){
            extraString = ":" + assembly.chainList.join( " OR :" );
        }

        // console.log( "getAssemblySele", extraString );

        return extraString;

    },

    getColorParams: function(){

        var p = NGL.Representation.prototype.getColorParams.call( this );

        p.structure = this.structure;
        p.atomSet = this.atomSet;

        return p;

    },

    setSelection: function( string, extraString, silent ){

        this.selection.setString( string, extraString, silent );

        return this;

    },

    setParameters: function( params, what, rebuild ){

        what = what || {};

        if( params && params[ "radiusType" ] !== undefined ){

            if( params[ "radiusType" ] === "size" ){
                this.radius = this.defaultSize;
            }else{
                this.radius = params[ "radiusType" ];
            }
            what[ "radius" ] = true;
            if( !NGL.extensionFragDepth || this.disableImpostor ){
                rebuild = true;
            }

        }

        if( params && params[ "radius" ] !== undefined ){

            what[ "radius" ] = true;
            if( !NGL.extensionFragDepth || this.disableImpostor ){
                rebuild = true;
            }

        }

        if( params && params[ "scale" ] !== undefined ){

            what[ "scale" ] = true;
            if( !NGL.extensionFragDepth || this.disableImpostor ){
                rebuild = true;
            }

        }

        if( params && params[ "assembly" ] !== undefined ){

            this.setSelection( undefined, this.getAssemblySele( params[ "assembly" ] ) );

        }

        NGL.Representation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    },

    attach: function( callback ){

        var viewer = this.viewer;
        var structure = this.structure;
        var assembly = this.assembly;

        if( assembly === "" ){
            assembly = structure.defaultAssembly;
        }

        // NGL.log( structure.biomolDict );

        var instanceList = [];

        if( structure.biomolDict && structure.biomolDict[ assembly ] ){

            var matrixDict = structure.biomolDict[ assembly ].matrixDict;

            Object.keys( matrixDict ).forEach( function( name, i ){

                instanceList.push( {

                    id: i + 1,
                    name: name,
                    assembly: assembly,
                    matrix: matrixDict[ name ]

                } );

            } );

        }

        this.bufferList.forEach( function( buffer, i, list ){

            // async to appease Chrome

            requestAnimationFrame( function(){

                if( instanceList.length >= 1 ){
                    viewer.add( buffer, instanceList );
                }else{
                    viewer.add( buffer );
                }

                if( i === list.length - 1 ){
                    callback();
                }

            } );

        } );

        this.setVisibility( this.visible );

        if( this.bufferList.length === 0 ) callback();

    },

    clear: function(){

        this.fiberList.length = 0;

        NGL.Representation.prototype.clear.call( this );

    },

    dispose: function(){

        this.atomSet.dispose();

        delete this.structure;

        NGL.Representation.prototype.dispose.call( this );

    }

} );


NGL.SpacefillRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.SpacefillRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.SpacefillRepresentation,

    type: "spacefill",

    parameters: Object.assign( {

        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
        }

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        this.sphereBuffer = new NGL.SphereBuffer(
            this.atomSet.atomPosition(),
            this.atomSet.atomColor( null, this.getColorParams() ),
            this.atomSet.atomRadius( null, this.radius, this.scale ),
            this.atomSet.atomPickingColor(),
            this.getBufferParams( {
                sphereDetail: this.sphereDetail,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.sphereBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var sphereData = {};

        if( what[ "position" ] ){

            sphereData[ "position" ] = this.atomSet.atomPosition();

        }

        if( what[ "color" ] ){

            sphereData[ "color" ] = this.atomSet.atomColor(
                null, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            sphereData[ "radius" ] = this.atomSet.atomRadius(
                null, this.radius, this.scale
            );

        }

        this.sphereBuffer.setAttributes( sphereData );

    }

} );


NGL.PointRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.PointRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.PointRepresentation,

    type: "point",

    parameters: Object.assign( {

        pointSize: {
            type: "integer", max: 20, min: 1, buffer: true
        },
        sizeAttenuation: {
            type: "boolean", buffer: true
        },
        sort: {
            type: "boolean", rebuild: true
        }

        // FIXME nearClip support missing
    }, NGL.Representation.prototype.parameters, {

        nearClip: null,
        flatShaded: null,
        wireframe: null,
        linewidth: null

    } ),

    init: function( params ){

        var p = params || {};

        this.pointSize = p.pointSize || 1;
        this.sizeAttenuation = p.sizeAttenuation !== undefined ? p.sizeAttenuation : true;
        this.sort = p.sort !== undefined ? p.sort : false;
        p.opacity = p.opacity !== undefined ? p.opacity : 0.6;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        this.pointBuffer = new NGL.PointBuffer(
            this.atomSet.atomPosition(),
            this.atomSet.atomColor( null, this.getColorParams() ),
            this.getBufferParams( {
                pointSize: this.pointSize,
                sizeAttenuation: this.sizeAttenuation,
                sort: this.sort,
            } )
        );

        this.bufferList.push( this.pointBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var pointData = {};

        if( what[ "position" ] ){

            pointData[ "position" ] = this.atomSet.atomPosition();

        }

        if( what[ "color" ] ){

            pointData[ "color" ] = this.atomSet.atomColor(
                null, this.colorScheme, this.getColorParams()
            );

        }

        this.pointBuffer.setAttributes( pointData );

    }

} );


NGL.LabelRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.LabelRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.LabelRepresentation,

    type: "label",

    parameters: Object.assign( {

        labelType: {
            type: "select", options: NGL.LabelFactory.types, rebuild: true
        },
        font: {
            type: "select", options: {
                // "Arial": "Arial",
                // "DejaVu": "DejaVu",
                "LatoBlack": "LatoBlack"
            },
            rebuild: true
        }

    }, NGL.StructureRepresentation.prototype.parameters, {

        side: null, flatShaded: null

    } ),

    init: function( params ){

        var p = params || {};

        this.labelType = p.labelType || "res";
        this.labelText = p.labelText || {};
        this.font = p.font || 'LatoBlack';

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var text = [];
        var labelFactory = new NGL.LabelFactory(
            this.labelType, this.labelText
        );

        this.atomSet.eachAtom( function( a ){

            text.push( labelFactory.atomLabel( a ) );

        } );

        this.textBuffer = new NGL.TextBuffer(
            this.atomSet.atomPosition(),
            this.atomSet.atomRadius( null, this.radius, this.scale ),
            this.atomSet.atomColor( null, this.getColorParams() ),
            text,
            this.getBufferParams( {
                font: this.font,
            } )
        );

        this.bufferList.push( this.textBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var textData = {};

        if( what[ "position" ] ){

            textData[ "position" ] = this.atomSet.atomPosition();

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            textData[ "size" ] = this.atomSet.atomRadius(
                null, this.radius, this.scale
            );

        }

        if( what[ "color" ] ){

            textData[ "color" ] = this.atomSet.atomColor(
                null, this.getColorParams()
            );

        }

        this.textBuffer.setAttributes( textData );

    }

} );


NGL.BallAndStickRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.BallAndStickRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.BallAndStickRepresentation,

    type: "ball+stick",

    defaultSize: 0.15,

    parameters: Object.assign( {

        aspectRatio: {
            type: "number", precision: 1, max: 10.0, min: 1.0
        },
        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        },
        radiusSegments: {
            type: "integer", max: 25, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.radius = p.radius || this.defaultSize;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
            this.radiusSegments = 20;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.aspectRatio = p.aspectRatio || 2.0;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var atomScale = this.scale * this.aspectRatio;

        this.sphereBuffer = new NGL.SphereBuffer(
            this.atomSet.atomPosition(),
            this.atomSet.atomColor( null, this.getColorParams() ),
            this.atomSet.atomRadius( null, this.radius, atomScale ),
            this.atomSet.atomPickingColor( null ),
            this.getBufferParams( {
                sphereDetail: this.sphereDetail,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.__center = new Float32Array( this.atomSet.bondCount * 3 );

        this.cylinderBuffer = new NGL.CylinderBuffer(
            this.atomSet.bondPosition( null, 0 ),
            this.atomSet.bondPosition( null, 1 ),
            this.atomSet.bondColor( null, 0, this.getColorParams() ),
            this.atomSet.bondColor( null, 1, this.getColorParams() ),
            this.atomSet.bondRadius( null, null, this.radius, this.scale ),
            this.atomSet.bondPickingColor( null, 0 ),
            this.atomSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.sphereBuffer, this.cylinderBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var sphereData = {};
        var cylinderData = {};

        if( what[ "position" ] ){

            sphereData[ "position" ] = this.atomSet.atomPosition();

            var from = this.atomSet.bondPosition( null, 0 );
            var to = this.atomSet.bondPosition( null, 1 );

            cylinderData[ "position" ] = NGL.Utils.calculateCenterArray(
                from, to, this.__center
            );
            cylinderData[ "position1" ] = from;
            cylinderData[ "position2" ] = to;

        }

        if( what[ "color" ] ){

            sphereData[ "color" ] = this.atomSet.atomColor(
                null, this.getColorParams()
            );

            cylinderData[ "color" ] = this.atomSet.bondColor(
                null, 0, this.getColorParams()
            );
            cylinderData[ "color2" ] = this.atomSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            sphereData[ "radius" ] = this.atomSet.atomRadius(
                null, this.radius, this.scale * this.aspectRatio
            );

            cylinderData[ "radius" ] = this.atomSet.bondRadius(
                null, null, this.radius, this.scale
            );

        }

        this.sphereBuffer.setAttributes( sphereData );
        this.cylinderBuffer.setAttributes( cylinderData );

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "aspectRatio" ] ){

            what[ "radius" ] = true;
            what[ "scale" ] = true;
            if( !NGL.extensionFragDepth || this.disableImpostor ){
                rebuild = true;
            }

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


NGL.LicoriceRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.LicoriceRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.LicoriceRepresentation,

    type: "licorice",

    defaultSize: 0.15,

    parameters: Object.assign( {

        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        },
        radiusSegments: {
            type: "integer", max: 25, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.radius = p.radius || this.defaultSize;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
            this.radiusSegments = 20;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        this.sphereBuffer = new NGL.SphereBuffer(
            this.atomSet.atomPosition(),
            this.atomSet.atomColor( null, this.getColorParams() ),
            this.atomSet.atomRadius( null, this.radius, this.scale ),
            this.atomSet.atomPickingColor(),
            this.getBufferParams( {
                sphereDetail: this.sphereDetail,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.cylinderBuffer = new NGL.CylinderBuffer(
            this.atomSet.bondPosition( null, 0 ),
            this.atomSet.bondPosition( null, 1 ),
            this.atomSet.bondColor( null, 0, this.getColorParams() ),
            this.atomSet.bondColor( null, 1, this.getColorParams() ),
            this.atomSet.bondRadius( null, null, this.radius, this.scale ),
            this.atomSet.bondPickingColor( null, 0 ),
            this.atomSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.sphereBuffer, this.cylinderBuffer );

    },

    update: function( what ){

        this.aspectRatio = 1.0;

        NGL.BallAndStickRepresentation.prototype.update.call( this, what );

    }

} );


NGL.LineRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.LineRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.LineRepresentation,

    type: "line",

    parameters: Object.assign( {


    }, NGL.Representation.prototype.parameters, {

        flatShaded: null,
        side: null,
        wireframe: null

    } ),

    init: function( params ){

        var p = params || {};

        this.linewidth = p.linewidth || 1;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        this.lineBuffer = new NGL.LineBuffer(
            this.atomSet.bondPosition( null, 0 ),
            this.atomSet.bondPosition( null, 1 ),
            this.atomSet.bondColor( null, 0, this.getColorParams() ),
            this.atomSet.bondColor( null, 1, this.getColorParams() ),
            this.getBufferParams()
        );

        this.bufferList.push( this.lineBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var lineData = {};

        if( what[ "position" ] ){

            lineData[ "from" ] = this.atomSet.bondPosition( null, 0 );
            lineData[ "to" ] = this.atomSet.bondPosition( null, 1 );

        }

        if( what[ "color" ] ){

            lineData[ "color" ] = this.atomSet.bondColor(
                null, 0, this.getColorParams()
            );
            lineData[ "color2" ] = this.atomSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        this.lineBuffer.setAttributes( lineData );

    }

} );


NGL.HyperballRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

    this.defaultScale[ "vdw" ] = 0.2;

};

NGL.HyperballRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.HyperballRepresentation,

    type: "hyperball",

    parameters: Object.assign( {

        shrink: {
            type: "number", precision: 3, max: 1.0, min: 0.001, buffer: true
        },
        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        },
        radiusSegments: {
            type: "integer", max: 25, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.scale = p.scale || 0.2;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
            this.radiusSegments = 20;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.shrink = p.shrink || 0.12;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        this.sphereBuffer = new NGL.SphereBuffer(
            this.atomSet.atomPosition(),
            this.atomSet.atomColor( null, this.getColorParams() ),
            this.atomSet.atomRadius( null, this.radius, this.scale ),
            this.atomSet.atomPickingColor(),
            this.getBufferParams( {
                sphereDetail: this.sphereDetail,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.__center = new Float32Array( this.atomSet.bondCount * 3 );

        this.cylinderBuffer = new NGL.HyperballStickBuffer(
            this.atomSet.bondPosition( null, 0 ),
            this.atomSet.bondPosition( null, 1 ),
            this.atomSet.bondColor( null, 0, this.getColorParams() ),
            this.atomSet.bondColor( null, 1, this.getColorParams() ),
            this.atomSet.bondRadius( null, 0, this.radius, this.scale ),
            this.atomSet.bondRadius( null, 1, this.radius, this.scale ),
            this.atomSet.bondPickingColor( null, 0 ),
            this.atomSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shrink: this.shrink,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.sphereBuffer, this.cylinderBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var sphereData = {};
        var cylinderData = {};

        if( what[ "position" ] ){

            sphereData[ "position" ] = this.atomSet.atomPosition();

            var from = this.atomSet.bondPosition( null, 0 );
            var to = this.atomSet.bondPosition( null, 1 );

            cylinderData[ "position" ] = NGL.Utils.calculateCenterArray(
                from, to, this.__center
            );

            cylinderData[ "position1" ] = from;
            cylinderData[ "position2" ] = to;

        }

        if( what[ "color" ] ){

            sphereData[ "color" ] = this.atomSet.atomColor(
                null, this.getColorParams()
            );

            cylinderData[ "color" ] = this.atomSet.bondColor(
                null, 0, this.getColorParams()
            );
            cylinderData[ "color2" ] = this.atomSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            sphereData[ "radius" ] = this.atomSet.atomRadius(
                null, this.radius, this.scale
            );

            cylinderData[ "radius" ] = this.atomSet.bondRadius(
                null, 0, this.radius, this.scale
            );
            cylinderData[ "radius2" ] = this.atomSet.bondRadius(
                null, 1, this.radius, this.scale
            );

        }

        this.sphereBuffer.setAttributes( sphereData );
        this.cylinderBuffer.setAttributes( cylinderData );

    }

} );


NGL.BackboneRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.BackboneRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.BackboneRepresentation,

    type: "backbone",

    defaultSize: 0.25,

    parameters: Object.assign( {

        aspectRatio: {
            type: "number", precision: 1, max: 10.0, min: 1.0
        },
        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        },
        radiusSegments: {
            type: "integer", max: 50, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.radius = p.radius || this.defaultSize;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
            this.radiusSegments = 20;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.aspectRatio = p.aspectRatio || 1.0;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var test = this.selection.test;

        this.backboneAtomSet = new NGL.AtomSet();
        this.backboneBondSet = new NGL.BondSet();

        var baSet = this.backboneAtomSet;
        var bbSet = this.backboneBondSet;

        baSet.structure = this.structure;
        bbSet.structure = this.structure;

        var a1, a2;

        this.structure.eachFiber( function( f ){

            if( f.residueCount < 2 ) return;

            f.eachResidueN( 2, function( r1, r2 ){

                a1 = r1.getTraceAtom();
                a2 = r2.getTraceAtom();

                if( !test || ( test( a1 ) && test( a2 ) ) ){

                    baSet.addAtom( a1 );
                    bbSet.addBond( a1, a2, true );

                }

            } );

            if( !test || ( test( a1 ) && test( a2 ) ) ){

                baSet.addAtom( a2 );

            }

        } );

        if( baSet.atomCount === 0 ) return;

        var sphereScale = this.scale * this.aspectRatio;

        this.sphereBuffer = new NGL.SphereBuffer(
            baSet.atomPosition(),
            baSet.atomColor( null, this.getColorParams() ),
            baSet.atomRadius( null, this.radius, sphereScale ),
            baSet.atomPickingColor(),
            this.getBufferParams( {
                sphereDetail: this.sphereDetail,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.cylinderBuffer = new NGL.CylinderBuffer(
            bbSet.bondPosition( null, 0 ),
            bbSet.bondPosition( null, 1 ),
            bbSet.bondColor( null, 0, this.getColorParams() ),
            bbSet.bondColor( null, 1, this.getColorParams() ),
            bbSet.bondRadius( null, 0, this.radius, this.scale ),
            bbSet.bondPickingColor( null, 0 ),
            bbSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.sphereBuffer, this.cylinderBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var baSet = this.backboneAtomSet;
        var bbSet = this.backboneBondSet;

        if( baSet.atomCount === 0 ) return;

        var sphereData = {};
        var cylinderData = {};

        if( what[ "position" ] ){

            sphereData[ "position" ] = baSet.atomPosition();

            var from = bbSet.bondPosition( null, 0 );
            var to = bbSet.bondPosition( null, 1 );

            cylinderData[ "position" ] = NGL.Utils.calculateCenterArray(
                from, to
            );
            cylinderData[ "position1" ] = from;
            cylinderData[ "position2" ] = to;

        }

        if( what[ "color" ] ){

            sphereData[ "color" ] = baSet.atomColor(
                null, this.getColorParams()
            );

            cylinderData[ "color" ] = bbSet.bondColor(
                null, 0, this.getColorParams()
            );
            cylinderData[ "color2" ] = bbSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            sphereData[ "radius" ] = baSet.atomRadius(
                null, this.radius, this.scale * this.aspectRatio
            );

            cylinderData[ "radius" ] = bbSet.bondRadius(
                null, 0, this.radius, this.scale
            );

        }

        this.sphereBuffer.setAttributes( sphereData );
        this.cylinderBuffer.setAttributes( cylinderData );

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "aspectRatio" ] ){

            what[ "radius" ] = true;
            what[ "scale" ] = true;
            if( !NGL.extensionFragDepth || this.disableImpostor ){
                rebuild = true;
            }

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    },

    clear: function(){

        if( this.backboneAtomSet ) this.backboneAtomSet.dispose();
        if( this.backboneBondSet ) this.backboneBondSet.dispose();

        NGL.StructureRepresentation.prototype.clear.call( this );

    }

} );


NGL.BaseRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.BaseRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.BaseRepresentation,

    type: "base",

    defaultSize: 0.2,

    parameters: Object.assign( {

        aspectRatio: {
            type: "number", precision: 1, max: 10.0, min: 1.0
        },
        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        },
        radiusSegments: {
            type: "integer", max: 50, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.radius = p.radius || this.defaultSize;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
            this.radiusSegments = 20;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.aspectRatio = p.aspectRatio || 1.0;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var test = this.selection.test;

        this.baseAtomSet = new NGL.AtomSet();
        this.baseBondSet = new NGL.BondSet();

        var baSet = this.baseAtomSet;
        var bbSet = this.baseBondSet;

        baSet.structure = this.structure;
        bbSet.structure = this.structure;

        var a1, a2;
        var bases = [ "A", "G", "DA", "DG" ];

        this.structure.eachFiber( function( f ){

            if( f.residueCount < 1 || !f.isNucleic() ) return;

            f.eachResidue( function( r ){

                a1 = r.getTraceAtom();

                if( bases.indexOf( r.resname ) !== -1 ){
                    a2 = r.getAtomByName( "N1" );
                }else{
                    a2 = r.getAtomByName( "N3" );
                }

                if( !test || test( a1 ) ){

                    baSet.addAtom( a1 );
                    baSet.addAtom( a2 );
                    bbSet.addBond( a1, a2, true );

                }

            } );

        } );

        if( baSet.atomCount === 0 ) return;

        var sphereScale = this.scale * this.aspectRatio;

        this.sphereBuffer = new NGL.SphereBuffer(
            baSet.atomPosition(),
            baSet.atomColor( null, this.getColorParams() ),
            baSet.atomRadius( null, this.radius, sphereScale ),
            baSet.atomPickingColor(),
            this.getBufferParams( {
                sphereDetail: this.sphereDetail,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.cylinderBuffer = new NGL.CylinderBuffer(
            bbSet.bondPosition( null, 0 ),
            bbSet.bondPosition( null, 1 ),
            bbSet.bondColor( null, 0, this.getColorParams() ),
            bbSet.bondColor( null, 1, this.getColorParams() ),
            bbSet.bondRadius( null, 0, this.radius, this.scale ),
            bbSet.bondPickingColor( null, 0 ),
            bbSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.sphereBuffer, this.cylinderBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var baSet = this.baseAtomSet;
        var bbSet = this.baseBondSet;

        if( baSet.atomCount === 0 ) return;

        var sphereData = {};
        var cylinderData = {};

        if( what[ "position" ] ){

            sphereData[ "position" ] = baSet.atomPosition();

            var from = bbSet.bondPosition( null, 0 );
            var to = bbSet.bondPosition( null, 1 );

            cylinderData[ "position" ] = NGL.Utils.calculateCenterArray(
                from, to
            );
            cylinderData[ "position1" ] = from;
            cylinderData[ "position2" ] = to;

        }

        if( what[ "color" ] ){

            sphereData[ "color" ] = baSet.atomColor(
                null, this.getColorParams()
            );

            cylinderData[ "color" ] = bbSet.bondColor(
                null, 0, this.getColorParams()
            );
            cylinderData[ "color2" ] = bbSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            sphereData[ "radius" ] = baSet.atomRadius(
                null, this.radius, this.scale * this.aspectRatio
            );

            cylinderData[ "radius" ] = bbSet.bondRadius(
                null, 0, this.radius, this.scale
            );

        }

        this.sphereBuffer.setAttributes( sphereData );
        this.cylinderBuffer.setAttributes( cylinderData );

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "aspectRatio" ] ){

            what[ "radius" ] = true;
            what[ "scale" ] = true;
            if( !NGL.extensionFragDepth || this.disableImpostor ){
                rebuild = true;
            }

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    },

    clear: function(){

        if( this.baseAtomSet ) this.baseAtomSet.dispose();
        if( this.baseBondSet ) this.baseAtomSet.dispose();

        NGL.StructureRepresentation.prototype.clear.call( this );

    }

} );


NGL.TubeRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.TubeRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.TubeRepresentation,

    type: "tube",

    defaultSize: 0.25,

    parameters: Object.assign( {

        subdiv: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        radialSegments: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        tension: {
            type: "number", precision: 1, max: 1.0, min: 0.1
        },
        capped: {
            type: "boolean", rebuild: true
        },

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";
        p.radius = p.radius || this.defaultSize;

        if( p.quality === "low" ){
            this.subdiv = 3;
            this.radialSegments = 5;
        }else if( p.quality === "medium" ){
            this.subdiv = 6;
            this.radialSegments = 10;
        }else if( p.quality === "high" ){
            this.subdiv = 12;
            this.radialSegments = 20;
        }else{
            this.subdiv = p.subdiv || 6;
            this.radialSegments = p.radialSegments || 10;
        }

        this.tension = p.tension || NaN;
        this.capped = p.capped || true;

        NGL.StructureRepresentation.prototype.init.call( this, p );

        this.__fiberList = [];
        this.__bufferList = [];

    },

    prepare: function( callback ){

        this.__fiberList.length = 0;
        this.__bufferList.length = 0;

        if( this.atomSet.atomCount === 0 ){

            callback();
            return;

        }

        var scope = this;

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 ) return;

            scope.__fiberList.push( fiber );

        }, this.selection, true );

        //

        NGL.processArray(

            this.__fiberList,

            function( _i, _n, fiberList ){

                for( var i = _i; i < _n; ++i ){

                    var fiber = fiberList[ i ];

                    var spline = new NGL.Spline( fiber );
                    var subPos = spline.getSubdividedPosition(
                        scope.subdiv, scope.tension
                    );
                    var subOri = spline.getSubdividedOrientation(
                        scope.subdiv, scope.tension
                    );
                    var subCol = spline.getSubdividedColor(
                        scope.subdiv, scope.getColorParams()
                    );
                    var subSize = spline.getSubdividedSize(
                        scope.subdiv, scope.radius, scope.scale
                    );

                    var rx = 1.0;
                    var ry = 1.0;

                    scope.__bufferList.push(

                        new NGL.TubeMeshBuffer(
                            subPos.position,
                            subOri.normal,
                            subOri.binormal,
                            subOri.tangent,
                            subCol.color,
                            subSize.size,
                            subCol.pickingColor,
                            scope.getBufferParams( {
                                radialSegments: scope.radialSegments,
                                rx: rx,
                                ry: ry,
                                capped: scope.capped,
                                dullInterior: true
                            } )
                        )

                    );

                }

            },

            callback,

            50

        );

    },

    create: function(){

        var n = this.__fiberList.length;

        for( var i = 0; i < n; ++i ){

            this.fiberList.push( this.__fiberList[ i ] );
            this.bufferList.push( this.__bufferList[ i ] );

        }

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var i = 0;
        var n = this.fiberList.length;

        // NGL.time( this.name, "update" );

        for( i = 0; i < n; ++i ){

            var fiber = this.fiberList[ i ];

            if( fiber.residueCount < 4 ) return;

            var bufferData = {};
            var spline = new NGL.Spline( fiber );

            if( what[ "position" ] || what[ "radius" ] || what[ "scale" ] ){

                var subPos = spline.getSubdividedPosition(
                    this.subdiv, this.tension
                );
                var subOri = spline.getSubdividedOrientation(
                    this.subdiv, this.tension
                );
                var subSize = spline.getSubdividedSize(
                    this.subdiv, this.radius, this.scale
                );

                bufferData[ "position" ] = subPos.position;
                bufferData[ "normal" ] = subOri.normal;
                bufferData[ "binormal" ] = subOri.binormal;
                bufferData[ "tangent" ] = subOri.tangent;
                bufferData[ "size" ] = subSize.size;

            }

            if( what[ "color" ] ){

                var subCol = spline.getSubdividedColor(
                    this.subdiv, this.getColorParams()
                );

                bufferData[ "color" ] = subCol.color;
                bufferData[ "pickingColor" ] = subCol.pickingColor;

            }

            this.bufferList[ i ].setAttributes( bufferData );

        };

        // NGL.timeEnd( this.name, "update" );

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "tension" ] ){

            what[ "position" ] = true;

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


NGL.CartoonRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.CartoonRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.CartoonRepresentation,

    type: "cartoon",

    parameters: Object.assign( {

        aspectRatio: {
            type: "number", precision: 1, max: 10.0, min: 1.0
        },
        subdiv: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        radialSegments: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        tension: {
            type: "number", precision: 1, max: 1.0, min: 0.1
        },
        capped: {
            type: "boolean", rebuild: true
        },
        arrows: {
            type: "boolean", rebuild: true
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";
        p.radius = p.radius || "sstruc";

        if( p.quality === "low" ){
            this.subdiv = 3;
            this.radialSegments = 6;
        }else if( p.quality === "medium" ){
            this.subdiv = 6;
            this.radialSegments = 10;
        }else if( p.quality === "high" ){
            this.subdiv = 12;
            this.radialSegments = 20;
        }else{
            this.subdiv = p.subdiv || 6;
            this.radialSegments = p.radialSegments || 10;
        }

        this.aspectRatio = p.aspectRatio || 3.0;
        this.tension = p.tension || NaN;
        this.capped = p.capped || true;
        this.arrows = p.arrows || false;

        NGL.StructureRepresentation.prototype.init.call( this, p );

        this.__fiberList = [];
        this.__bufferList = [];

    },

    prepare: function( callback ){

        this.__fiberList.length = 0;
        this.__bufferList.length = 0;

        if( this.atomSet.atomCount === 0 ){

            callback();
            return;

        }

        var scope = this;

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 ) return;

            scope.__fiberList.push( fiber );

        }, this.selection, true );

        //

        NGL.processArray(

            this.__fiberList,

            function( _i, _n, fiberList ){

                for( var i = _i; i < _n; ++i ){

                    var fiber = fiberList[ i ];
                    var spline = new NGL.Spline( fiber, scope.arrows );

                    var subPos = spline.getSubdividedPosition(
                        scope.subdiv, scope.tension
                    );
                    var subOri = spline.getSubdividedOrientation(
                        scope.subdiv, scope.tension
                    );
                    var subCol = spline.getSubdividedColor(
                        scope.subdiv, scope.getColorParams()
                    );
                    var subSize = spline.getSubdividedSize(
                        scope.subdiv, scope.radius, scope.scale
                    );

                    var rx = 1.0 * scope.aspectRatio;
                    var ry = 1.0;

                    if( fiber.isCg() ){
                        ry = rx;
                    }

                    scope.__bufferList.push(

                        new NGL.TubeMeshBuffer(
                            subPos.position,
                            subOri.normal,
                            subOri.binormal,
                            subOri.tangent,
                            subCol.color,
                            subSize.size,
                            subCol.pickingColor,
                            scope.getBufferParams( {
                                radialSegments: scope.radialSegments,
                                rx: rx,
                                ry: ry,
                                capped: scope.capped,
                                dullInterior: true
                            } )
                        )

                    );

                }

            },

            callback,

            50

        );

    },

    create: function(){

        var n = this.__fiberList.length;

        for( var i = 0; i < n; ++i ){

            this.fiberList.push( this.__fiberList[ i ] );
            this.bufferList.push( this.__bufferList[ i ] );

        }

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        // NGL.time( "cartoon repr update" );

        what = what || {};

        var i = 0;
        var n = this.fiberList.length;

        for( i = 0; i < n; ++i ){

            var fiber = this.fiberList[ i ];

            if( fiber.residueCount < 4 ) return;

            var bufferData = {};
            var spline = new NGL.Spline( fiber, this.arrows );

            this.bufferList[ i ].rx = this.aspectRatio;

            if( what[ "position" ] || what[ "radius" ] || what[ "scale" ] ){

                var subPos = spline.getSubdividedPosition( this.subdiv, this.tension );
                var subOri = spline.getSubdividedOrientation( this.subdiv, this.tension );
                var subSize = spline.getSubdividedSize(
                    this.subdiv, this.radius, this.scale
                );

                bufferData[ "position" ] = subPos.position;
                bufferData[ "normal" ] = subOri.normal;
                bufferData[ "binormal" ] = subOri.binormal;
                bufferData[ "tangent" ] = subOri.tangent;
                bufferData[ "size" ] = subSize.size;

            }

            if( what[ "color" ] ){

                var subCol = spline.getSubdividedColor(
                    this.subdiv, this.getColorParams()
                );

                bufferData[ "color" ] = subCol.color;
                bufferData[ "pickingColor" ] = subCol.pickingColor;

            }

            this.bufferList[ i ].setAttributes( bufferData );

        }

        // NGL.timeEnd( "cartoon repr update" );

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "aspectRatio" ] ){

            what[ "radius" ] = true;

        }

        if( params && params[ "tension" ] ){

            what[ "position" ] = true;

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


NGL.RibbonRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

    this.defaultScale[ "sstruc" ] *= 3.0;

};

NGL.RibbonRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.RibbonRepresentation,

    type: "ribbon",

    parameters: Object.assign( {

        subdiv: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        tension: {
            type: "number", precision: 1, max: 1.0, min: 0.1
        }

    }, NGL.StructureRepresentation.prototype.parameters, {

        side: null,
        wireframe: null,
        linewidth: null

    } ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";
        p.radius = p.radius || "sstruc";
        p.scale = p.scale || 3.0;

        if( p.quality === "low" ){
            this.subdiv = 3;
        }else if( p.quality === "medium" ){
            this.subdiv = 6;
        }else if( p.quality === "high" ){
            this.subdiv = 12;
        }else{
            this.subdiv = p.subdiv || 6;
        }

        this.tension = p.tension || NaN;

        NGL.StructureRepresentation.prototype.init.call( this, p );

        this.__fiberList = [];
        this.__bufferList = [];

    },

    prepare: function( callback ){

        this.__fiberList.length = 0;
        this.__bufferList.length = 0;

        if( this.atomSet.atomCount === 0 ){

            callback();
            return;

        }

        var scope = this;

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 ) return;

            scope.__fiberList.push( fiber );

        }, this.selection, true );

        //

        NGL.processArray(

            this.__fiberList,

            function( _i, _n, fiberList ){

                for( var i = _i; i < _n; ++i ){

                    var fiber = fiberList[ i ];

                    var spline = new NGL.Spline( fiber );
                    var subPos = spline.getSubdividedPosition(
                        scope.subdiv, scope.tension
                    );
                    var subOri = spline.getSubdividedOrientation(
                        scope.subdiv, scope.tension
                    );
                    var subCol = spline.getSubdividedColor(
                        scope.subdiv, scope.getColorParams()
                    );
                    var subSize = spline.getSubdividedSize(
                        scope.subdiv, scope.radius, scope.scale
                    );

                    scope.__bufferList.push(

                        new NGL.RibbonBuffer(
                            subPos.position,
                            subOri.binormal,
                            subOri.normal,
                            subCol.color,
                            subSize.size,
                            subCol.pickingColor,
                            scope.getBufferParams()
                        )

                    );

                }

            },

            callback,

            50

        );

    },

    create: function(){

        var n = this.__fiberList.length;

        for( var i = 0; i < n; ++i ){

            this.fiberList.push( this.__fiberList[ i ] );
            this.bufferList.push( this.__bufferList[ i ] );

        }

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var i = 0;
        var n = this.fiberList.length;

        for( i = 0; i < n; ++i ){

            var fiber = this.fiberList[ i ]

            if( fiber.residueCount < 4 ) return;

            var bufferData = {};
            var spline = new NGL.Spline( fiber );

            if( what[ "position" ] ){

                var subPos = spline.getSubdividedPosition(
                    this.subdiv, this.tension
                );
                var subOri = spline.getSubdividedOrientation(
                    this.subdiv, this.tension
                );

                bufferData[ "position" ] = subPos.position;
                bufferData[ "normal" ] = subOri.binormal;
                bufferData[ "dir" ] = subOri.normal;

            }

            if( what[ "radius" ] || what[ "scale" ] ){

                var subSize = spline.getSubdividedSize(
                    this.subdiv, this.radius, this.scale
                );

                bufferData[ "size" ] = subSize.size;

            }

            if( what[ "color" ] ){

                var subCol = spline.getSubdividedColor(
                    this.subdiv, this.getColorParams()
                );

                bufferData[ "color" ] = subCol.color;

            }

            this.bufferList[ i ].setAttributes( bufferData );

        };

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "tension" ] ){

            what[ "position" ] = true;

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


NGL.TraceRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.TraceRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.TraceRepresentation,

    type: "trace",

    parameters: Object.assign( {

        subdiv: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        tension: {
            type: "number", precision: 1, max: 1.0, min: 0.1
        }

    }, NGL.Representation.prototype.parameters, {

        flatShaded: null,
        side: null,
        wireframe: null

    } ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";

        if( p.quality === "low" ){
            this.subdiv = 3;
        }else if( p.quality === "medium" ){
            this.subdiv = 6;
        }else if( p.quality === "high" ){
            this.subdiv = 12;
        }else{
            this.subdiv = p.subdiv || 6;
        }

        this.tension = p.tension || NaN;

        NGL.StructureRepresentation.prototype.init.call( this, p );

        this.__fiberList = [];
        this.__bufferList = [];

    },

    prepare: function( callback ){

        this.__fiberList.length = 0;
        this.__bufferList.length = 0;

        if( this.atomSet.atomCount === 0 ){

            callback();
            return;

        }

        var scope = this;

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 ) return;

            scope.__fiberList.push( fiber );

        }, this.selection, true );

        //

        NGL.processArray(

            this.__fiberList,

            function( _i, _n, fiberList ){

                for( var i = _i; i < _n; ++i ){

                    var fiber = fiberList[ i ];

                    var spline = new NGL.Spline( fiber );
                    var subPos = spline.getSubdividedPosition(
                        scope.subdiv, scope.tension
                    );
                    var subCol = spline.getSubdividedColor(
                        scope.subdiv, scope.getColorParams()
                    );

                    scope.__bufferList.push(

                        new NGL.TraceBuffer(
                            subPos.position,
                            subCol.color,
                            scope.getBufferParams()
                        )

                    );

                }

            },

            callback,

            50

        );

    },

    create: function(){

        var n = this.__fiberList.length;

        for( var i = 0; i < n; ++i ){

            this.fiberList.push( this.__fiberList[ i ] );
            this.bufferList.push( this.__bufferList[ i ] );

        }

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var i = 0;
        var n = this.fiberList.length;

        for( i = 0; i < n; ++i ){

            var fiber = this.fiberList[ i ]

            if( fiber.residueCount < 4 ) return;

            var bufferData = {};
            var spline = new NGL.Spline( fiber );

            if( what[ "position" ] ){

                var subPos = spline.getSubdividedPosition(
                    this.subdiv, this.tension
                );

                bufferData[ "position" ] = subPos.position;

            }

            if( what[ "color" ] ){

                var subCol = spline.getSubdividedColor(
                    this.subdiv, this.getColorParams()
                );

                bufferData[ "color" ] = subCol.color;

            }

            this.bufferList[ i ].setAttributes( bufferData );

        };

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "tension" ] ){

            what[ "position" ] = true;

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


NGL.HelixorientRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.HelixorientRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.HelixorientRepresentation,

    type: "helixorient",

    parameters: Object.assign( {

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        params = params || {};
        params.colorScheme = params.colorScheme || "sstruc";
        params.radius = params.radius || 0.15;
        params.scale = params.scale || 1.0;

        NGL.StructureRepresentation.prototype.init.call( this, params );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var scope = this;

        // TODO reduce buffer count as in e.g. rocket repr

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 || fiber.isNucleic() ) return;

            var helixorient = new NGL.Helixorient( fiber );
            var position = helixorient.getPosition();
            var color = helixorient.getColor( scope.getColorParams() );
            var size = helixorient.getSize( scope.radius, scope.scale );

            scope.bufferList.push(

                new NGL.SphereBuffer(
                    position.center,
                    color.color,
                    size.size,
                    color.pickingColor,
                    scope.getBufferParams( {
                        sphereDetail: scope.sphereDetail,
                        dullInterior: true
                    } ),
                    scope.disableImpostor
                )

            );

            scope.bufferList.push(

                new NGL.VectorBuffer(
                    position.center,
                    position.axis,
                    {
                        color: "skyblue",
                        scale: 1
                    }
                )

            );

            scope.bufferList.push(

                new NGL.VectorBuffer(
                    position.center,
                    position.resdir,
                    {
                        color: "lightgreen",
                        scale: 1
                    }
                )

            );

            scope.fiberList.push( fiber );

        }, this.selection );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        // NGL.time( "helixorient repr update" );

        what = what || {};

        var j;
        var i = 0;
        var n = this.fiberList.length;

        for( i = 0; i < n; ++i ){

            j = i * 3;

            var fiber = this.fiberList[ i ]

            if( fiber.residueCount < 4 ) return;

            var bufferData = {};
            var helixorient = new NGL.Helixorient( fiber );

            if( what[ "position" ] ){

                var position = helixorient.getPosition();

                bufferData[ "position" ] = position.center;

                this.bufferList[ j + 1 ].setAttributes( {
                    "position": position.center,
                    "vector": position.axis,
                } );
                this.bufferList[ j + 2 ].setAttributes( {
                    "position": position.center,
                    "vector": position.resdir,
                } );

            }

            this.bufferList[ j ].setAttributes( bufferData );

        }

        // NGL.timeEnd( "helixorient repr update" );

    }

} );


NGL.RocketRepresentation = function( structure, viewer, params ){

    this.helixbundleList = [];

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.RocketRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.RocketRepresentation,

    type: "rocket",

    parameters: Object.assign( {

        localAngle: {
            type: "integer", max: 180, min: 0, rebuild: true
        },
        centerDist: {
            type: "number", precision: 1, max: 10, min: 0, rebuild: true
        },
        ssBorder: {
            type: "boolean", rebuild: true
        },
        radiusSegments: {
            type: "integer", max: 25, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";
        p.radius = p.radius || 1.5;
        p.scale = p.scale || 1.0;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.radiusSegments = 20;
        }else{
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.localAngle = p.localAngle || 30;
        this.centerDist = p.centerDist || 2.5;
        this.ssBorder = p.ssBorder === undefined ? false : p.ssBorder;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var scope = this;

        var length = 0;
        var axisList = [];

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 || fiber.isNucleic() ) return;

            var helixbundle = new NGL.Helixbundle( fiber );
            var axis = helixbundle.getAxis(
                scope.localAngle, scope.centerDist, scope.ssBorder,
                scope.getColorParams(), scope.radius, scope.scale
            );

            length += axis.size.length;
            axisList.push( axis );
            scope.helixbundleList.push( helixbundle );

        }, this.selection );

        this.axisData = {
            begin: new Float32Array( length * 3 ),
            end: new Float32Array( length * 3 ),
            size: new Float32Array( length ),
            color: new Float32Array( length * 3 ),
            pickingColor: new Float32Array( length * 3 ),
        };

        var ad = this.axisData;
        var offset = 0;

        axisList.forEach( function( axis ){

            ad.begin.set( axis.begin, offset * 3 );
            ad.end.set( axis.end, offset * 3 );
            ad.size.set( axis.size, offset );
            ad.color.set( axis.color, offset * 3 );
            ad.pickingColor.set( axis.pickingColor, offset * 3 );

            offset += axis.size.length;

        } );

        this.cylinderBuffer = new NGL.CylinderBuffer(
            ad.begin,
            ad.end,
            ad.color,
            ad.color,
            ad.size,
            ad.pickingColor,
            ad.pickingColor,
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.cylinderBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var scope = this;

        var cylinderData = {};

        if( what[ "position" ] ){

            this.build();
            return;

        }

        if( what[ "color" ] || what[ "radius" ] || what[ "scale" ] ){

            var offset = 0;
            var ad = this.axisData;

            this.helixbundleList.forEach( function( helixbundle ){

                var axis = helixbundle.getAxis(
                    scope.localAngle, scope.centerDist, scope.ssBorder,
                    scope.getColorParams(), scope.radius, scope.scale
                );

                if( what[ "color" ] ){
                    ad.color.set( axis.color, offset * 3 );
                }

                if( what[ "radius" ] || what[ "scale" ] ){
                    ad.size.set( axis.size, offset );
                }

                offset += axis.size.length;

            } );

            if( what[ "color" ] ){
                cylinderData[ "color" ] = ad.color;
                cylinderData[ "color2" ] = ad.color;
            }

            if( what[ "radius" ] || what[ "scale" ] ){
                cylinderData[ "radius" ] = ad.size;
            }

        }

        this.cylinderBuffer.setAttributes( cylinderData );

    },

    clear: function(){

        this.helixbundleList.length = 0;

        NGL.StructureRepresentation.prototype.clear.call( this );

    }

} );


NGL.RopeRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.RopeRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.RopeRepresentation,

    type: "rope",

    parameters: Object.assign( {

        subdiv: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        radialSegments: {
            type: "integer", max: 50, min: 1, rebuild: true
        },
        tension: {
            type: "number", precision: 1, max: 1.0, min: 0.1
        },
        capped: {
            type: "boolean", rebuild: true
        },
        smooth: {
            type: "integer", max: 15, min: 0, rebuild: true
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";
        p.radius = p.radius || this.defaultSize;

        if( p.quality === "low" ){
            this.subdiv = 3;
            this.radialSegments = 5;
        }else if( p.quality === "medium" ){
            this.subdiv = 6;
            this.radialSegments = 10;
        }else if( p.quality === "high" ){
            this.subdiv = 12;
            this.radialSegments = 20;
        }else{
            this.subdiv = p.subdiv || 6;
            this.radialSegments = p.radialSegments || 10;
        }

        this.tension = p.tension || 0.5;
        this.capped = p.capped || true;
        this.smooth = p.smooth === undefined ? 2 : p.smooth;

        NGL.StructureRepresentation.prototype.init.call( this, p );

        this.__fiberList = [];
        this.__bufferList = [];

    },

    prepare: function( callback ){

        this.__fiberList.length = 0;
        this.__bufferList.length = 0;

        if( this.atomSet.atomCount === 0 ){

            callback();
            return;

        }

        var scope = this;

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 || fiber.isNucleic() ) return;

            scope.__fiberList.push( fiber );

        }, this.selection, true );

        //

        NGL.processArray(

            this.__fiberList,

            function( _i, _n, fiberList ){

                for( var i = _i; i < _n; ++i ){

                    var fiber = fiberList[ i ];

                    var helixorient = new NGL.Helixorient( fiber );

                    var spline = new NGL.Spline(
                        helixorient.getFiber( scope.smooth, true )
                    );
                    var subPos = spline.getSubdividedPosition(
                        scope.subdiv, scope.tension
                    );
                    var subOri = spline.getSubdividedOrientation(
                        scope.subdiv, scope.tension
                    );
                    var subCol = spline.getSubdividedColor(
                        scope.subdiv, scope.getColorParams()
                    );
                    var subSize = spline.getSubdividedSize(
                        scope.subdiv, scope.radius, scope.scale
                    );

                    var rx = 1.0;
                    var ry = 1.0;

                    scope.__bufferList.push(

                        new NGL.TubeMeshBuffer(
                            subPos.position,
                            subOri.normal,
                            subOri.binormal,
                            subOri.tangent,
                            subCol.color,
                            subSize.size,
                            subCol.pickingColor,
                            scope.getBufferParams( {
                                radialSegments: scope.radialSegments,
                                rx: rx,
                                ry: ry,
                                capped: scope.capped,
                                dullInterior: true
                            } )
                        )

                    );

                }

            },

            callback,

            50

        );

    },

    create: function(){

        var n = this.__fiberList.length;

        for( var i = 0; i < n; ++i ){

            this.fiberList.push( this.__fiberList[ i ] );
            this.bufferList.push( this.__bufferList[ i ] );

        }

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        // NGL.time( "rope repr update" );

        what = what || {};

        var i = 0;
        var n = this.fiberList.length;

        for( i = 0; i < n; ++i ){

            var fiber = this.fiberList[ i ]

            if( fiber.residueCount < 4 ) return;

            var bufferData = {};
            var helixorient = new NGL.Helixorient( fiber );
            var spline = new NGL.Spline( helixorient.getFiber( this.smooth, true ) );

            if( what[ "position" ] || what[ "radius" ] || what[ "scale" ] ){

                var subPos = spline.getSubdividedPosition(
                    this.subdiv, this.tension
                );
                var subOri = spline.getSubdividedOrientation(
                    this.subdiv, this.tension
                );
                var subSize = spline.getSubdividedSize(
                    this.subdiv, this.radius, this.scale
                );

                bufferData[ "position" ] = subPos.position;
                bufferData[ "normal" ] = subOri.normal;
                bufferData[ "binormal" ] = subOri.binormal;
                bufferData[ "tangent" ] = subOri.tangent;
                bufferData[ "size" ] = subSize.size;

            }

            if( what[ "color" ] ){

                var subCol = spline.getSubdividedColor(
                    this.subdiv, this.getColorParams()
                );

                bufferData[ "color" ] = subCol.color;
                bufferData[ "pickingColor" ] = subCol.pickingColor;

            }

            this.bufferList[ i ].setAttributes( bufferData );

        }

        // NGL.timeEnd( "rope repr update" );

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "tension" ] ){

            what[ "radius" ] = true;

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


NGL.CrossingRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.CrossingRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.CrossingRepresentation,

    type: "crossing",

    parameters: Object.assign( {

        localAngle: {
            type: "integer", max: 180, min: 0, rebuild: true
        },
        centerDist: {
            type: "number", precision: 1, max: 10, min: 0, rebuild: true
        },
        ssBorder: {
            type: "boolean", rebuild: true
        },
        radiusSegments: {
            type: "integer", max: 25, min: 5, rebuild: "impostor"
        },
        helixDist: {
            type: "number", precision: 1, max: 30, min: 0, rebuild: true
        },
        displayLabel: {
            type: "boolean", rebuild: true
        },
        download: {
            type: "button", methodName: "download"
        },

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "sstruc";
        p.radius = p.radius || 0.7;
        p.scale = p.scale || 1.0;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.radiusSegments = 20;
        }else{
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.localAngle = p.localAngle || 30;
        this.centerDist = p.centerDist || 2.5;
        this.ssBorder = p.ssBorder === undefined ? false : p.ssBorder;
        this.helixDist = p.helixDist || 12;
        this.displayLabel = p.displayLabel === undefined ? true : p.displayLabel;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var scope = this;

        var helixList = [];

        // TODO reduce buffer count as in e.g. rocket repr

        this.structure.eachFiber( function( fiber ){

            if( fiber.residueCount < 4 || fiber.isNucleic() ) return;

            var helixbundle = new NGL.Helixbundle( fiber );
            var axis = helixbundle.getAxis(
                scope.localAngle, scope.centerDist, scope.ssBorder,
                scope.getColorParams(), scope.radius, scope.scale
            );

            scope.bufferList.push(

                new NGL.CylinderBuffer(
                    axis.begin,
                    axis.end,
                    axis.color,
                    axis.color,
                    axis.size,
                    axis.pickingColor,
                    axis.pickingColor,
                    scope.getBufferParams( {
                        shift: 0,
                        cap: true,
                        radiusSegments: scope.radiusSegments,
                        dullInterior: true
                    } ),
                    scope.disableImpostor
                )

            );

            scope.fiberList.push( fiber );

            for( var i = 0; i < axis.residue.length; ++i ){

                var helix = new NGL.Helix();
                helix.fromHelixbundleAxis( axis, i );
                helixList.push( helix );

            }

        }, this.selection );

        //

        var helixCrossing = new NGL.HelixCrossing( helixList );
        var crossing = helixCrossing.getCrossing( this.helixDist );

        this.crossing = crossing;

        var n = crossing.end.length / 3;

        this.bufferList.push(

            new NGL.CylinderBuffer(
                new Float32Array( crossing.begin ),
                new Float32Array( crossing.end ),
                NGL.Utils.uniformArray3( n, 0.2, 0.2, 0.9 ),
                NGL.Utils.uniformArray3( n, 0.2, 0.2, 0.9 ),
                NGL.Utils.uniformArray( n, 0.1 ),
                NGL.Utils.uniformArray3( n, 0, 0, 0 ),
                NGL.Utils.uniformArray3( n, 0, 0, 0 ),
                {
                    shift: 0,
                    cap: true,
                    radiusSegments: this.radiusSegments,
                    side: this.side,
                    opacity: this.opacity,
                    nearClip: this.nearClip,
                    flatShaded: this.flatShaded,
                    dullInterior: true
                },
                this.disableImpostor
            )

        );

        if( this.displayLabel ){

            var m = crossing.helixLabel.length;

            this.bufferList.push(

                new NGL.TextBuffer(
                    crossing.helixCenter,
                    NGL.Utils.uniformArray( m, 2.5 ),
                    NGL.Utils.uniformArray3( m, 1.0, 1.0, 1.0 ),
                    crossing.helixLabel,
                    {
                        nearClip: this.nearClip
                    }
                )

            );

        }

    },

    update: function( what ){

        this.build();

    },

    download: function(){

        var json = JSON.stringify( this.crossing.info, null, '\t' );

        NGL.download(
            new Blob( [ json ], {type : 'text/plain'} ),
            "helixCrossing.json"
        );

    }

} );


NGL.ContactRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.ContactRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.ContactRepresentation,

    type: "contact",

    defaultSize: 0.25,

    parameters: Object.assign( {

        contactType: {
            type: "select", rebuild: true,
            options: {
                "polar": "polar",
                "polarBackbone": "polar backbone"
            }
        },
        maxDistance: {
            type: "number", precision: 1, max: 10, min: 0.1, rebuild: true
        },
        maxAngle: {
            type: "integer", max: 180, min: 0, rebuild: true
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.radius = p.radius || this.defaultSize;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
        }else{
            this.sphereDetail = p.sphereDetail !== undefined ? p.sphereDetail : 1;
        }

        this.contactType = p.contactType || "polar";
        this.maxDistance = p.maxDistance || 3.5;
        this.maxAngle = p.maxAngle || 40;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var structureSubset = new NGL.StructureSubset(
            this.structure, this.selection
        );

        var contactsFnDict = {
            "polar": NGL.polarContacts,
            "polarBackbone": NGL.polarBackboneContacts
        };

        var contactData = contactsFnDict[ this.contactType ](
            structureSubset, this.maxDistance, this.maxAngle
        );

        this.contactAtomSet = contactData.atomSet;
        this.contactBondSet = contactData.bondSet;

        var atomSet = this.contactAtomSet;
        var bondSet = this.contactBondSet;

        if( atomSet.atomCount === 0 ) return;

        this.cylinderBuffer = new NGL.CylinderBuffer(
            bondSet.bondPosition( null, 0 ),
            bondSet.bondPosition( null, 1 ),
            bondSet.bondColor( null, 0, this.getColorParams() ),
            bondSet.bondColor( null, 1, this.getColorParams() ),
            bondSet.bondRadius( null, 0, this.radius, this.scale ),
            bondSet.bondPickingColor( null, 0 ),
            bondSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.cylinderBuffer );

        structureSubset.dispose();

    },

    update: function( what ){

        if( what[ "position" ] ){

            // FIXME
            this.build();
            return;

        }

        //

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var atomSet = this.contactAtomSet;
        var bondSet = this.contactBondSet;

        if( atomSet.atomCount === 0 ) return;

        var sphereData = {};
        var cylinderData = {};

        if( what[ "position" ] ){

            var from = bondSet.bondPosition( null, 0 );
            var to = bondSet.bondPosition( null, 1 );

            cylinderData[ "position" ] = NGL.Utils.calculateCenterArray(
                from, to
            );
            cylinderData[ "position1" ] = from;
            cylinderData[ "position2" ] = to;

        }

        if( what[ "color" ] ){

            cylinderData[ "color" ] = bondSet.bondColor(
                null, 0, this.getColorParams()
            );
            cylinderData[ "color2" ] = bondSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            cylinderData[ "radius" ] = bondSet.bondRadius(
                null, 0, this.radius, this.scale
            );

        }

        this.cylinderBuffer.setAttributes( cylinderData );

    },

    clear: function(){

        if( this.contactAtomSet ) this.contactAtomSet.dispose();
        if( this.contactBondSet ) this.contactBondSet.dispose();

        NGL.StructureRepresentation.prototype.clear.call( this );

    }

} );


NGL.MolecularSurfaceRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.MolecularSurfaceRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.MolecularSurfaceRepresentation,

    type: "surface",

    parameters: Object.assign( {

        surfaceType: {
            type: "select", rebuild: true,
            options: {
                "vws": "vws",
                "sas": "sas",
                "ms": "ms",
                "ses": "ses"
            }
        },
        probeRadius: {
            type: "number", precision: 1, max: 20, min: 0,
            rebuild: true
        },
        smooth: {
            type: "integer", precision: 1, max: 10, min: 0,
            rebuild: true
        },
        scaleFactor: {
            type: "number", precision: 1, max: 5, min: 0,
            rebuild: true
        },
        cutoff: {
            type: "number", precision: 2, max: 50, min: 0,
            rebuild: true
        },
        background: {
            type: "boolean", rebuild: true  // FIXME
        },
        opaqueBack: {
            type: "boolean", buffer: true
        },
        lowResolution: {
            type: "boolean", rebuild: true
        },
        filterSele: {
            type: "text", rebuild: true
        },

    }, NGL.StructureRepresentation.prototype.parameters, {

        radiusType: null,
        radius: null,
        scale: null

    } ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "uniform";
        p.colorValue = p.colorValue !== undefined ? p.colorValue : 0xDDDDDD;

        this.surfaceType = p.surfaceType !== undefined ? p.surfaceType : "ms";
        this.probeRadius = p.probeRadius !== undefined ? p.probeRadius : 1.4;
        this.smooth = p.smooth !== undefined ? p.smooth : 2;
        this.scaleFactor = p.scaleFactor !== undefined ? p.scaleFactor : 2.0;
        this.cutoff = p.cutoff || 0.0;
        this.background = p.background || false;
        this.opaqueBack = p.opaqueBack !== undefined ? p.opaqueBack : true;
        this.lowResolution = p.lowResolution !== undefined ? p.lowResolution : false;
        this.filterSele = p.filterSele !== undefined ? p.filterSele : "";

        NGL.StructureRepresentation.prototype.init.call( this, params );

    },

    prepare: function( callback ){

        if( !this.molsurf || this.__forceNewMolsurf ||
            this.__sele !== this.selection.combinedString ||
            this.__smooth !== this.smooth ||
            this.__surfaceType !== this.surfaceType ||
            this.__probeRadius !== this.probeRadius ||
            this.__scaleFactor !== this.scaleFactor ||
            this.__cutoff !== this.cutoff ||
            this.__lowResolution !== this.lowResolution
        ){

            if( this.molsurf ) this.molsurf.dispose();

            this.molsurf = new NGL.MolecularSurface( this.atomSet );
            this.__forceNewMolsurf = false;
            this.__sele = this.selection.combinedString;
            this.__smooth = this.smooth;
            this.__surfaceType = this.surfaceType;
            this.__probeRadius = this.probeRadius;
            this.__scaleFactor = this.scaleFactor;
            this.__cutoff = this.cutoff;
            this.__lowResolution = this.lowResolution;

            this.molsurf.getSurfaceWorker(
                this.surfaceType, this.probeRadius,
                this.scaleFactor, this.smooth,
                this.lowResolution, this.cutoff,
                function( surface ){
                    this.surface = surface;
                    callback();
                }.bind( this )
            );

        }else{

            callback();

        }

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var surfaceBuffer = new NGL.SurfaceBuffer(
            this.surface.getPosition(),
            this.surface.getColor( this.getColorParams() ),
            this.surface.getFilteredIndex( this.filterSele, this.atomSet.atoms ),
            this.surface.getNormal(),
            this.surface.getPickingColor( this.getColorParams() ),
            this.getBufferParams( {
                background: this.background,
                opaqueBack: this.opaqueBack,
                dullInterior: false
            } )
        );
        var doubleSidedBuffer = new NGL.DoubleSidedBuffer( surfaceBuffer );

        this.bufferList.push( doubleSidedBuffer );

    },

    update: function( what ){

        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var surfaceData = {};

        if( what[ "position" ] ){

            this.__forceNewMolsurf = true;
            this.build();
            return;

        }

        if( what[ "color" ] ){

            surfaceData[ "color" ] = this.surface.getColor( this.getColorParams() );

        }

        this.bufferList.forEach( function( buffer ){

            buffer.setAttributes( surfaceData );

        } );

    },

    setParameters: function( params, what, rebuild ){

        what = what || {};

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    },

    clear: function(){

        NGL.StructureRepresentation.prototype.clear.call( this );

    },

    dispose: function(){

        if( this.molsurf ) this.molsurf.dispose();

        NGL.StructureRepresentation.prototype.dispose.call( this );

    }

} );


NGL.DistanceRepresentation = function( structure, viewer, params ){

    NGL.StructureRepresentation.call( this, structure, viewer, params );

};

NGL.DistanceRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.DistanceRepresentation,

    type: "distance",

    defaultSize: 0.15,

    parameters: Object.assign( {

        font: {
            type: "select", options: {
                // "Arial": "Arial",
                // "DejaVu": "DejaVu",
                "LatoBlack": "LatoBlack"
            },
            rebuild: true
        },
        labelSize: {
            type: "number", precision: 3, max: 10.0, min: 0.001
        },
        labelColor: {
            type: "color"
        },
        labelVisible: {
            type: "boolean"
        },
        atomPair: {
            type: "hidden", rebuild: true
        },
        radiusSegments: {
            type: "integer", max: 25, min: 5, rebuild: "impostor"
        }

    }, NGL.StructureRepresentation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.radius = p.radius || this.defaultSize;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.radiusSegments = 5;
        }else if( p.quality === "medium" ){
            this.radiusSegments = 10;
        }else if( p.quality === "high" ){
            this.radiusSegments = 20;
        }else{
            this.radiusSegments = p.radiusSegments !== undefined ? p.radiusSegments : 10;
        }

        this.font = p.font || 'LatoBlack';
        this.labelSize = p.labelSize || 1.0;
        this.labelColor = p.labelColor || 0xFFFFFF;
        this.labelVisible = p.labelVisible !== undefined ? p.labelVisible : true;
        this.antialias = p.antialias !== undefined ? p.antialias : true;
        this.atomPair = p.atomPair || [];

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    create: function(){

        if( this.atomSet.atomCount === 0 ) return;

        var n = this.atomPair.length;
        if( n === 0 ) return;

        var text = new Array( n );
        var position = new Float32Array( n * 3 );
        var sele1 = new NGL.Selection();
        var sele2 = new NGL.Selection();

        this.bondSet = new NGL.BondSet();
        this.bondSet.structure = this.structure;
        var bSet = this.bondSet;

        var j = 0;

        this.atomPair.forEach( function( pair, i ){

            i -= j;

            var i3 = i * 3;

            sele1.setString( pair[ 0 ] );
            sele2.setString( pair[ 1 ] );

            var a1 = this.atomSet.getAtoms( sele1, true );
            var a2 = this.atomSet.getAtoms( sele2, true );

            if( a1 && a2 ){

                bSet.addBond( a1, a2, true );

                text[ i ] = a1.distanceTo( a2 ).toFixed( 2 );

                position[ i3 + 0 ] = ( a1.x + a2.x ) / 2;
                position[ i3 + 1 ] = ( a1.y + a2.y ) / 2;
                position[ i3 + 2 ] = ( a1.z + a2.z ) / 2;

            }else{

                j += 1;

            }

        }, this );

        if( j > 0 ){

            n -= j;
            position = position.subarray( 0, n * 3 );

        }

        var c = new THREE.Color( this.labelColor );

        this.textBuffer = new NGL.TextBuffer(
            position,
            NGL.Utils.uniformArray( n, this.labelSize ),
            NGL.Utils.uniformArray3( n, c.r, c.g, c.b ),
            text,
            this.getBufferParams( {
                font: this.font,
                antialias: this.antialias,
                opacity: 1.0,
                visible: this.labelVisible
            } )
        );

        this.__center = new Float32Array( bSet.bondCount * 3 );

        this.cylinderBuffer = new NGL.CylinderBuffer(
            bSet.bondPosition( null, 0 ),
            bSet.bondPosition( null, 1 ),
            bSet.bondColor( null, 0, this.getColorParams() ),
            bSet.bondColor( null, 1, this.getColorParams() ),
            bSet.bondRadius( null, null, this.radius, this.scale ),
            bSet.bondPickingColor( null, 0 ),
            bSet.bondPickingColor( null, 1 ),
            this.getBufferParams( {
                shift: 0,
                cap: true,
                radiusSegments: this.radiusSegments,
                dullInterior: true
            } ),
            this.disableImpostor
        );

        this.bufferList.push( this.textBuffer, this.cylinderBuffer );

    },

    update: function( what ){

        if( this.atomSet.atomCount === 0 ) return;
        if( this.bufferList.length === 0 ) return;

        var n = this.atomPair.length;
        if( n === 0 ) return;

        what = what || {};

        var bSet = this.bondSet;

        var textData = {};
        var cylinderData = {};

        if( what[ "position" ] ){

            var position = new Float32Array( n * 3 );
            var sele1 = new NGL.Selection();
            var sele2 = new NGL.Selection();

            this.atomPair.forEach( function( pair, i ){

                var i3 = i * 3;

                sele1.setString( pair[ 0 ] );
                sele2.setString( pair[ 1 ] );

                var a1 = this.atomSet.getAtoms( sele1, true );
                var a2 = this.atomSet.getAtoms( sele2, true );

                position[ i3 + 0 ] = ( a1.x + a2.x ) / 2;
                position[ i3 + 1 ] = ( a1.y + a2.y ) / 2;
                position[ i3 + 2 ] = ( a1.z + a2.z ) / 2;

            }, this );

            textData[ "position" ] = position;

            //

            var from = bSet.bondPosition( null, 0 );
            var to = bSet.bondPosition( null, 1 );

            cylinderData[ "position" ] = NGL.Utils.calculateCenterArray(
                from, to
            );
            cylinderData[ "position1" ] = from;
            cylinderData[ "position2" ] = to;

        }

        if( what[ "labelSize" ] ){

            textData[ "size" ] = NGL.Utils.uniformArray(
                n, this.labelSize
            );

        }

        if( what[ "labelColor" ] ){

            var c = new THREE.Color( this.labelColor );
            textData[ "color" ] = NGL.Utils.uniformArray3(
                n, c.r, c.g, c.b
            );

        }

        if( what[ "color" ] ){

            cylinderData[ "color" ] = bSet.bondColor(
                null, 0, this.getColorParams()
            );
            cylinderData[ "color2" ] = bSet.bondColor(
                null, 1, this.getColorParams()
            );

        }

        if( what[ "radius" ] || what[ "scale" ] ){

            cylinderData[ "radius" ] = bSet.bondRadius(
                null, 0, this.radius, this.scale
            );

        }

        this.textBuffer.setAttributes( textData );
        this.cylinderBuffer.setAttributes( cylinderData );

    },

    setVisibility: function( value, noRenderRequest ){

        NGL.StructureRepresentation.prototype.setVisibility.call(
            this, value, true
        );

        if( this.textBuffer ){

            this.textBuffer.setVisibility(
                this.labelVisible && this.visible
            );

        }

        if( !noRenderRequest ) this.viewer.requestRender();

        return this;

    },

    setParameters: function( params ){

        var rebuild = false;
        var what = {};

        if( params && params[ "labelSize" ] ){

            what[ "labelSize" ] = true;

        }

        if( params && params[ "labelColor" ] ){

            what[ "labelColor" ] = true;

        }

        NGL.StructureRepresentation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        if( params && params[ "labelVisible" ] !== undefined ){

            this.setVisibility( this.visible );

        }

        return this;

    },

    clear: function(){

        if( this.bondSet ) this.bondSet.dispose();

        NGL.StructureRepresentation.prototype.clear.call( this );

    }

} );


//////////////////////////////
// Trajectory representation

NGL.TrajectoryRepresentation = function( trajectory, viewer, params ){

    this.manualAttach = true;

    this.trajectory = trajectory;

    NGL.StructureRepresentation.call(
        this, trajectory.structure, viewer, params
    );

};

NGL.TrajectoryRepresentation.prototype = NGL.createObject(

    NGL.StructureRepresentation.prototype, {

    constructor: NGL.TrajectoryRepresentation,

    type: "",

    parameters: Object.assign( {

        drawLine: {
            type: "boolean", rebuild: true
        },
        drawCylinder: {
            type: "boolean", rebuild: true
        },
        drawPoint: {
            type: "boolean", rebuild: true
        },
        drawSphere: {
            type: "boolean", rebuild: true
        },

        linewidth: {
            type: "integer", max: 20, min: 1, rebuild: true
        },
        pointSize: {
            type: "integer", max: 20, min: 1, rebuild: true
        },
        sizeAttenuation: {
            type: "boolean", rebuild: true
        },
        sort: {
            type: "boolean", rebuild: true
        },

    }, NGL.Representation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "uniform";
        p.colorValue = p.colorValue || 0xDDDDDD;

        this.drawLine = p.drawLine || true;
        this.drawCylinder = p.drawCylinder || false;
        this.drawPoint = p.drawPoint || false;
        this.drawSphere = p.drawSphere || false;

        this.pointSize = p.pointSize || 1;
        this.sizeAttenuation = p.sizeAttenuation !== undefined ? p.sizeAttenuation : false;
        this.sort = p.sort !== undefined ? p.sort : true;

        NGL.StructureRepresentation.prototype.init.call( this, p );

    },

    attach: function( callback ){

        this.bufferList.forEach( function( buffer ){

            this.viewer.add( buffer );

        }, this );

        this.setVisibility( this.visible );

        callback();

    },

    prepare: function( callback ){

        // TODO

        callback();

    },

    create: function(){

        // NGL.log( this.selection )
        // NGL.log( this.atomSet )

        if( this.atomSet.atomCount === 0 ) return;

        var scope = this;

        var index = this.atomSet.atoms[ 0 ].index;

        this.trajectory.getPath( index, function( path ){

            var n = path.length / 3;
            var tc = new THREE.Color( scope.colorValue );

            if( scope.drawSphere ){

                var sphereBuffer = new NGL.SphereBuffer(
                    path,
                    NGL.Utils.uniformArray3( n, tc.r, tc.g, tc.b ),
                    NGL.Utils.uniformArray( n, 0.2 ),
                    NGL.Utils.uniformArray3( n, tc.r, tc.g, tc.b ),
                    scope.getBufferParams( {
                        sphereDetail: scope.sphereDetail,
                        dullInterior: true
                    } ),
                    scope.disableImpostor
                );

                scope.bufferList.push( sphereBuffer );

            }

            if( scope.drawCylinder ){

                var cylinderBuffer = new NGL.CylinderBuffer(
                    path.subarray( 0, -3 ),
                    path.subarray( 3 ),
                    NGL.Utils.uniformArray3( n - 1, tc.r, tc.g, tc.b ),
                    NGL.Utils.uniformArray3( n - 1, tc.r, tc.g, tc.b ),
                    NGL.Utils.uniformArray( n, 0.05 ),
                    NGL.Utils.uniformArray3( n - 1, tc.r, tc.g, tc.b ),
                    NGL.Utils.uniformArray3( n - 1, tc.r, tc.g, tc.b ),
                    scope.getBufferParams( {
                        shift: 0,
                        cap: true,
                        radiusSegments: scope.radiusSegments,
                        dullInterior: true
                    } ),
                    scope.disableImpostor

                );

                scope.bufferList.push( cylinderBuffer );

            }

            if( scope.drawPoint ){

                var pointBuffer = new NGL.PointBuffer(
                    path,
                    NGL.Utils.uniformArray3( n, tc.r, tc.g, tc.b ),
                    scope.getBufferParams( {
                        pointSize: scope.pointSize,
                        sizeAttenuation: scope.sizeAttenuation,
                        sort: scope.sort,
                    } )
                );

                scope.bufferList.push( pointBuffer );

            }

            if( scope.drawLine ){

                var lineBuffer = new NGL.LineBuffer(
                    path.subarray( 0, -3 ),
                    path.subarray( 3 ),
                    NGL.Utils.uniformArray3( n - 1, tc.r, tc.g, tc.b ),
                    NGL.Utils.uniformArray3( n - 1, tc.r, tc.g, tc.b ),
                    scope.getBufferParams()
                );

                scope.bufferList.push( lineBuffer );

            }

            scope.attach();

        } );

    }

} );


///////////////////////////
// Surface representation

NGL.SurfaceRepresentation = function( surface, viewer, params ){

    NGL.Representation.call( this, surface, viewer, params );

    if( surface instanceof NGL.Volume ){
        this.surface = undefined;
        this.volume = surface;
    }else{
        this.surface = surface;
        this.volume = undefined;
    }

    this.boxCenter = new THREE.Vector3();
    this.__boxCenter = new THREE.Vector3();
    this.box = new THREE.Box3();
    this.__box = new THREE.Box3();

    this.setBox = ( function(){
        var position = new THREE.Vector3();
        return function(){
            var target = viewer.controls.target;
            var group = viewer.rotationGroup.position;
            position.copy( group ).negate().add( target );
            this.setParameters( { "boxCenter": position } );
        }.bind( this );
    }.bind( this ) )();

    this.viewer.signals.orientationChanged.add(
        this.setBox
    );

    this.build();

};

NGL.SurfaceRepresentation.prototype = NGL.createObject(

    NGL.Representation.prototype, {

    constructor: NGL.SurfaceRepresentation,

    type: "surface",

    parameters: Object.assign( {

        isolevelType: {
            type: "select", options: {
                "value": "value", "sigma": "sigma"
            }
        },
        isolevel: {
            type: "number", precision: 2, max: 1000, min: -1000
        },
        smooth: {
            type: "integer", precision: 1, max: 10, min: 0
        },
        background: {
            type: "boolean", rebuild: true  // FIXME
        },
        opaqueBack: {
            type: "boolean", buffer: true
        },
        boxSize: {
            type: "integer", precision: 1, max: 100, min: 0
        }

    }, NGL.Representation.prototype.parameters ),

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "uniform";
        p.colorValue = p.colorValue !== undefined ? p.colorValue : 0xDDDDDD;

        this.isolevelType  = p.isolevelType !== undefined ? p.isolevelType : "sigma";
        this.isolevel = p.isolevel !== undefined ? p.isolevel : 2.0;
        this.smooth = p.smooth !== undefined ? p.smooth : 0;
        this.background = p.background || false;
        this.opaqueBack = p.opaqueBack !== undefined ? p.opaqueBack : true;
        this.boxSize = p.boxSize !== undefined ? p.boxSize : 0;

        NGL.Representation.prototype.init.call( this, p );

    },

    attach: function( callback ){

        this.bufferList.forEach( function( buffer ){

            this.viewer.add( buffer );

        }, this );

        this.setVisibility( this.visible );

        callback();

    },

    prepare: function( callback ){

        if( this.volume ){

            var isolevel;

            if( this.isolevelType === "sigma" ){
                isolevel = this.volume.getValueForSigma( this.isolevel );
            }else{
                isolevel = this.isolevel;
            }

            if( !this.surface ||
                this.__isolevel !== isolevel ||
                this.__smooth !== this.smooth ||
                this.__boxSize !== this.boxSize ||
                ( this.boxSize > 0 &&
                    !this.__boxCenter.equals( this.boxCenter ) )
            ){
                this.__isolevel = isolevel;
                this.__smooth = this.smooth;
                this.__boxSize = this.boxSize;
                this.__boxCenter.copy( this.boxCenter );
                this.__box.copy( this.box );

                this.volume.getSurfaceWorker(
                    isolevel, this.smooth, this.boxCenter, this.boxSize,
                    function( surface ){
                        this.surface = surface;
                        callback();
                    }.bind( this )
                );
            }else{
                callback();
            }

        }else{
            callback();
        }

    },

    create: function(){

        var surfaceBuffer = new NGL.SurfaceBuffer(
            this.surface.getPosition(),
            this.surface.getColor( this.getColorParams() ),
            this.surface.getIndex(),
            this.surface.getNormal(),
            undefined,  // this.surface.getPickingColor( this.getColorParams() ),
            this.getBufferParams( {
                background: this.background,
                opaqueBack: this.opaqueBack,
                dullInterior: false,
            } )
        );
        var doubleSidedBuffer = new NGL.DoubleSidedBuffer( surfaceBuffer );

        this.bufferList.push( doubleSidedBuffer );

    },

    update: function( what ){

        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var surfaceData = {};

        if( what[ "position" ] ){
            surfaceData[ "position" ] = this.surface.getPosition();
        }

        if( what[ "color" ] ){
            surfaceData[ "color" ] = this.surface.getColor(
                this.getColorParams()
            );
        }

        if( what[ "index" ] ){
            surfaceData[ "index" ] = this.surface.getIndex();
        }

        if( what[ "normal" ] ){
            surfaceData[ "normal" ] = this.surface.getNormal();
        }

        this.bufferList.forEach( function( buffer ){
            buffer.setAttributes( surfaceData );
        } );

    },

    setParameters: function( params, what, rebuild ){

        if( params && params[ "isolevelType" ] !== undefined &&
            this.volume
        ){

            if( this.isolevelType === "value" &&
                params[ "isolevelType" ] === "sigma"
            ){

                this.isolevel = this.volume.getSigmaForValue(
                    this.isolevel
                );

            }else if( this.isolevelType === "sigma" &&
                params[ "isolevelType" ] === "value"
            ){

                this.isolevel = this.volume.getValueForSigma(
                    this.isolevel
                );

            }

            this.isolevelType = params[ "isolevelType" ];

        }

        if( params && params[ "boxCenter" ] ){
            this.boxCenter.copy( params[ "boxCenter" ] );
            delete params[ "boxCenter" ];
        }

        NGL.Representation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        this.volume.getBox( this.boxCenter, this.boxSize, this.box );

        if( this.surface && (
                params[ "isolevel" ] !== undefined ||
                params[ "smooth" ] !== undefined ||
                params[ "boxSize" ] !== undefined ||
                ( this.boxSize > 0 &&
                    !this.__box.equals( this.box ) )
            )
        ){
            this.build( {
                "__update": {
                    "position": true,
                    "color": true,
                    "index": true,
                    "normal": true
                }
            } );
        }

        return this;

    },

    dispose: function(){

        this.viewer.signals.orientationChanged.remove(
            this.setBox
        );

        NGL.Representation.prototype.dispose.call( this );

    }

} );


NGL.DotRepresentation = function( surface, viewer, params ){

    NGL.Representation.call( this, surface, viewer, params );

    if( surface instanceof NGL.Volume ){
        this.surface = undefined;
        this.volume = surface;
    }else{
        this.surface = surface;
        this.volume = undefined;
    }

    this.build();

};

NGL.DotRepresentation.prototype = NGL.createObject(

    NGL.Representation.prototype, {

    constructor: NGL.DotRepresentation,

    type: "dot",

    parameters: Object.assign( {

        thresholdType: {
            type: "select", rebuild: true, options: {
                "value": "value", "sigma": "sigma"
            }
        },
        thresholdMin: {
            type: "number", precision: 3, max: 1000, min: -1000, rebuild: true
        },
        thresholdMax: {
            type: "number", precision: 3, max: 1000, min: -1000, rebuild: true
        },
        thresholdOut: {
            type: "boolean", rebuild: true
        },
        dotType: {
            type: "select", rebuild: true, options: {
                "": "",
                "sphere": "sphere",
                "point": "point"
            }
        },
        radiusType: {
            type: "select", options: {
                "": "",
                "value": "value",
                "abs-value": "abs-value",
                "value-min": "value-min",
                "deviation": "deviation",
                "size": "size"
            }
        },
        radius: {
            type: "number", precision: 3, max: 10.0, min: 0.001, property: "size"
        },
        scale: {
            type: "number", precision: 3, max: 10.0, min: 0.001
        },
        sort: {
            type: "boolean", rebuild: true
        },
        sphereDetail: {
            type: "integer", max: 3, min: 0, rebuild: "impostor"
        },

    }, NGL.Representation.prototype.parameters, {

        colorScheme: {
            type: "select", update: "color", options: {
                "": "",
                "value": "value",
                "uniform": "uniform",
                // "value-min": "value-min",
                // "deviation": "deviation",
                // "size": "size"
            }
        },

    } ),

    defaultSize: 0.1,

    init: function( params ){

        var p = params || {};
        p.colorScheme = p.colorScheme || "uniform";
        p.colorValue = p.colorValue || 0xDDDDDD;

        this.disableImpostor = p.disableImpostor || false;

        if( p.quality === "low" ){
            this.sphereDetail = 0;
        }else if( p.quality === "medium" ){
            this.sphereDetail = 1;
        }else if( p.quality === "high" ){
            this.sphereDetail = 2;
        }else{
            this.sphereDetail = p.sphereDetail || 1;
        }

        this.thresholdType  = p.thresholdType !== undefined ? p.thresholdType : "sigma";
        this.thresholdMin = p.thresholdMin !== undefined ? p.thresholdMin : 2.0;
        this.thresholdMax = p.thresholdMax !== undefined ? p.thresholdMax : Infinity;
        this.thresholdOut = p.thresholdOut !== undefined ? p.thresholdOut : false;
        this.dotType = p.dotType !== undefined ? p.dotType : "point";
        this.radius = p.radius !== undefined ? p.radius : 0.1;
        this.scale = p.scale !== undefined ? p.scale : 1.0;
        this.sort = p.sort !== undefined ? p.sort : false;

        NGL.Representation.prototype.init.call( this, p );

    },

    attach: function( callback ){

        this.bufferList.forEach( function( buffer ){

            this.viewer.add( buffer );

        }, this );

        this.setVisibility( this.visible );

        callback();

    },

    create: function(){

        var position, color, size, pickingColor;

        if( this.volume ){

            var thresholdMin, thresholdMax;

            if( this.thresholdType === "sigma" ){
                thresholdMin = this.volume.getValueForSigma( this.thresholdMin );
                thresholdMax = this.volume.getValueForSigma( this.thresholdMax );
            }else{
                thresholdMin = this.thresholdMin;
                thresholdMax = this.thresholdMax;
            }
            this.volume.filterData( thresholdMin, thresholdMax, this.thresholdOut );

            position = this.volume.getDataPosition();
            color = this.volume.getDataColor( this.getColorParams() );
            size = this.volume.getDataSize( this.radius, this.scale );
            pickingColor = this.volume.getPickingDataColor( this.getColorParams() );

        }else{

            position = this.surface.getPosition();
            color = this.surface.getColor( this.getColorParams() );
            size = this.surface.getSize( this.radius, this.scale );
            pickingColor = this.surface.getPickingColor( this.getColorParams() );

        }

        if( this.dotType === "sphere" ){

            this.dotBuffer = new NGL.SphereBuffer(
                position,
                color,
                size,
                pickingColor,
                this.getBufferParams( {
                    sphereDetail: this.sphereDetail,
                    dullInterior: false
                } ),
                this.disableImpostor
            );

        }else{

            this.dotBuffer = new NGL.PointBuffer(
                position,
                color,
                this.getBufferParams( {
                    pointSize: this.radius,
                    sizeAttenuation: true,  // this.sizeAttenuation,
                    sort: this.sort,
                } )
            );

        }

        this.bufferList.push( this.dotBuffer );

    },

    update: function( what ){

        if( this.bufferList.length === 0 ) return;

        what = what || {};

        var dotData = {};

        if( what[ "color" ] ){

            if( this.volume ){

                dotData[ "color" ] = this.volume.getDataColor(
                    this.getColorParams()
                );

            }else{

                dotData[ "color" ] = this.surface.getColor(
                    this.getColorParams()
                );

            }

        }

        if( this.dotType === "sphere" && ( what[ "radius" ] || what[ "scale" ] ) ){

            if( this.volume ){

                dotData[ "radius" ] = this.volume.getDataSize(
                    this.radius, this.scale
                );

            }else{

                dotData[ "radius" ] = this.surface.getSize(
                    this.radius, this.scale
                );

            }

        }

        this.dotBuffer.setAttributes( dotData );

    },

    setParameters: function( params, what, rebuild ){

        what = what || {};

        if( params && params[ "thresholdType" ] !== undefined &&
            this.volume instanceof NGL.Volume
        ){

            if( this.thresholdType === "value" &&
                params[ "thresholdType" ] === "sigma"
            ){

                this.thresholdMin = this.volume.getSigmaForValue(
                    this.thresholdMin
                );
                this.thresholdMax = this.volume.getSigmaForValue(
                    this.thresholdMax
                );

            }else if( this.thresholdType === "sigma" &&
                params[ "thresholdType" ] === "value"
            ){

                this.thresholdMin = this.volume.getValueForSigma(
                    this.thresholdMin
                );
                this.thresholdMax = this.volume.getValueForSigma(
                    this.thresholdMax
                );

            }

            this.thresholdType = params[ "thresholdType" ];

        }

        if( params && params[ "radiusType" ] !== undefined ){

            if( params[ "radiusType" ] === "radius" ){
                this.radius = this.defaultSize;
            }else{
                this.radius = params[ "radiusType" ];
            }
            what[ "radius" ] = true;
            if( this.dotType === "sphere" &&
                ( !NGL.extensionFragDepth || this.disableImpostor )
            ){
                rebuild = true;
            }

        }

        if( params && params[ "radius" ] !== undefined ){

            what[ "radius" ] = true;
            if( this.dotType === "sphere" &&
                ( !NGL.extensionFragDepth || this.disableImpostor )
            ){
                rebuild = true;
            }

        }

        if( params && params[ "scale" ] !== undefined ){

            what[ "scale" ] = true;
            if( this.dotType === "sphere" &&
                ( !NGL.extensionFragDepth || this.disableImpostor )
            ){
                rebuild = true;
            }

        }

        NGL.Representation.prototype.setParameters.call(
            this, params, what, rebuild
        );

        return this;

    }

} );


/////////////////////////
// Representation types

( function(){

    NGL.representationTypes = {};
    var reprList = [];

    // find structure representations

    for( var key in NGL ){

        var val = NGL[ key ];

        if( val.prototype instanceof NGL.StructureRepresentation &&
            val.prototype.type
        ){

            reprList.push( val );

        }

    }

    // sort by representation type (i.e. name)

    reprList.sort( function( a, b ){

            return a.prototype.type.localeCompare( b.prototype.type );

    } ).forEach( function( repr ){

        NGL.representationTypes[ repr.prototype.type ] = repr;

    } );

} )();

// File:js/ngl/stage.js

/**
 * @file Stage
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */


//////////
// Stage

NGL.Stage = function( eid ){

    var SIGNALS = signals;

    this.signals = {

        themeChanged: new SIGNALS.Signal(),

        componentAdded: new SIGNALS.Signal(),
        componentRemoved: new SIGNALS.Signal(),

        atomPicked: new SIGNALS.Signal(),
        bondPicked: new SIGNALS.Signal(),
        volumePicked: new SIGNALS.Signal(),
        nothingPicked: new SIGNALS.Signal(),
        onPicking: new SIGNALS.Signal(),

        requestTheme: new SIGNALS.Signal()

    };

    this.tasks = new NGL.Counter();

    this.compList = [];

    this.preferences =  new NGL.Preferences( this );

    this.viewer = new NGL.Viewer( eid );

    this.preferences.setTheme();

    this.defaultFileParams = {};

    this.initFileDragDrop();

    this.viewer.animate();

    this.pickingControls = new NGL.PickingControls( this.viewer, this );

}

NGL.Stage.prototype = {

    constructor: NGL.Stage,

    defaultFileRepresentation: function( object ){

        if( object instanceof NGL.StructureComponent ){

            if( object.structure.atomCount > 100000 ){

                object.addRepresentation( "line" );
                object.centerView( true );

            }else{

                object.addRepresentation( "cartoon", { sele: "*" } );
                object.addRepresentation( "licorice", { sele: "hetero" } );
                object.centerView( true );

            }

            // add frames as trajectory
            if( object.structure.frames.length ) object.addTrajectory();

        }else if( object instanceof NGL.SurfaceComponent ){

            object.addRepresentation( "surface" );
            object.centerView();

        }

    },

    initFileDragDrop: function(){

        this.viewer.container.addEventListener( 'dragover', function( e ){

            e.stopPropagation();
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';

        }, false );

        this.viewer.container.addEventListener( 'drop', function( e ){

            e.stopPropagation();
            e.preventDefault();

            var fileList = e.dataTransfer.files;
            var n = fileList.length;

            for( var i=0; i<n; ++i ){

                // TODO loading params (e.g. set in GUI)
                this.loadFile( fileList[ i ] );

            }

        }.bind( this ), false );

    },

    loadFile: function( path, params ){

        var p = Object.assign( {}, this.defaultFileParams, params );

        // placeholder component
        var component = new NGL.Component( this, p );
        component.name = NGL.getFileInfo( path ).name;
        this.addComponent( component );

        var onLoadFn = function( object ){

            // remove placeholder component
            this.removeComponent( component );

            component = this.addComponentFromObject( object, p );

            if( component instanceof NGL.ScriptComponent ){
                component.run();
            }

            if( p.defaultRepresentation ){
                this.defaultFileRepresentation( component );
            }

            return component;

        }.bind( this );

        var onErrorFn = function( e ){

            component.setStatus( e );
            throw e;

        }

        return NGL.autoLoad( path, p ).then( onLoadFn, onErrorFn );

    },

    addComponent: function( component ){

        if( !component ){

            NGL.warn( "NGL.Stage.addComponent: no component given" );
            return;

        }

        this.compList.push( component );

        this.signals.componentAdded.dispatch( component );

    },

    addComponentFromObject: function( object, params ){

        var component = NGL.makeComponent( this, object, params );

        this.addComponent( component );

        return component;

    },

    removeComponent: function( component ){

        var idx = this.compList.indexOf( component );

        if( idx !== -1 ){

            this.compList.splice( idx, 1 );

        }

        component.dispose();

        this.signals.componentRemoved.dispatch( component );

    },

    removeAllComponents: function( type ){

        this.compList.slice().forEach( function( o, i ){

            if( !type || o instanceof type ){

                this.removeComponent( o );

            }

        }, this );

    },

    handleResize: function(){

        this.viewer.handleResize();

    },

    toggleFullscreen: function( element ){

        if( !document.fullscreenEnabled && !document.mozFullScreenEnabled &&
            !document.webkitFullscreenEnabled && !document.msFullscreenEnabled
        ){
            console.log( "fullscreen mode (currently) not possible" );
            return;
        }

        var self = this;
        element = element || this.viewer.container;
        this.lastFullscreenElement = element;

        //

        function getFullscreenElement(){
            return document.fullscreenElement || document.mozFullScreenElement ||
                document.webkitFullscreenElement || document.msFullscreenElement;
        }

        function resizeElement(){

            if( !getFullscreenElement() && self.lastFullscreenElement ){

                var element = self.lastFullscreenElement;
                element.style.width = element.dataset.normalWidth;
                element.style.height = element.dataset.normalHeight;

                document.removeEventListener( "fullscreenchange", resizeElement );
                document.removeEventListener( "mozfullscreenchange", resizeElement );
                document.removeEventListener( "webkitfullscreenchange", resizeElement );
                document.removeEventListener( "msfullscreenchange", resizeElement );

                self.handleResize();

            }

        }

        //

        if( !getFullscreenElement() ){

            element.dataset.normalWidth = element.style.width;
            element.dataset.normalHeight = element.style.height;
            element.style.width = screen.width + "px";
            element.style.height = screen.height + "px";

            self.handleResize();

            if( element.requestFullscreen ){
                element.requestFullscreen();
            }else if( element.msRequestFullscreen ){
                element.msRequestFullscreen();
            }else if( element.mozRequestFullScreen ){
                element.mozRequestFullScreen();
            }else if( element.webkitRequestFullscreen ){
                element.webkitRequestFullscreen();
            }

            document.addEventListener( "fullscreenchange", resizeElement );
            document.addEventListener( "mozfullscreenchange", resizeElement );
            document.addEventListener( "webkitfullscreenchange", resizeElement );
            document.addEventListener( "msfullscreenchange", resizeElement );

        }else{

            if( document.exitFullscreen ){
                document.exitFullscreen();
            }else if( document.msExitFullscreen ){
                document.msExitFullscreen();
            }else if( document.mozCancelFullScreen ){
                document.mozCancelFullScreen();
            }else if( document.webkitExitFullscreen ){
                document.webkitExitFullscreen();
            }

        }

    },

    centerView: function(){

        if( this.tasks.count > 0 ){

            var centerFn = function( delta, count ){

                if( count === 0 ){

                    this.tasks.signals.countChanged.remove( centerFn, this );

                }

                this.viewer.centerView( true );

            }

            this.tasks.signals.countChanged.add( centerFn, this );

        }

        this.viewer.centerView( true );

    },

    setOrientation: function( orientation ){

        this.tasks.onZeroOnce( function(){

            this.viewer.setOrientation( orientation );

        }, this );

    },

    getOrientation: function(){

        return this.viewer.getOrientation();

    },

    exportImage: function( factor, antialias, transparent, trim, onProgress ){

        var reprParamsList = [];

        // this.eachRepresentation( function( repr ){

        //     if( repr.visible && repr.parent.visible ){

        //         var r = repr.repr;

        //         var op = {
        //             subdiv: r.subdiv,
        //             radialSegments: r.radialSegments,
        //             sphereDetail: r.sphereDetail,
        //             radiusSegments: r.radiusSegments
        //         }

        //         reprParamsList.push( {
        //             repr: repr,
        //             params: op
        //         } );

        //         var p = {};

        //         if( op.subdiv !== undefined ){
        //             p.subdiv = Math.max( 12, op.subdiv );
        //         }

        //         if( op.radialSegments !== undefined ){
        //             p.radialSegments = Math.max( 20, op.radialSegments );
        //         }

        //         if( op.sphereDetail !== undefined ){
        //             p.sphereDetail = Math.max( 2, op.sphereDetail );
        //         }

        //         if( op.radiusSegments !== undefined ){
        //             p.radiusSegments = Math.max( 20, op.radiusSegments );
        //         }

        //         repr.setParameters( p );

        //     }

        // }, NGL.StructureComponent );

        function makeScreenshot(){

            this.viewer.screenshot( {

                factor: factor,
                type: "image/png",
                quality: 1.0,
                antialias: antialias,
                transparent: transparent,
                trim: trim,

                onProgress: function( i, n, finished ){

                    if( typeof onProgress === "function" ){

                        onProgress( i, n, finished );

                    }

                    if( finished ){

                        reprParamsList.forEach( function( d ){

                            d.repr.setParameters( d.params );

                        } );

                    }

                }

            } );

        }

        this.tasks.onZeroOnce( makeScreenshot, this );

    },

    setTheme: function( value ){

        var viewerBackground;

        if( value === "light" ){
            viewerBackground = "white";
        }else{
            viewerBackground = "black";
        }

        this.signals.requestTheme.dispatch( value );
        this.viewer.setBackground( viewerBackground );

    },

    eachComponent: function( callback, type ){

        this.compList.forEach( function( o, i ){

            if( !type || o instanceof type ){

                callback( o, i );

            }

        } );

    },

    eachRepresentation: function( callback, componentType ){

        this.eachComponent( function( comp ){

            comp.reprList.forEach( function( repr ){

                callback( repr, comp );

            } );

        }, componentType );

    },

    getComponentsByName: function( name, componentType ){

        var compList = [];

        this.eachComponent( function( comp ){

            if( name === undefined || comp.name.match( name ) !== null ){
                compList.push( comp );
            }

        }, componentType );

        return new NGL.ComponentCollection( compList );

    },

    getRepresentationsByName: function( name, componentType ){

        var compName, reprName;

        if( typeof name !== "object" ){
            compName = undefined;
            reprName = name;
        }else{
            compName = name.comp;
            reprName = name.repr;
        }

        var reprList = [];

        this.eachRepresentation( function( repr, comp ){

            if( compName !== undefined && comp.name.match( compName ) === null ){
                return;
            }

            if( reprName === undefined || repr.name.match( reprName ) !== null ){
                reprList.push( repr );
            }

        }, componentType );

        return new NGL.RepresentationCollection( reprList );

    },

    getAnythingByName: function( name ){

        var compList = this.getComponentsByName( name ).list;
        var reprList = this.getRepresentationsByName( name ).list;

        return new NGL.Collection( compList.concat( reprList ) );

    },

    dispose: function(){

        this.tasks.dispose();

    }

}


////////////
// Picking

NGL.PickingControls = function( viewer, stage ){

    var position = new THREE.Vector3();

    var mouse = {

        position: new THREE.Vector2(),
        down: new THREE.Vector2(),
        moving: false,
        distance: function(){
            return mouse.position.distanceTo( mouse.down );
        }

    };

    viewer.renderer.domElement.addEventListener( 'mousemove', function( e ){

        e.preventDefault();
        // e.stopPropagation();

        mouse.moving = true;
        mouse.position.x = e.layerX;
        mouse.position.y = e.layerY;

    } );

    viewer.renderer.domElement.addEventListener( 'mousedown', function( e ){

        e.preventDefault();
        // e.stopPropagation();

        mouse.moving = false;
        mouse.down.x = e.layerX;
        mouse.down.y = e.layerY;

    } );

    viewer.renderer.domElement.addEventListener( 'mouseup', function( e ){

        e.preventDefault();
        // e.stopPropagation();

        if( mouse.distance() > 3 || e.which === NGL.RightMouseButton ) return;

        var box = viewer.renderer.domElement.getBoundingClientRect();

        var offsetX = e.clientX - box.left;
        var offsetY = e.clientY - box.top;

        var pickingData = viewer.pick(
            offsetX,
            box.height - offsetY
        );
        var gid = pickingData.gid;
        var instance = pickingData.instance;

        var pickedAtom = undefined;
        var pickedBond = undefined;
        var pickedVolume = undefined;

        var picked = NGL.GidPool.getByGid( gid );

        if( picked instanceof NGL.Atom || picked instanceof NGL.ProxyAtom ){

            pickedAtom = picked;

        }else if( picked instanceof NGL.Bond ){

            pickedBond = picked;

        }else if( picked && picked.volume instanceof NGL.Volume ){

            pickedVolume = picked;

        }

        //

        if( ( pickedAtom || pickedBond || pickedVolume ) &&
                e.which === NGL.MiddleMouseButton
        ){

            if( pickedAtom ){

                position.copy( pickedAtom );

            }else if( pickedBond ){

                position.set( 0, 0, 0 )
                    .addVectors( pickedBond.atom1, pickedBond.atom2 )
                    .multiplyScalar( 0.5 );

            }else if( pickedVolume ){

                position.copy( pickedVolume );

            }

            if( instance ){

                position.applyProjection( instance.matrix );

            }

            viewer.centerView( false, position );

        }

        //

        if( pickedAtom ){

            stage.signals.atomPicked.dispatch( pickedAtom );

        }else if( pickedBond ){

            stage.signals.bondPicked.dispatch( pickedBond );

        }else if( pickedVolume ){

            stage.signals.volumePicked.dispatch( pickedVolume );

        }else{

            stage.signals.nothingPicked.dispatch();

        }

        stage.signals.onPicking.dispatch( {

            "atom": pickedAtom,
            "bond": pickedBond,
            "volume": pickedVolume,
            "instance": instance

        } );

        //

        if( NGL.debug ){

            NGL.log( "picked atom", pickedAtom );
            NGL.log( "picked bond", pickedBond );
            NGL.log( "picked volume", pickedVolume );

        }

    } );

};


////////////////
// Preferences

NGL.Preferences = function( stage, id ){

    this.id = id || "ngl-stage";

    this.stage = stage;

    this.storage = {

        impostor: true,
        quality: "medium",
        theme: "dark",
        overview: true

    };


    try{

        if ( window.localStorage[ this.id ] === undefined ) {

            window.localStorage[ this.id ] = JSON.stringify( this.storage );

        } else {

            var data = JSON.parse( window.localStorage[ this.id ] );

            for ( var key in data ) {

                this.storage[ key ] = data[ key ];

            }

        }

    }catch( e ){

        NGL.error( "localStorage not accessible/available" );

    }

};

NGL.Preferences.prototype = {

    constructor: NGL.Preferences,

    setImpostor: function( value ) {

        if( value !== undefined ){
            this.setKey( "impostor", value );
        }else{
            value = this.getKey( "impostor" );
        }

        var types = [
            "spacefill", "ball+stick", "licorice", "hyperball",
            "backbone", "rocket", "crossing", "contact",
            "dot"
        ];

        this.stage.eachRepresentation( function( repr ){

            if( repr instanceof NGL.ScriptComponent ) return;

            if( types.indexOf( repr.getType() ) === -1 ){
                return;
            }

            var p = repr.getParameters();
            p.disableImpostor = !value;
            repr.build( p );

        } );

    },

    setQuality: function( value ) {

        if( value !== undefined ){
            this.setKey( "quality", value );
        }else{
            value = this.getKey( "quality" );
        }

        var types = [
            "tube", "cartoon", "ribbon", "trace", "rope"
        ];

        var impostorTypes = [
            "spacefill", "ball+stick", "licorice", "hyperball",
            "backbone", "rocket", "crossing", "contact",
            "dot"
        ];

        this.stage.eachRepresentation( function( repr ){

            if( repr instanceof NGL.ScriptComponent ) return;

            var p = repr.getParameters();

            if( types.indexOf( repr.getType() ) === -1 ){

                if( impostorTypes.indexOf( repr.getType() ) === -1 ){
                    return;
                }

                if( NGL.extensionFragDepth && !p.disableImpostor ){
                    repr.repr.quality = value;
                    return;
                }

            }

            p.quality = value;
            repr.build( p );

        } );

    },

    setTheme: function( value ) {

        if( value !== undefined ){
            this.setKey( "theme", value );
        }else{
            value = this.getKey( "theme" );
        }

        this.stage.setTheme( value );

    },

    getKey: function( key ){

        return this.storage[ key ];

    },

    setKey: function( key, value ){

        this.storage[ key ] = value;

        try{

            window.localStorage[ this.id ] = JSON.stringify( this.storage );

        }catch( e ){

            // Webkit === 22 / Firefox === 1014

            if( e.code === 22 || e.code === 1014 ){

                NGL.error( "localStorage full" );

            }else{

                NGL.error( "localStorage not accessible/available" );

            }

        }

    },

    clear: function(){

        try{

            delete window.localStorage[ this.id ];

        }catch( e ){

            NGL.error( "localStorage not accessible/available" );

        }

    }

};


//////////////
// Component

NGL.makeComponent = function( stage, object, params ){

    var component;

    if( object instanceof NGL.Structure ){

        component = new NGL.StructureComponent( stage, object, params );

    }else if( object instanceof NGL.Surface || object instanceof NGL.Volume ){

        component = new NGL.SurfaceComponent( stage, object, params );

    }else if( object instanceof NGL.Script ){

        component = new NGL.ScriptComponent( stage, object, params );

    }else{

        NGL.warn( "NGL.makeComponent: object type unknown", object );

    }

    return component;

};


NGL.nextComponentId = 0;


NGL.Component = function( stage, params ){

    Object.defineProperty( this, 'id', { value: NGL.nextComponentId++ } );

    var p = params || {};

    this.name = p.name;
    this.uuid = THREE.Math.generateUUID();
    this.visible = p.visible !== undefined ? p.visible : true;

    // construct instance signals
    var signalNames = Object.keys( this.signals );
    this.signals = {};
    signalNames.forEach( function( name ){
        this.signals[ name ] = new signals.Signal();
    }, this );

    this.stage = stage;
    this.viewer = stage.viewer;

    this.reprList = [];

}

NGL.Component.prototype = {

    constructor: NGL.Component,

    type: "component",

    signals: {

        representationAdded: null,
        representationRemoved: null,
        visibilityChanged: null,
        requestGuiVisibility: null,

        statusChanged: null,
        nameChanged: null,
        disposed: null,

    },

    addRepresentation: function( type, object, params ){

        var pref = this.stage.preferences;
        var p = params || {};
        p.quality = p.quality || pref.getKey( "quality" );
        p.disableImpostor = p.disableImpostor !== undefined ? p.disableImpostor : !pref.getKey( "impostor" );
        p.visible = p.visible !== undefined ? p.visible : true;

        var p2 = Object.assign( {}, p, { visible: this.visible && p.visible } );

        var repr = NGL.makeRepresentation(
            type, object, this.viewer, p2
        );

        var reprComp = new NGL.RepresentationComponent(
            this.stage, repr, p, this
        );

        this.reprList.push( reprComp );

        this.signals.representationAdded.dispatch( reprComp );

        return reprComp;

    },

    addBufferRepresentation: function( buffer, params ){

        return NGL.Component.prototype.addRepresentation.call(
            this, "buffer", buffer, params
        );

    },

    removeRepresentation: function( repr ){

        var idx = this.reprList.indexOf( repr );

        if( idx !== -1 ){

            this.reprList.splice( idx, 1 );

        }

        this.signals.representationRemoved.dispatch( repr );

    },

    updateRepresentations: function( what ){

        this.reprList.forEach( function( repr ){

            repr.update( what );

        } );

        this.stage.viewer.requestRender();

    },

    clearRepresentations: function(){

        // copy via .slice because side effects may change reprList
        this.reprList.slice().forEach( function( repr ){

            repr.dispose();

        } );

    },

    dispose: function(){

        this.clearRepresentations();

        delete this.reprList;

        this.signals.disposed.dispatch();

    },

    setVisibility: function( value ){

        this.visible = value;

        this.eachRepresentation( function( repr ){

            repr.updateVisibility();

        } );

        this.signals.visibilityChanged.dispatch( value );

        return this;

    },

    setStatus: function( value ){

        this.status = value;
        this.signals.statusChanged.dispatch( value );

        return this;

    },

    setName: function( value ){

        this.name = value;
        this.signals.nameChanged.dispatch( value );

        return this;

    },

    getCenter: function(){

        // NGL.warn( "not implemented" )

    },

    requestGuiVisibility: function( value ){

        this.signals.requestGuiVisibility.dispatch( value );

        return this;

    },

    eachRepresentation: function( callback ){

        this.reprList.forEach( callback );

    }

};


NGL.StructureComponent = function( stage, structure, params ){

    var p = params || {};
    p.name = p.name !== undefined ? p.name : structure.name;

    NGL.Component.call( this, stage, p );

    this.__structure = structure;
    this.structure = structure;

    this.trajList = [];
    this.initSelection( p.sele );

    if( p.assembly !== undefined ){
        this.structure.setDefaultAssembly( p.assembly );
    }

};

NGL.StructureComponent.prototype = NGL.createObject(

    NGL.Component.prototype, {

    constructor: NGL.StructureComponent,

    type: "structure",

    signals: Object.assign( {

        trajectoryAdded: null,
        trajectoryRemoved: null

    }, NGL.Component.prototype.signals ),

    initSelection: function( string ){

        this.selection = new NGL.Selection( string );

        this.selection.signals.stringChanged.add( function( string ){

            this.applySelection();

            this.rebuildRepresentations( true );
            this.rebuildTrajectories();

        }, this );

        this.applySelection();

    },

    applySelection: function(){

        if( this.selection.string ){

            this.structure = new NGL.StructureSubset(
                this.__structure, this.selection
            );

        }else{

            this.structure = this.__structure;

        }

    },

    setSelection: function( string ){

        this.selection.setString( string );

        return this;

    },

    rebuildRepresentations: function( setStructure ){

        this.reprList.forEach( function( repr ){

            if( setStructure ){
                repr.setStructure( this.structure );
            }

            repr.build( repr.getParameters() );

        }, this );

    },

    rebuildTrajectories: function(){

        this.trajList.slice( 0 ).forEach( function( trajComp ){

            trajComp.trajectory.setStructure( this.structure );

        }, this );

    },

    addRepresentation: function( type, params ){

        return NGL.Component.prototype.addRepresentation.call(
            this, type, this.structure, params
        );

    },

    addTrajectory: function( trajPath, sele, i ){

        var params = { "i": i };

        var traj = NGL.makeTrajectory(
            trajPath, this.structure, sele
        );

        traj.signals.frameChanged.add( function( value ){

            this.updateRepresentations( { "position": true } );

        }, this );

        var trajComp = new NGL.TrajectoryComponent(
            this.stage, traj, params, this
        );

        this.trajList.push( trajComp );

        this.signals.trajectoryAdded.dispatch( trajComp );

        return trajComp;

    },

    removeTrajectory: function( traj ){

        var idx = this.trajList.indexOf( traj );

        if( idx !== -1 ){

            this.trajList.splice( idx, 1 );

        }

        traj.dispose();

        this.signals.trajectoryRemoved.dispatch( traj );

    },

    dispose: function(){

        // copy via .slice because side effects may change trajList
        this.trajList.slice().forEach( function( traj ){

            traj.dispose();

        } );

        this.trajList = [];

        this.structure.dispose();
        this.__structure.dispose();

        NGL.Component.prototype.dispose.call( this );

    },

    centerView: function( zoom, sele ){

        var center;

        if( sele ){

            var selection = new NGL.Selection( sele );

            center = this.structure.atomCenter( selection );

            if( zoom ){
                var bb = this.structure.getBoundingBox( selection );
                zoom = bb.size().length();
            }

        }else{

            center = this.structure.center;

            if( zoom ){
                zoom = this.structure.boundingBox.size().length();
            }

        }

        this.viewer.centerView( zoom, center );

        return this;

    },

    getCenter: function(){

        return this.structure.center;

    },

    superpose: function( component, align, sele1, sele2, xsele1, xsele2 ){

        NGL.superpose(
            this.structure, component.structure,
            align, sele1, sele2, xsele1, xsele2
        );


        // FIXME there should be a better way
        if( this.structure !== this.__structure ){

            NGL.superpose(
                this.__structure, component.structure,
                align, sele1, sele2, xsele1, xsele2
            );

        }

        this.updateRepresentations( { "position": true } );

        return this;

    },

    setVisibility: function( value ){

        NGL.Component.prototype.setVisibility.call( this, value );

        this.trajList.forEach( function( traj ){

            // FIXME ???
            traj.setVisibility( value );

        } );

        return this;

    },

} );


NGL.SurfaceComponent = function( stage, surface, params ){

    var p = params || {};
    p.name = p.name !== undefined ? p.name : surface.name;

    NGL.Component.call( this, stage, p );

    this.surface = surface;

};

NGL.SurfaceComponent.prototype = NGL.createObject(

    NGL.Component.prototype, {

    constructor: NGL.SurfaceComponent,

    type: "surface",

    addRepresentation: function( type, params ){

        return NGL.Component.prototype.addRepresentation.call(
            this, type, this.surface, params
        );

    },

    dispose: function(){

        this.surface.dispose();

        NGL.Component.prototype.dispose.call( this );

    },

    centerView: function( zoom ){

        var center = this.surface.center;

        if( zoom ){
            zoom = this.surface.boundingBox.size().length();
        }

        this.viewer.centerView( zoom, center );

    },

} );


NGL.TrajectoryComponent = function( stage, trajectory, params, parent ){

    var p = params || {};
    p.name = p.name !== undefined ? p.name : trajectory.name;

    NGL.Component.call( this, stage, p );

    this.trajectory = trajectory;
    this.parent = parent;
    this.status = "loaded";

    // signals

    trajectory.signals.frameChanged.add( function( i ){

        this.signals.frameChanged.dispatch( i );

    }, this );

    trajectory.signals.playerChanged.add( function( player ){

        this.signals.playerChanged.dispatch( player );

    }, this );

    trajectory.signals.gotNumframes.add( function( n ){

        this.signals.gotNumframes.dispatch( n );

    }, this );

    //

    if( p.i !== undefined ){

        this.setFrame( p.i );

    }

};

NGL.TrajectoryComponent.prototype = NGL.createObject(

    NGL.Component.prototype, {

    constructor: NGL.TrajectoryComponent,

    type: "trajectory",

    signals: Object.assign( {

        frameChanged: null,
        playerChanged: null,
        gotNumframes: null,
        parametersChanged: null

    }, NGL.Component.prototype.signals ),

    addRepresentation: function( type, params ){

        return NGL.Component.prototype.addRepresentation.call(
            this, type, this.trajectory, params
        );

    },

    setFrame: function( i ){

        this.trajectory.setFrame( i );

    },

    setParameters: function( params ){

        this.trajectory.setParameters( params );
        this.signals.parametersChanged.dispatch( params );

        return this;

    },

    dispose: function(){

        this.trajectory.dispose();

        NGL.Component.prototype.dispose.call( this );

    },

    getCenter: function(){}

} );


NGL.ScriptComponent = function( stage, script, params ){

    var p = params || {};
    p.name = p.name !== undefined ? p.name : script.name;

    NGL.Component.call( this, stage, p );

    this.script = script;
    this.status = "loaded";

    this.script.signals.nameChanged.add( function( value ){

        this.setName( value );

    }, this );

};

NGL.ScriptComponent.prototype = NGL.createObject(

    NGL.Component.prototype, {

    constructor: NGL.ScriptComponent,

    type: "script",

    addRepresentation: function( type ){},

    removeRepresentation: function( repr ){},

    run: function(){

        var scope = this;

        this.setStatus( "running" );

        this.script.call( this.stage, function(){

            scope.setStatus( "finished" );

        } );

        this.setStatus( "called" );

    },

    dispose: function(){

        this.signals.disposed.dispatch();

    },

    setVisibility: function( value ){},

    getCenter: function(){}

} );


NGL.RepresentationComponent = function( stage, repr, params, parent ){

    var p = params || {};
    p.name = p.name !== undefined ? p.name : repr.type;

    NGL.Component.call( this, stage, p );

    this.parent = parent;

    this.setRepresentation( repr );

};

NGL.RepresentationComponent.prototype = NGL.createObject(

    NGL.Component.prototype, {

    constructor: NGL.RepresentationComponent,

    type: "representation",

    signals: Object.assign( {

        parametersChanged: null,

    }, NGL.Component.prototype.signals ),

    getType: function(){

        return this.repr.type;

    },

    setRepresentation: function( repr ){

        if( this.repr ){
            this.repr.dispose();
        }

        this.repr = repr;
        // this.name = repr.type;

        this.stage.tasks.listen( this.repr.tasks )

        this.updateVisibility();

    },

    addRepresentation: function( type ){},

    removeRepresentation: function( repr ){},

    dispose: function(){

        if( this.parent ){

            this.parent.removeRepresentation( this );

        }

        this.repr.dispose();

        this.signals.disposed.dispatch();

    },

    setVisibility: function( value ){

        this.visible = value;
        this.updateVisibility();
        this.signals.visibilityChanged.dispatch( this.visible );

        return this;

    },

    updateVisibility: function(){

        if( this.parent ){

            this.repr.setVisibility( this.parent.visible && this.visible );

        }else{

            this.repr.setVisibility( this.visible );

        }

    },

    update: function( what ){

        this.repr.update( what );

        return this;

    },

    build: function( params ){

        this.repr.build( params );

        return this;

    },

    setStructure: function( structure ){

        this.repr.setStructure( structure );

        return this;

    },

    setSelection: function( string ){

        this.repr.setSelection( string );

        return this;

    },

    setParameters: function( params ){

        this.repr.setParameters( params );
        this.signals.parametersChanged.dispatch(
            this.repr.getParameters()
        );

        return this;

    },

    getParameters: function(){

        return this.repr.getParameters();

    },

    setColor: function( value ){

        this.repr.setColor( value );

        return this;

    },

    getCenter: function(){}

} );


///////////////
// Collection

NGL.Collection = function( list ){

    this.list = list || [];

    // remove elements from list when they get disposed

    var n = this.list.length;

    for( var i = 0; i < n; ++i ){

        var elm = this.list[ i ];

        elm.signals.disposed.add( function(){

            this._remove( elm );

        }, this );

    }

};

NGL.Collection.prototype = {

    constructor: NGL.Collection,

    _remove: function( elm ){

        var idx = this.list.indexOf( elm );

        if( idx !== -1 ){

            this.list.splice( idx, 1 );

        }

    },

    _invoke: function( methodName, methodArgs ){

        var n = this.list.length;

        for( var i = 0; i < n; ++i ){

            var elm = this.list[ i ];
            var method = elm[ methodName ];

            if( typeof method === "function" ){

                method.apply( elm, methodArgs );

            }

        }

        return this;

    },

    setVisibility: function( value ){

        return this._invoke( "setVisibility", [ value ] );

    },

    setSelection: function( string ){

        return this._invoke( "setSelection", [ string ] );

    },

    requestGuiVisibility: function( value ){

        return this._invoke( "requestGuiVisibility", [ value ] );

    },

    dispose: function(){

        return this._invoke( "dispose" );

    }

};


NGL.ComponentCollection = function( compList ){

    NGL.Collection.call( this, compList );

};

NGL.ComponentCollection.prototype = NGL.createObject(

    NGL.Collection.prototype, {

    constructor: NGL.ComponentCollection,

    addRepresentation: function( name, params ){

        return this._invoke( "addRepresentation", [ name, params ] );

    },

    centerView: function( zoom, sele ){

        return this._invoke( "centerView", [ zoom, sele ] );

    }

} );


NGL.RepresentationCollection = function( reprList ){

    NGL.Collection.call( this, reprList );

};

NGL.RepresentationCollection.prototype = NGL.createObject(

    NGL.Collection.prototype, {

    constructor: NGL.RepresentationCollection,

    setParameters: function( params ){

        return this._invoke( "setParameters", [ params ] );

    },

    setColor: function( color ){

        return this._invoke( "setColor", [ color ] );

    }

} );

// File:shader/CylinderImpostor.vert

NGL.Resources[ 'shader/CylinderImpostor.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\n\n// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.\n\n//  All Rights Reserved\n\n//  Permission to use, copy, modify, distribute, and distribute modified\n//  versions of this software and its built-in documentation for any\n//  purpose and without fee is hereby granted, provided that the above\n//  copyright notice appears in all copies and that both the copyright\n//  notice and this permission notice appear in supporting documentation,\n//  and that the name of Schrodinger, LLC not be used in advertising or\n//  publicity pertaining to distribution of the software without specific,\n//  written prior permission.\n\n//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN\n//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n//  USE OR PERFORMANCE OF THIS SOFTWARE.\n\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - dual color\n// - picking color\n// - shift\n\nattribute vec3 mapping;\nattribute vec3 position1;\nattribute vec3 position2;\nattribute float radius;\n\nvarying vec3 axis;\nvarying vec4 base_radius;\nvarying vec4 end_b;\nvarying vec3 U;\nvarying vec3 V;\nvarying vec4 w;\n\n#ifdef PICKING\n    attribute vec3 pickingColor;\n    attribute vec3 pickingColor2;\n    varying vec3 vPickingColor;\n    varying vec3 vPickingColor2;\n#else\n    attribute vec3 color;\n    attribute vec3 color2;\n    varying vec3 vColor;\n    varying vec3 vColor2;\n#endif\n\nuniform mat4 modelViewMatrixInverse;\nuniform float shift;\n\n\nvoid main()\n{\n\n    #ifdef PICKING\n        vPickingColor = pickingColor;\n        vPickingColor2 = pickingColor2;\n    #else\n        vColor = color;\n        vColor2 = color2;\n    #endif\n\n    // vRadius = radius;\n    base_radius.w = radius;\n\n    vec3 center = position;\n    vec3 dir = normalize( position2 - position1 );\n    float ext = length( position2 - position1 ) / 2.0;\n\n    vec3 cam_dir = normalize(\n        ( modelViewMatrixInverse * vec4( 0, 0, 0, 1 ) ).xyz - center\n    );\n\n    vec3 ldir;\n\n    float b = dot( cam_dir, dir );\n    end_b.w = b;\n    if( b < 0.0 ) // direction vector looks away, so flip\n        ldir = -ext * dir;\n    else // direction vector already looks in my direction\n        ldir = ext * dir;\n\n    vec3 left = normalize( cross( cam_dir, ldir ) );\n    vec3 leftShift = shift * left * radius;\n    if( b < 0.0 )\n        leftShift *= -1.0;\n    left = radius * left;\n    vec3 up = radius * normalize( cross( left, ldir ) );\n\n    // transform to modelview coordinates\n    axis = normalize( normalMatrix * ldir );\n    U = normalize( normalMatrix * up );\n    V = normalize( normalMatrix * left );\n\n    vec4 base4 = modelViewMatrix * vec4( center - ldir + leftShift, 1.0 );\n    base_radius.xyz = base4.xyz / base4.w;\n\n    vec4 top_position = modelViewMatrix * vec4( center + ldir + leftShift, 1.0 );\n    vec4 end4 = top_position;\n    end_b.xyz = end4.xyz / end4.w;\n\n    w = modelViewMatrix * vec4(\n        center + leftShift + mapping.x*ldir + mapping.y*left + mapping.z*up, 1.0\n    );\n\n    gl_Position = projectionMatrix * w;\n\n    // avoid clipping\n    gl_Position.z = 1.0;\n\n}\n\n\n";

// File:shader/CylinderImpostor.frag

NGL.Resources[ 'shader/CylinderImpostor.frag' ] = "\n#extension GL_EXT_frag_depth : enable\n\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\n// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.\n\n//  All Rights Reserved\n\n//  Permission to use, copy, modify, distribute, and distribute modified\n//  versions of this software and its built-in documentation for any\n//  purpose and without fee is hereby granted, provided that the above\n//  copyright notice appears in all copies and that both the copyright\n//  notice and this permission notice appear in supporting documentation,\n//  and that the name of Schrodinger, LLC not be used in advertising or\n//  publicity pertaining to distribution of the software without specific,\n//  written prior permission.\n\n//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN\n//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n//  USE OR PERFORMANCE OF THIS SOFTWARE.\n\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - dual color\n// - picking color\n\nuniform float opacity;\nuniform float nearClip;\n\nuniform mat4 projectionMatrix;\n// uniform mat3 normalMatrix;\n\nvarying vec3 axis;\nvarying vec4 base_radius;\nvarying vec4 end_b;\nvarying vec3 U;\nvarying vec3 V;\nvarying vec4 w;\n\n#ifdef PICKING\n    uniform float objectId;\n    varying vec3 vPickingColor;\n    varying vec3 vPickingColor2;\n#else\n    varying vec3 vColor;\n    varying vec3 vColor2;\n#endif\n\n#include light_params\n\n#include fog_params\n\n\nfloat distSq3( vec3 v3a, vec3 v3b ){\n\n    return (\n        ( v3a.x - v3b.x ) * ( v3a.x - v3b.x ) +\n        ( v3a.y - v3b.y ) * ( v3a.y - v3b.y ) +\n        ( v3a.z - v3b.z ) * ( v3a.z - v3b.z )\n    );\n\n}\n\n\n// round caps\n// http://sourceforge.net/p/pymol/code/HEAD/tree/trunk/pymol/data/shaders/cylinder.fs\n\n\n// void main2(void)\n// {\n//     #ifdef PICKING\n//         gl_FragColor = vec4( vPickingColor, 1.0 );\n//     #else\n//         gl_FragColor = vec4( vColor, 1.0 );\n//     #endif\n// }\n\n// Calculate depth based on the given camera position.\nfloat calcDepth( in vec3 cameraPos )\n{\n    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;\n    return 0.5 + 0.5 * clipZW.x / clipZW.y;\n}\n\n\nfloat calcClip( vec3 cameraPos )\n{\n    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );\n}\n\n\nvoid main()\n{\n    vec3 point = w.xyz / w.w;\n\n    // unpacking\n    vec3 base = base_radius.xyz;\n    float vRadius = base_radius.w;\n    vec3 end = end_b.xyz;\n    float b = end_b.w;\n\n    vec3 end_cyl = end;\n    vec3 surface_point = point;\n\n    const float ortho=0.0;\n\n    vec3 ray_target = surface_point;\n    vec3 ray_origin = vec3(0.0);\n    vec3 ray_direction = mix(normalize(ray_origin - ray_target), vec3(0.0, 0.0, 1.0), ortho);\n    mat3 basis = mat3( U, V, axis );\n\n    vec3 diff = ray_target - 0.5 * (base + end_cyl);\n    vec3 P = diff * basis;\n\n    // angle (cos) between cylinder cylinder_axis and ray direction\n    float dz = dot( axis, ray_direction );\n\n    float radius2 = vRadius*vRadius;\n\n    // calculate distance to the cylinder from ray origin\n    vec3 D = vec3(dot(U, ray_direction),\n                dot(V, ray_direction),\n                dz);\n    float a0 = P.x*P.x + P.y*P.y - radius2;\n    float a1 = P.x*D.x + P.y*D.y;\n    float a2 = D.x*D.x + D.y*D.y;\n\n    // calculate a dicriminant of the above quadratic equation\n    float d = a1*a1 - a0*a2;\n    if (d < 0.0)\n        // outside of the cylinder\n        discard;\n\n    float dist = (-a1 + sqrt(d)) / a2;\n\n    // point of intersection on cylinder surface\n    vec3 new_point = ray_target + dist * ray_direction;\n\n    vec3 tmp_point = new_point - base;\n    vec3 normal = normalize( tmp_point - axis * dot(tmp_point, axis) );\n\n    ray_origin = mix( ray_origin, surface_point, ortho );\n\n    // test front cap\n    float cap_test = dot( new_point - base, axis );\n\n    // to calculate caps, simply check the angle between\n    // the point of intersection - cylinder end vector\n    // and a cap plane normal (which is the cylinder cylinder_axis)\n    // if the angle < 0, the point is outside of cylinder\n    // test front cap\n\n    #ifndef CAP\n        vec3 new_point2 = ray_target + ( (-a1 - sqrt(d)) / a2 ) * ray_direction;\n        vec3 tmp_point2 = new_point2 - base;\n    #endif\n\n    // flat\n    if (cap_test < 0.0)\n    {\n        // ray-plane intersection\n        float dNV = dot(-axis, ray_direction);\n        if (dNV < 0.0)\n            discard;\n        float near = dot(-axis, (base)) / dNV;\n        new_point = ray_direction * near + ray_origin;\n        // within the cap radius?\n        if (dot(new_point - base, new_point-base) > radius2)\n            discard;\n\n        #ifdef CAP\n            normal = axis;\n        #else\n            normal = -normalize( tmp_point2 - axis * dot(tmp_point2, axis) );\n        #endif\n    }\n\n    // test end cap\n    cap_test = dot((new_point - end_cyl), axis);\n\n    // flat\n    if( cap_test > 0.0 )\n    {\n        // ray-plane intersection\n        float dNV = dot(axis, ray_direction);\n        if (dNV < 0.0)\n            discard;\n        float near = dot(axis, end_cyl) / dNV;\n        new_point = ray_direction * near + ray_origin;\n        // within the cap radius?\n        if( dot(new_point - end_cyl, new_point-base) > radius2 )\n            discard;\n\n        #ifdef CAP\n            normal = axis;\n        #else\n            normal = -normalize( tmp_point2 - axis * dot(tmp_point2, axis) );\n        #endif\n    }\n\n    gl_FragDepthEXT = calcDepth( new_point );\n\n    #ifdef NEAR_CLIP\n        if( calcClip( new_point ) > 0.0 ){\n            dist = (-a1 - sqrt(d)) / a2;\n            new_point = ray_target + dist * ray_direction;\n            if( calcClip( new_point ) > 0.0 )\n                discard;\n            normal = vec3( 0.0, 0.0, 0.4 );\n            gl_FragDepthEXT = calcDepth( new_point );\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / vRadius ) );\n            }\n        }else if( gl_FragDepthEXT <= 0.0 ){\n            dist = (-a1 - sqrt(d)) / a2;\n            new_point = ray_target + dist * ray_direction;\n            normal = vec3( 0.0, 0.0, 0.4 );\n            gl_FragDepthEXT = calcDepth( new_point );\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );\n            }\n        }\n    #else\n        if( gl_FragDepthEXT <= 0.0 ){\n            dist = (-a1 - sqrt(d)) / a2;\n            new_point = ray_target + dist * ray_direction;\n            normal = vec3( 0.0, 0.0, 0.4 );\n            gl_FragDepthEXT = calcDepth( new_point );\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = 0.0 + ( 0.0000001 / vRadius );\n            }\n        }\n    #endif\n\n    // this is a workaround necessary for Mac\n    // otherwise the modified fragment won't clip properly\n    if (gl_FragDepthEXT < 0.0)\n        discard;\n    if (gl_FragDepthEXT > 1.0)\n        discard;\n\n\n    vec3 transformedNormal = normal;\n    vec3 vLightFront = vec3( 0.0, 0.0, 0.0 );\n\n    #include light\n\n    #ifdef PICKING\n        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){\n            if( b < 0.0 ){\n                gl_FragColor = vec4( vPickingColor, objectId );\n            }else{\n                gl_FragColor = vec4( vPickingColor2, objectId );\n            }\n        }else{\n            if( b > 0.0 ){\n                gl_FragColor = vec4( vPickingColor, objectId );\n            }else{\n                gl_FragColor = vec4( vPickingColor2, objectId );\n            }\n        }\n    #else\n        if( distSq3( new_point, end_cyl ) < distSq3( new_point, base ) ){\n            if( b < 0.0 ){\n                gl_FragColor = vec4( vColor, opacity );\n            }else{\n                gl_FragColor = vec4( vColor2, opacity );\n            }\n        }else{\n            if( b > 0.0 ){\n                gl_FragColor = vec4( vColor, opacity );\n            }else{\n                gl_FragColor = vec4( vColor2, opacity );\n            }\n        }\n        gl_FragColor.rgb *= vLightFront;\n        //gl_FragColor.rgb = transformedNormal;\n    #endif\n\n    // #include fog\n\n    #ifdef USE_FOG\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n        #ifdef FOG_EXP2\n            const float LOG2 = 1.442695;\n            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n        #else\n            float fogFactor = smoothstep( fogNear, fogFar, depth );\n        #endif\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    #endif\n}\n\n\n\n\n\n\n\n\n";

// File:shader/HyperballStickImpostor.vert

NGL.Resources[ 'shader/HyperballStickImpostor.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\n// uniform mat4 modelViewMatrix;\n// uniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\n\n// Copyright (C) 2010-2011 by\n// Laboratoire de Biochimie Theorique (CNRS),\n// Laboratoire d'Informatique Fondamentale d'Orleans (Universite d'Orleans), (INRIA) and\n// Departement des Sciences de la Simulation et de l'Information (CEA).\n\n// License: CeCILL-C license (http://www.cecill.info/)\n\n// Contact: Marc Baaden\n// E-mail: baaden@smplinux.de\n// Webpage: http://hyperballs.sourceforge.net\n\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - dual color\n// - picking color\n\nattribute vec3 mapping;\nattribute float radius;\nattribute float radius2;\nattribute vec3 position1;\nattribute vec3 position2;\n\nvarying mat4 matrix_near;\nvarying vec4 prime1;\nvarying vec4 prime2;\nvarying float vRadius;\nvarying float vRadius2;\n\n#ifdef PICKING\n    attribute vec3 pickingColor;\n    attribute vec3 pickingColor2;\n    varying vec3 vPickingColor;\n    varying vec3 vPickingColor2;\n#else\n    attribute vec3 color;\n    attribute vec3 color2;\n    varying vec3 vColor;\n    varying vec3 vColor2;\n#endif\n\nuniform float shrink;\nuniform mat4 modelViewProjectionMatrix;\nuniform mat4 modelViewProjectionMatrixInverse;\n\n\nvoid main()\n{\n\n    vRadius = radius;\n    vRadius2 = radius2;\n\n    vec4 spaceposition;\n    vec3 position_atom1;\n    vec3 position_atom2;\n    vec4 vertex_position;\n\n    #ifdef PICKING\n        vPickingColor = pickingColor;\n        vPickingColor2 = pickingColor2;\n    #else\n        vColor = color;\n        vColor2 = color2;\n    #endif\n\n    float radius1 = radius;\n\n    position_atom1 = position1;\n    position_atom2 = position2;\n\n    float distance = distance( position_atom1, position_atom2 );\n\n    spaceposition.z = mapping.z * distance;\n\n    if (radius1 > radius2) {\n        spaceposition.y = mapping.y * 1.5 * radius1;\n        spaceposition.x = mapping.x * 1.5 * radius1;\n    } else {\n        spaceposition.y = mapping.y * 1.5 * radius2;\n        spaceposition.x = mapping.x * 1.5 * radius2;\n    }\n    spaceposition.w = 1.0;\n\n    vec4 e3 = vec4( 1.0 );\n    vec3 e1, e1_temp, e2, e2_temp;\n\n    // Calculation of bond direction: e3\n    e3.xyz = normalize(position_atom1-position_atom2);\n\n    // little hack to avoid some problems of precision due to graphic card limitation using float: To improve soon\n    if (e3.z == 0.0) { e3.z = 0.0000000000001;}\n    if ( (position_atom1.x - position_atom2.x) == 0.0) { position_atom1.x += 0.001;}\n    if ( (position_atom1.y - position_atom2.y) == 0.0) { position_atom1.y += 0.001;}\n    if ( (position_atom1.z - position_atom2.z) == 0.0) { position_atom1.z += 0.001;}\n\n    // Focus calculation\n    vec4 focus = vec4( 1.0 );\n    focus.x = ( position_atom1.x*position_atom1.x - position_atom2.x*position_atom2.x +\n        ( radius2*radius2 - radius1*radius1 )*e3.x*e3.x/shrink )/(2.0*(position_atom1.x - position_atom2.x));\n    focus.y = ( position_atom1.y*position_atom1.y - position_atom2.y*position_atom2.y +\n        ( radius2*radius2 - radius1*radius1 )*e3.y*e3.y/shrink )/(2.0*(position_atom1.y - position_atom2.y));\n    focus.z = ( position_atom1.z*position_atom1.z - position_atom2.z*position_atom2.z +\n        ( radius2*radius2 - radius1*radius1 )*e3.z*e3.z/shrink )/(2.0*(position_atom1.z - position_atom2.z));\n\n    // e1 calculation\n    e1.x = 1.0;\n    e1.y = 1.0;\n    e1.z = ( (e3.x*focus.x + e3.y*focus.y + e3.z*focus.z) - e1.x*e3.x - e1.y*e3.y)/e3.z;\n    e1_temp = e1 - focus.xyz;\n    e1 = normalize(e1_temp);\n\n    // e2 calculation\n    e2_temp = e1.yzx * e3.zxy - e1.zxy * e3.yzx;\n    e2 = normalize(e2_temp);\n\n    //ROTATION:\n    // final form of change of basis matrix:\n    mat3 R= mat3( e1.xyz, e2.xyz, e3.xyz );\n    // Apply rotation and translation to the bond primitive\n    vertex_position.xyz = R * spaceposition.xyz;\n    vertex_position.w = 1.0;\n\n    // TRANSLATION:\n    vertex_position.x += (position_atom1.x+position_atom2.x) / 2.0;\n    vertex_position.y += (position_atom1.y+position_atom2.y) / 2.0;\n    vertex_position.z += (position_atom1.z+position_atom2.z) / 2.0;\n\n    // New position\n    gl_Position = modelViewProjectionMatrix * vertex_position;\n\n    vec4 i_near, i_far;\n\n    // Calculate near from position\n    vec4 near = gl_Position;\n    near.z = 0.0 ;\n    near = modelViewProjectionMatrixInverse * near;\n    i_near = near;\n\n    // Calculate far from position\n    vec4 far = gl_Position;\n    far.z = far.w ;\n    i_far = modelViewProjectionMatrixInverse * far;\n\n    prime1 = vec4( position_atom1 - (position_atom1 - focus.xyz)*shrink, 1.0 );\n    prime2 = vec4( position_atom2 - (position_atom2 - focus.xyz)*shrink, 1.0 );\n\n    float Rsquare = (radius1*radius1/shrink) - (\n                        (position_atom1.x - focus.x)*(position_atom1.x - focus.x) +\n                        (position_atom1.y - focus.y)*(position_atom1.y - focus.y) +\n                        (position_atom1.z - focus.z)*(position_atom1.z - focus.z)\n                    );\n\n    focus.w = Rsquare;\n\n    matrix_near = mat4( i_near, i_far, focus, e3 );\n\n    // avoid clipping\n    gl_Position.z = 1.0;\n\n}\n\n";

// File:shader/HyperballStickImpostor.frag

NGL.Resources[ 'shader/HyperballStickImpostor.frag' ] = "\n#extension GL_EXT_frag_depth : enable\n\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\n// Copyright (C) 2010-2011 by\n// Laboratoire de Biochimie Theorique (CNRS),\n// Laboratoire d'Informatique Fondamentale d'Orleans (Universite d'Orleans), (INRIA) and\n// Departement des Sciences de la Simulation et de l'Information (CEA).\n\n// License: CeCILL-C license (http://www.cecill.info/)\n\n// Contact: Marc Baaden\n// E-mail: baaden@smplinux.de\n// Webpage: http://hyperballs.sourceforge.net\n\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - dual color\n// - picking color\n\n\nvarying mat4 matrix_near;\nvarying vec4 prime1;\nvarying vec4 prime2;\nvarying float vRadius;\nvarying float vRadius2;\n\nuniform float opacity;\nuniform float nearClip;\nuniform float shrink;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelViewProjectionMatrix;\nuniform mat4 modelViewMatrixInverseTranspose;\nuniform mat4 projectionMatrix;\n\n#ifdef PICKING\n    uniform float objectId;\n    varying vec3 vPickingColor;\n    varying vec3 vPickingColor2;\n#else\n    varying vec3 vColor;\n    varying vec3 vColor2;\n#endif\n\n#include light_params\n\n#include fog_params\n\n\nfloat calcClip( vec4 cameraPos )\n{\n    return dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );\n}\nfloat calcClip( vec3 cameraPos )\n{\n    return calcClip( vec4( cameraPos, 1.0 ) );\n}\n\n\nfloat calcDepth( in vec3 cameraPos )\n{\n    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;\n    return 0.5 + 0.5 * clipZW.x / clipZW.y;\n}\n\n\nstruct Ray {\n    vec3 origin ;\n    vec3 direction ;\n};\n\n\nbool cutoff_plane (vec3 M, vec3 cutoff, vec3 x3){\n    float a = x3.x;\n    float b = x3.y;\n    float c = x3.z;\n    float d = -x3.x*cutoff.x-x3.y*cutoff.y-x3.z*cutoff.z;\n    float l = a*M.x+b*M.y+c*M.z+d;\n    if (l<0.0) {return true;}\n    else{return false;}\n}\n\n\nvec3 isect_surf(Ray r, mat4 matrix_coef){\n    vec4 direction = vec4(r.direction, 0.0);\n    vec4 origin = vec4(r.origin, 1.0);\n    float a = dot(direction,(matrix_coef*direction));\n    float b = dot(origin,(matrix_coef*direction));\n    float c = dot(origin,(matrix_coef*origin));\n    float delta =b*b-a*c;\n    gl_FragColor.a = 1.0;\n    if (delta<0.0){\n        discard;\n        // gl_FragColor.a = 0.5;\n    }\n    float t1 =(-b-sqrt(delta))/a;\n\n    // Second solution not necessary if you don't want\n    // to see inside spheres and cylinders, save some fps\n    //float t2 = (-b+sqrt(delta)) / a  ;\n    //float t =(t1<t2) ? t1 : t2;\n\n    return r.origin+t1*r.direction;\n}\n\n\nvec3 isect_surf2(Ray r, mat4 matrix_coef){\n    vec4 direction = vec4(r.direction, 0.0);\n    vec4 origin = vec4(r.origin, 1.0);\n    float a = dot(direction,(matrix_coef*direction));\n    float b = dot(origin,(matrix_coef*direction));\n    float c = dot(origin,(matrix_coef*origin));\n    float delta =b*b-a*c;\n    gl_FragColor.a = 1.0;\n    if (delta<0.0){\n        discard;\n        // gl_FragColor.a = 0.5;\n    }\n    float t2 =(-b+sqrt(delta))/a;\n\n    return r.origin+t2*r.direction;\n}\n\n\nRay primary_ray(vec4 near1, vec4 far1){\n    vec3 near=near1.xyz/near1.w;\n    vec3 far=far1.xyz/far1.w;\n    return Ray(near,far-near);\n}\n\n\nfloat update_z_buffer(vec3 M, mat4 ModelViewP){\n    float  depth1;\n    vec4 Ms=(ModelViewP*vec4(M,1.0));\n    return depth1=(1.0+Ms.z/Ms.w)/2.0;\n}\n\n\n// void main2(void)\n// {\n//     gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n// }\n\n// void main(void)\n// {\n//     #ifdef PICKING\n//         gl_FragColor = vec4( vPickingColor, 1.0 );\n//     #else\n//         gl_FragColor = vec4( vColor, 1.0 );\n//     #endif\n// }\n\n\nvoid main()\n{\n\n    float radius = max( vRadius, vRadius2 );\n\n    vec4 i_near, i_far, focus;\n    vec3 e3, e1, e1_temp, e2;\n\n    i_near = vec4(matrix_near[0][0],matrix_near[0][1],matrix_near[0][2],matrix_near[0][3]);\n    i_far  = vec4(matrix_near[1][0],matrix_near[1][1],matrix_near[1][2],matrix_near[1][3]);\n    focus = vec4(matrix_near[2][0],matrix_near[2][1],matrix_near[2][2],matrix_near[2][3]);\n    e3 = vec3(matrix_near[3][0],matrix_near[3][1],matrix_near[3][2]);\n\n    e1.x = 1.0;\n    e1.y = 1.0;\n    e1.z = ( (e3.x*focus.x + e3.y*focus.y + e3.z*focus.z) - e1.x*e3.x - e1.y*e3.y)/e3.z;\n    e1_temp = e1 - focus.xyz;\n    e1 = normalize(e1_temp);\n\n    e2 = normalize(cross(e1,e3));\n\n\n    vec4 equation = focus;\n\n    float shrinkfactor = shrink;\n    float t1 = -1.0/(1.0-shrinkfactor);\n    float t2 = 1.0/(shrinkfactor);\n    // float t3 = 2.0/(shrinkfactor);\n\n    vec4 colonne1, colonne2, colonne3, colonne4;\n    mat4 mat;\n\n    vec3 equation1 = vec3(t2,t2,t1);\n\n\n    float A1 = - e1.x*equation.x - e1.y*equation.y - e1.z*equation.z;\n    float A2 = - e2.x*equation.x - e2.y*equation.y - e2.z*equation.z;\n    float A3 = - e3.x*equation.x - e3.y*equation.y - e3.z*equation.z;\n\n    float A11 = equation1.x*e1.x*e1.x +  equation1.y*e2.x*e2.x + equation1.z*e3.x*e3.x;\n    float A21 = equation1.x*e1.x*e1.y +  equation1.y*e2.x*e2.y + equation1.z*e3.x*e3.y;\n    float A31 = equation1.x*e1.x*e1.z +  equation1.y*e2.x*e2.z + equation1.z*e3.x*e3.z;\n    float A41 = equation1.x*e1.x*A1   +  equation1.y*e2.x*A2   + equation1.z*e3.x*A3;\n\n    float A22 = equation1.x*e1.y*e1.y +  equation1.y*e2.y*e2.y + equation1.z*e3.y*e3.y;\n    float A32 = equation1.x*e1.y*e1.z +  equation1.y*e2.y*e2.z + equation1.z*e3.y*e3.z;\n    float A42 = equation1.x*e1.y*A1   +  equation1.y*e2.y*A2   + equation1.z*e3.y*A3;\n\n    float A33 = equation1.x*e1.z*e1.z +  equation1.y*e2.z*e2.z + equation1.z*e3.z*e3.z;\n    float A43 = equation1.x*e1.z*A1   +  equation1.y*e2.z*A2   + equation1.z*e3.z*A3;\n\n    float A44 = equation1.x*A1*A1 +  equation1.y*A2*A2 + equation1.z*A3*A3 - equation.w;\n\n    colonne1 = vec4(A11,A21,A31,A41);\n    colonne2 = vec4(A21,A22,A32,A42);\n    colonne3 = vec4(A31,A32,A33,A43);\n    colonne4 = vec4(A41,A42,A43,A44);\n\n    mat = mat4(colonne1,colonne2,colonne3,colonne4);\n\n\n\n    // Ray calculation using near and far\n    Ray ray = primary_ray(i_near,i_far) ;\n\n    // Intersection between ray and surface for each pixel\n    vec3 M;\n    M = isect_surf(ray, mat);\n\n    // cut the extremities of bonds to superimpose bond and spheres surfaces\n    if (cutoff_plane(M, prime1.xyz, -e3) || cutoff_plane(M, prime2.xyz, e3)){ discard; }\n\n    // Transform normal to model space to view-space\n    vec4 M1 = vec4(M,1.0);\n    vec4 M2 =  mat*M1;\n    vec3 normal = normalize( ( modelViewMatrixInverseTranspose * M2 ).xyz );\n\n    // Recalculate the depth in function of the new pixel position\n    gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;\n\n    #ifdef NEAR_CLIP\n        if( calcClip( modelViewMatrix * vec4( M, 1.0 ) ) > 0.0 ){\n            M = isect_surf2(ray, mat);\n            if( calcClip( modelViewMatrix * vec4( M, 1.0 ) ) > 0.0 )\n                discard;\n            normal = vec3( 0.0, 0.0, 0.4 );\n            gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / radius ) );\n            }\n        }else if( gl_FragDepthEXT <= 0.0 ){\n            M = isect_surf2(ray, mat);\n            normal = vec3( 0.0, 0.0, 0.4 );\n            gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix);\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = 0.0 + ( 0.0000001 / radius );\n            }\n        }\n    #else\n        if( gl_FragDepthEXT <= 0.0 ){\n            M = isect_surf2(ray, mat);\n            normal = vec3( 0.0, 0.0, 0.4 );\n            gl_FragDepthEXT = update_z_buffer(M, modelViewProjectionMatrix) ;\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = 0.0 + ( 0.0000001 / radius );\n            }\n        }\n    #endif\n\n    // cut the extremities of bonds to superimpose bond and spheres surfaces\n    if (cutoff_plane(M, prime1.xyz, -e3) || cutoff_plane(M, prime2.xyz, e3)){ discard; }\n\n    if (gl_FragDepthEXT < 0.0)\n        discard;\n    if (gl_FragDepthEXT > 1.0)\n        discard;\n\n    // Give color parameters to the Graphic card\n    //gl_FragColor.rgb = lighting.y * diffusecolor + lighting.z * specularcolor;\n    //gl_FragColor.a = 1.0;\n\n    vec3 transformedNormal = normal;\n    vec3 vLightFront = vec3( 0.0, 0.0, 0.0 );\n\n    #include light\n\n    // Mix the color bond in function of the two atom colors\n    float distance_ratio = ((M.x-prime2.x)*e3.x + (M.y-prime2.y)*e3.y +(M.z-prime2.z)*e3.z) /\n                                distance(prime2.xyz,prime1.xyz);\n\n    #ifdef PICKING\n        // lerp function not in GLSL. Find something else ...\n        vec3 diffusecolor = mix( vPickingColor2, vPickingColor, distance_ratio );\n        if( distance_ratio>0.5 ){\n            diffusecolor = vPickingColor;\n        }else{\n            diffusecolor = vPickingColor2;\n        }\n        gl_FragColor = vec4( diffusecolor, objectId );\n    #else\n        // lerp function not in GLSL. Find something else ...\n        vec3 diffusecolor = mix( vColor2, vColor, distance_ratio );\n        if( distance_ratio>0.5 ){\n            diffusecolor = vColor;\n        }else{\n            diffusecolor = vColor2;\n        }\n        gl_FragColor = vec4( diffusecolor, opacity );\n        gl_FragColor.rgb *= vLightFront;\n    #endif\n\n    // #include fog\n\n    #ifdef USE_FOG\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n        #ifdef FOG_EXP2\n            const float LOG2 = 1.442695;\n            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n        #else\n            float fogFactor = smoothstep( fogNear, fogFar, depth );\n        #endif\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    #endif\n\n    // ############## Fog effect #####################################################\n    // To use fog comment the two previous lines: ie  gl_FragColor.rgb = E and   gl_FragColor.a = 1.0;\n    // and uncomment the next lines.\n    // Color of the fog: white\n    //float fogDistance  = update_z_buffer(M, gl_ModelViewMatrix) ;\n    //float fogExponent  = fogDistance * fogDistance * 0.007;\n    //vec3 fogColor   = vec3(1.0, 1.0, 1.0);\n    //float fogFactor   = exp2(-abs(fogExponent));\n    //fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    //vec3 final_color = lighting.y * diffusecolor + lighting.z * specularcolor;\n    //gl_FragColor.rgb = mix(fogColor,final_color,fogFactor);\n    //gl_FragColor.a = 1.0;\n    // ##################################################################################\n\n}\n";

// File:shader/Line.vert

NGL.Resources[ 'shader/Line.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvarying vec4 cameraPos;\n\n\nvoid main()\n{\n\n    vColor = color;\n\n    cameraPos =  modelViewMatrix * vec4( position, 1.0 );\n\n    gl_Position = projectionMatrix * vec4( cameraPos.xyz, 1.0 );\n\n}\n";

// File:shader/Line.frag

NGL.Resources[ 'shader/Line.frag' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nuniform float opacity;\nuniform float nearClip;\n\nvarying vec3 vColor;\nvarying vec4 cameraPos;\n\n#ifdef PICKING\n    uniform float objectId;\n#endif\n\n#include fog_params\n\n\nvoid main()\n{\n\n	#ifdef NEAR_CLIP\n		if( dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip ) ) > 0.0 )\n        	discard;\n    #endif\n\n    gl_FragColor = vec4( vColor, opacity );\n\n    #include fog\n\n}\n";

// File:shader/LineSprite.vert

NGL.Resources[ 'shader/LineSprite.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n// Open-Source PyMOL is Copyright (C) Schrodinger, LLC.\n\n//  All Rights Reserved\n\n//  Permission to use, copy, modify, distribute, and distribute modified\n//  versions of this software and its built-in documentation for any\n//  purpose and without fee is hereby granted, provided that the above\n//  copyright notice appears in all copies and that both the copyright\n//  notice and this permission notice appear in supporting documentation,\n//  and that the name of Schrodinger, LLC not be used in advertising or\n//  publicity pertaining to distribution of the software without specific,\n//  written prior permission.\n\n//  SCHRODINGER, LLC DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n//  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN\n//  NO EVENT SHALL SCHRODINGER, LLC BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n//  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n//  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n//  OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\n//  USE OR PERFORMANCE OF THIS SOFTWARE.\n\n// Note: here the box screen aligned code from Open-Source PyMOL is used\n\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - dual color\n// - adapted for line sprites\n\nattribute vec3 position;\nattribute lowp vec2 inputMapping;\nattribute lowp vec3 inputColor;\nattribute lowp vec3 inputColor2;\nattribute lowp vec3 inputAxis;\nattribute lowp float inputWidth;\n\nvarying float dist;\nvarying lowp vec3 color;\nvarying lowp vec3 color2;\n\n\n// void main2(void){\n//     colorx = inputColor;\n\n//     vec2 B;\n//     vec3 C;\n//     if (inputAxis.y != 0.0 || inputAxis.z != 0.0){\n//         C = vec3(1.0, 0.0, 0.0);\n//     }else{\n//         C = vec3(0.0, 1.0, 0.0);\n//     }\n//     B = normalize(cross(inputAxis, C).xy);\n\n//     vec4 cameraCornerPos = modelViewMatrix * vec4( position, 1.0 );\n//     cameraCornerPos.xy += inputMapping * (B.xy * inputWidth);\n\n//     gl_Position = projectionMatrix * cameraCornerPos;\n// }\n\n\nvoid main(void){\n    mat4 MVMatrix = modelViewMatrix;\n    mat4 PMatrix = projectionMatrix;\n    vec4 EyePoint = vec4( cameraPosition, 1.0 );\n\n    vec3 center = position.xyz;\n    vec3 dir = normalize(inputAxis);\n    // float ext = inputCylinderHeight/2.0;\n    vec3 ldir;\n\n    vec3 cam_dir = normalize(EyePoint.xyz - center);\n    float b = dot(cam_dir, dir);\n    if(b<0.0) // direction vector looks away, so flip\n        //ldir = -ext*dir;\n        ldir = -(length(inputAxis)/2.0) * normalize(inputAxis);\n    else // direction vector already looks in my direction\n        //ldir = ext*dir;\n        ldir = (length(inputAxis)/2.0) * normalize(inputAxis);\n\n    vec3 left = cross(cam_dir, ldir);\n    vec3 up = cross(left, ldir);\n    left = inputWidth*normalize(left);\n    up = inputWidth*normalize(up);\n\n    vec4 w = MVMatrix * vec4(\n        center + inputMapping.x*ldir + inputMapping.y*left, 1.0\n    );\n\n    gl_Position = PMatrix * w;\n\n\n    vec4 base4 = MVMatrix * vec4(center-ldir, 1.0);\n    vec3 base = base4.xyz / base4.w;\n\n    vec4 top_position = MVMatrix*(vec4(center+ldir,1.0));\n    vec4 end4 = top_position;\n    vec3 end = end4.xyz / end4.w;\n\n    vec3 point = w.xyz / w.w;\n\n    color = inputColor;\n    color2 = inputColor2;\n\n    // TODO compare without sqrt\n    if( distance( point, end ) < distance( point, base ) ){\n        dist = b > 0.0 ? 1.0 : 0.0;\n    }else{\n        dist = b < 0.0 ? 1.0 : 0.0;\n    }\n\n}";

// File:shader/LineSprite.frag

NGL.Resources[ 'shader/LineSprite.frag' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nvarying float dist;\nvarying highp vec3 color;\nvarying highp vec3 color2;\n\n#include fog_params\n\n\nvoid main() {\n\n    if( dist > 0.5 ){\n        gl_FragColor = vec4( color, 1.0 );\n    }else{\n        gl_FragColor = vec4( color2, 1.0 );\n    }\n\n    #include fog\n}\n";

// File:shader/Mesh.vert

NGL.Resources[ 'shader/Mesh.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\n\nvarying vec4 cameraPos;\n\n#ifdef PICKING\n    attribute vec3 pickingColor;\n    varying vec3 vPickingColor;\n#else\n    attribute vec3 color;\n    attribute vec3 normal;\n    varying vec3 vColor;\n    varying vec3 vNormal;\n#endif\n\nvoid main()\n{\n\n    #ifdef PICKING\n        vPickingColor = pickingColor;\n    #else\n        vColor = color;\n        vNormal = normalize( normalMatrix * normal );\n    #endif\n\n    cameraPos = modelViewMatrix * vec4( position, 1.0 );\n\n    gl_Position = projectionMatrix * vec4( cameraPos.xyz, 1.0 );\n\n}\n";

// File:shader/Mesh.frag

NGL.Resources[ 'shader/Mesh.frag' ] = "\n#ifdef FLAT_SHADED\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nuniform float opacity;\nuniform float nearClip;\n\nvarying vec4 cameraPos;\n\n#ifdef PICKING\n    uniform float objectId;\n    varying vec3 vPickingColor;\n#else\n    varying vec3 vColor;\n    varying vec3 vNormal;\n#endif\n\n#include light_params\n\n#include fog_params\n\nvoid main()\n{\n\n    #ifdef NEAR_CLIP\n        if( dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip ) ) > 0.0 )\n            discard;\n    #endif\n\n    #ifdef PICKING\n\n        gl_FragColor = vec4( vPickingColor, objectId );\n\n    #else\n\n        #ifdef FLAT_SHADED\n            vec3 fdx = dFdx( cameraPos.xyz );\n            vec3 fdy = dFdy( cameraPos.xyz );\n            vec3 normal = normalize( cross( fdx, fdy ) );\n        #else\n            vec3 normal = normalize( vNormal );\n        #endif\n\n        vec3 transformedNormal = normalize( normal );\n        #ifndef FLAT_SHADED\n            #ifdef DOUBLE_SIDED\n                transformedNormal = transformedNormal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n            #endif\n            #ifdef FLIP_SIDED\n                transformedNormal = -transformedNormal;\n            #endif\n        #endif\n\n        #ifdef DULL_INTERIOR\n            if( !gl_FrontFacing ){\n                transformedNormal = vec3( 0.0, 0.0, 0.4 );\n            }\n        #endif\n\n        vec3 vLightFront = vec3( 0.0, 0.0, 0.0 );\n\n        #ifndef NOLIGHT\n            #include light\n        #endif\n\n        #ifdef OPAQUE_BACK\n            #ifdef FLIP_SIDED\n                if( float( gl_FrontFacing ) == 1.0 ){\n                    gl_FragColor = vec4( vColor, 1.0 );\n                }else{\n                    gl_FragColor = vec4( vColor, opacity );\n                }\n            #else\n                if( float( gl_FrontFacing ) == 1.0 ){\n                    gl_FragColor = vec4( vColor, opacity );\n                }else{\n                    gl_FragColor = vec4( vColor, 1.0 );\n                }\n            #endif\n        #else\n            gl_FragColor = vec4( vColor, opacity );\n        #endif\n\n        #ifndef NOLIGHT\n            gl_FragColor.rgb *= vLightFront;\n        #endif\n\n    #endif\n\n    #include fog\n\n}\n";

// File:shader/ParticleSprite.vert

NGL.Resources[ 'shader/ParticleSprite.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\n// uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec2 mapping;\nattribute vec3 color;\nattribute float radius;\n\nvarying vec3 point;\nvarying vec3 vColor;\nvarying vec3 cameraSpherePos;\nvarying float sphereRadius;\n\nuniform mat4 projectionMatrixInverse;\n\nconst mat4 D = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, -1.0\n);\n\nmat4 transpose( in mat4 inMatrix ) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}\n\n\n//------------------------------------------------------------------------------\n// Compute point size and center using the technique described in:\n// \"GPU-Based Ray-Casting of Quadratic Surfaces\"\n// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.\n//\n// Code based on\n/*=========================================================================\n\n Program:   Visualization Toolkit\n Module:    Quadrics_fs.glsl and Quadrics_vs.glsl\n\n Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n All rights reserved.\n See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n This software is distributed WITHOUT ANY WARRANTY; without even\n the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n PURPOSE.  See the above copyright notice for more information.\n\n =========================================================================*/\n\n// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl\n// .SECTION Thanks\n// <verbatim>\n//\n//  This file is part of the PointSprites plugin developed and contributed by\n//\n//  Copyright (c) CSCS - Swiss National Supercomputing Centre\n//                EDF - Electricite de France\n//\n//  John Biddiscombe, Ugo Varetto (CSCS)\n//  Stephane Ploix (EDF)\n//\n// </verbatim>\n//\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - adapted to work with quads\nvoid ComputePointSizeAndPositionInClipCoordSphere(){\n\n    vec2 xbc;\n    vec2 ybc;\n\n    mat4 T = mat4(\n        sphereRadius, 0.0, 0.0, 0.0,\n        0.0, sphereRadius, 0.0, 0.0,\n        0.0, 0.0, sphereRadius, 0.0,\n        position.x, position.y, position.z, 1.0\n    );\n\n    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );\n    float A = dot( R[ 3 ], D * R[ 3 ] );\n    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );\n    float C = dot( R[ 0 ], D * R[ 0 ] );\n    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;\n\n    A = dot( R[ 3 ], D * R[ 3 ] );\n    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );\n    C = dot( R[ 1 ], D * R[ 1 ] );\n    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;\n\n    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );\n    gl_Position.xy -= mapping * vec2( sx, sy );\n    gl_Position.xy *= gl_Position.w;\n}\n\n\nvoid main(void){\n\n    vColor = color;\n    cameraSpherePos = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;\n    sphereRadius = radius;\n\n    gl_Position = projectionMatrix * vec4( cameraSpherePos, 1.0 );\n    ComputePointSizeAndPositionInClipCoordSphere();\n\n    point = ( projectionMatrixInverse * gl_Position ).xyz;\n\n    // move out of viewing frustum to avoid clipping artifacts\n    if( gl_Position.z-sphereRadius<=1.0 )\n        gl_Position.z = -10.0;\n}\n\n\n\n\n";

// File:shader/ParticleSprite.frag

NGL.Resources[ 'shader/ParticleSprite.frag' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nvarying vec3 point;\nvarying vec3 vColor;\nvarying vec3 cameraSpherePos;\nvarying float sphereRadius;\n\n#include fog_params\n\n\nvoid main() {\n\n    vec3 rayDirection = normalize( point );\n\n    float B = -2.0 * dot(rayDirection, cameraSpherePos);\n    float C = dot(cameraSpherePos, cameraSpherePos) - (sphereRadius*sphereRadius);\n    float det = (B * B) - (4.0 * C);\n    if(det < 0.0)\n        discard;\n\n	gl_FragColor = vec4( vColor, 1.0 );\n\n    #include fog\n\n}\n";

// File:shader/Quad.vert

NGL.Resources[ 'shader/Quad.vert' ] = "\nprecision highp float;\nprecision highp int;\n\nattribute vec2 position;\nattribute vec2 texture;\nvarying vec2 texCoord;\n\nvoid main(void) {\n    texCoord = texture;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n";

// File:shader/Quad.frag

NGL.Resources[ 'shader/Quad.frag' ] = "\nprecision mediump float;\nprecision mediump int;\n\nuniform sampler2D diffuse;\nvarying vec2 texCoord;\n\nvoid main(void) {\n    vec4 color = texture2D(diffuse, texCoord);\n    gl_FragColor = vec4(color.rgb, color.a);\n}\n";

// File:shader/Ribbon.vert

NGL.Resources[ 'shader/Ribbon.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n#ifndef PICKING\n    uniform mat3 normalMatrix;\n#endif\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 dir;\nattribute float size;\nattribute vec3 normal;\n\nvarying vec4 cameraPos;\n\n#ifdef PICKING\n    attribute vec3 pickingColor;\n    varying vec3 vPickingColor;\n#else\n    attribute vec3 color;\n    varying vec3 vColor;\n    varying vec3 vNormal;\n#endif\n\nvoid main(void){\n\n    #ifdef PICKING\n        vPickingColor = pickingColor;\n    #else\n        vColor = color;\n        vNormal = normalize( normalMatrix * normal );\n    #endif\n\n    cameraPos = modelViewMatrix * vec4(\n        position + ( normalize( dir ) * size ), 1.0\n    );\n\n    gl_Position = projectionMatrix * vec4( cameraPos.xyz, 1.0 );\n\n}\n";

// File:shader/Ribbon.frag

NGL.Resources[ 'shader/Ribbon.frag' ] = "\n#ifdef FLAT_SHADED\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nuniform float opacity;\nuniform float nearClip;\n\nvarying vec4 cameraPos;\n\n#ifdef PICKING\n    uniform float objectId;\n    varying vec3 vPickingColor;\n#else\n    varying vec3 vColor;\n    varying vec3 vNormal;\n#endif\n\n#include light_params\n\n#include fog_params\n\n\nvoid main() {\n\n    #ifdef NEAR_CLIP\n        if( dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip ) ) > 0.0 )\n            discard;\n    #endif\n\n    #ifdef PICKING\n        gl_FragColor = vec4( vPickingColor, objectId );\n        //gl_FragColor.rgb = vec3( 1.0, 0.0, 0.0 );\n    #else\n\n        #ifdef FLAT_SHADED\n            vec3 fdx = dFdx( cameraPos.xyz );\n            vec3 fdy = dFdy( cameraPos.xyz );\n            vec3 normal = cross( fdx, fdy );\n        #else\n            vec3 normal = vNormal;\n        #endif\n\n        vec3 transformedNormal = normalize( normal );\n        #ifndef FLAT_SHADED\n            #ifdef DOUBLE_SIDED\n                transformedNormal = transformedNormal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n            #endif\n            #ifdef FLIP_SIDED\n                transformedNormal = -transformedNormal;\n            #endif\n        #endif\n\n        vec3 vLightFront = vec3( 0.0, 0.0, 0.0 );\n\n        #include light\n\n        gl_FragColor = vec4( vColor, opacity );\n        // gl_FragColor.rgb = vec3( 1.0, 0.0, 0.0 );\n        gl_FragColor.rgb *= vLightFront;\n        // gl_FragColor.rgb = normalx;\n        //gl_FragColor.rgb = vColor;\n    #endif\n\n    #include fog\n}\n";

// File:shader/SDFFont.vert

NGL.Resources[ 'shader/SDFFont.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec2 mapping;\nattribute vec2 inputTexCoord;\nattribute float inputSize;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvarying vec2 texCoord;\n\nuniform float nearClip;\n\n\nvoid main(void){\n\n    vColor = color;\n    texCoord = inputTexCoord;\n\n    vec4 cameraPos = ( modelViewMatrix * vec4( position, 1.0 ) );\n    vec4 cameraCornerPos = vec4( cameraPos.xyz, 1.0 );\n    cameraCornerPos.xy += mapping * inputSize;\n\n    cameraCornerPos.z += 0.5;\n\n    gl_Position = projectionMatrix * cameraCornerPos;\n\n    #ifdef NEAR_CLIP\n        // move out of viewing frustum for custom clipping\n        if( dot( cameraPos, vec4( 0.0, 0.0, 1.0, nearClip ) ) > 0.0 )\n            gl_Position.w = -10.0;\n    #endif\n\n}\n";

// File:shader/SDFFont.frag

NGL.Resources[ 'shader/SDFFont.frag' ] = "\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nuniform sampler2D fontTexture;\nuniform float opacity;\n\nvarying vec3 vColor;\nvarying vec2 texCoord;\n\n#include fog_params\n\nconst float smoothness = 16.0;\nconst float gamma = 2.2;\n\nvoid main() {\n\n    // retrieve signed distance\n    float sdf = texture2D( fontTexture, texCoord ).a;\n\n    // perform adaptive anti-aliasing of the edges\n    float w = clamp(\n        smoothness * ( abs( dFdx( texCoord.x ) ) + abs( dFdy( texCoord.y ) ) ),\n        0.0,\n        0.5\n    );\n    float a = smoothstep( 0.5 - w, 0.5 + w, sdf );\n\n    // gamma correction for linear attenuation\n    a = pow( a, 1.0 / gamma );\n\n    if( a < 0.2 ) discard;\n\n    a *= opacity;\n\n    gl_FragColor = vec4( vColor, a );\n\n    #include fog\n\n}\n\n";

// File:shader/SphereHalo.vert

NGL.Resources[ 'shader/SphereHalo.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec2 mapping;\nattribute float radius;\n\nvarying vec3 point;\nvarying vec3 cameraSpherePos;\nvarying float sphereRadius;\n\nuniform mat4 projectionMatrixInverse;\n\nconst mat4 D = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, -1.0\n);\n\nmat4 transpose( in mat4 inMatrix ) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}\n\n\n//------------------------------------------------------------------------------\n// Compute point size and center using the technique described in:\n// \"GPU-Based Ray-Casting of Quadratic Surfaces\"\n// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.\n//\n// Code based on\n/*=========================================================================\n\n Program:   Visualization Toolkit\n Module:    Quadrics_fs.glsl and Quadrics_vs.glsl\n\n Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n All rights reserved.\n See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n This software is distributed WITHOUT ANY WARRANTY; without even\n the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n PURPOSE.  See the above copyright notice for more information.\n\n =========================================================================*/\n\n// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl\n// .SECTION Thanks\n// <verbatim>\n//\n//  This file is part of the PointSprites plugin developed and contributed by\n//\n//  Copyright (c) CSCS - Swiss National Supercomputing Centre\n//                EDF - Electricite de France\n//\n//  John Biddiscombe, Ugo Varetto (CSCS)\n//  Stephane Ploix (EDF)\n//\n// </verbatim>\n//\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - adapted to work with quads\nvoid ComputePointSizeAndPositionInClipCoordSphere(){\n\n    vec2 xbc;\n    vec2 ybc;\n\n    mat4 T = mat4(\n        sphereRadius, 0.0, 0.0, 0.0,\n        0.0, sphereRadius, 0.0, 0.0,\n        0.0, 0.0, sphereRadius, 0.0,\n        position.x, position.y, position.z, 1.0\n    );\n\n    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );\n    float A = dot( R[ 3 ], D * R[ 3 ] );\n    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );\n    float C = dot( R[ 0 ], D * R[ 0 ] );\n    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;\n\n    A = dot( R[ 3 ], D * R[ 3 ] );\n    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );\n    C = dot( R[ 1 ], D * R[ 1 ] );\n    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;\n\n    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );\n    gl_Position.xy -= mapping * vec2( sx, sy );\n    gl_Position.xy *= gl_Position.w;\n}\n\n\nvoid main(void){\n\n    cameraSpherePos = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;\n    sphereRadius = radius * 1.3;\n\n    gl_Position = projectionMatrix * vec4( cameraSpherePos, 1.0 );\n    ComputePointSizeAndPositionInClipCoordSphere();\n\n    point = ( projectionMatrixInverse * gl_Position ).xyz;\n\n    // move out of viewing frustum to avoid clipping artifacts\n    if( gl_Position.z-sphereRadius<=1.0 )\n        gl_Position.z = -10.0;\n}\n\n\n\n\n\n";

// File:shader/SphereHalo.frag

NGL.Resources[ 'shader/SphereHalo.frag' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nvarying vec3 point;\nvarying vec3 cameraSpherePos;\nvarying float sphereRadius;\n\nuniform vec3 color;\n\n#include fog_params\n\n\nvoid main(void)\n{\n    vec3 rayDirection = normalize( point );\n\n    float B = -2.0 * dot(rayDirection, cameraSpherePos);\n    float C = dot(cameraSpherePos, cameraSpherePos) - (sphereRadius*sphereRadius);\n    float det = (B * B) - (4.0 * C);\n    if(det < 0.0)\n        discard;\n\n    float r2 = sphereRadius*0.97;\n    B = -2.0 * dot(rayDirection, cameraSpherePos);\n    C = dot(cameraSpherePos, cameraSpherePos) - (r2*r2);\n    det = (B * B) - (4.0 * C);\n\n    if(det < 0.0){\n        gl_FragColor = vec4( color, 1.0 );\n\n    }else{\n    	gl_FragColor = vec4( color, 0.5 );\n    }\n\n    #include fog\n}\n\n\n";

// File:shader/SphereImpostor.vert

NGL.Resources[ 'shader/SphereImpostor.vert' ] = "\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// uniform mat4 viewMatrix;\n// uniform mat3 normalMatrix;\n// uniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec2 mapping;\nattribute float radius;\n\nvarying vec3 point;\nvarying vec4 cameraSpherePos;\nvarying float sphereRadius;\n\n#ifdef PICKING\n    attribute vec3 pickingColor;\n    varying vec3 vPickingColor;\n#else\n    attribute vec3 color;\n    varying vec3 vColor;\n#endif\n\nuniform mat4 projectionMatrixInverse;\nuniform float nearClip;\n\nconst mat4 D = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, -1.0\n);\n\nmat4 transpose( in mat4 inMatrix ) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}\n\n\n//------------------------------------------------------------------------------\n// Compute point size and center using the technique described in:\n// \"GPU-Based Ray-Casting of Quadratic Surfaces\"\n// by Christian Sigg, Tim Weyrich, Mario Botsch, Markus Gross.\n//\n// Code based on\n/*=========================================================================\n\n Program:   Visualization Toolkit\n Module:    Quadrics_fs.glsl and Quadrics_vs.glsl\n\n Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n All rights reserved.\n See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n This software is distributed WITHOUT ANY WARRANTY; without even\n the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n PURPOSE.  See the above copyright notice for more information.\n\n =========================================================================*/\n\n// .NAME Quadrics_fs.glsl and Quadrics_vs.glsl\n// .SECTION Thanks\n// <verbatim>\n//\n//  This file is part of the PointSprites plugin developed and contributed by\n//\n//  Copyright (c) CSCS - Swiss National Supercomputing Centre\n//                EDF - Electricite de France\n//\n//  John Biddiscombe, Ugo Varetto (CSCS)\n//  Stephane Ploix (EDF)\n//\n// </verbatim>\n//\n// Contributions by Alexander Rose\n// - ported to WebGL\n// - adapted to work with quads\nvoid ComputePointSizeAndPositionInClipCoordSphere(){\n\n    vec2 xbc;\n    vec2 ybc;\n\n    mat4 T = mat4(\n        sphereRadius, 0.0, 0.0, 0.0,\n        0.0, sphereRadius, 0.0, 0.0,\n        0.0, 0.0, sphereRadius, 0.0,\n        position.x, position.y, position.z, 1.0\n    );\n\n    mat4 R = transpose( projectionMatrix * modelViewMatrix * T );\n    float A = dot( R[ 3 ], D * R[ 3 ] );\n    float B = -2.0 * dot( R[ 0 ], D * R[ 3 ] );\n    float C = dot( R[ 0 ], D * R[ 0 ] );\n    xbc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    xbc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    float sx = abs( xbc[ 0 ] - xbc[ 1 ] ) * 0.5;\n\n    A = dot( R[ 3 ], D * R[ 3 ] );\n    B = -2.0 * dot( R[ 1 ], D * R[ 3 ] );\n    C = dot( R[ 1 ], D * R[ 1 ] );\n    ybc[ 0 ] = ( -B - sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    ybc[ 1 ] = ( -B + sqrt( B * B - 4.0 * A * C ) ) / ( 2.0 * A );\n    float sy = abs( ybc[ 0 ] - ybc[ 1 ]  ) * 0.5;\n\n    gl_Position.xy = vec2( 0.5 * ( xbc.x + xbc.y ), 0.5 * ( ybc.x + ybc.y ) );\n    gl_Position.xy -= mapping * vec2( sx, sy );\n    gl_Position.xy *= gl_Position.w;\n\n}\n\n\nvoid main(void){\n\n    #ifdef PICKING\n        vPickingColor = pickingColor;\n    #else\n        vColor = color;\n    #endif\n\n    cameraSpherePos = ( modelViewMatrix * vec4( position, 1.0 ) ).xyzw;\n    sphereRadius = radius;\n\n    // avoid clipping, added again in fragment shader\n    cameraSpherePos.z -= radius;\n\n    gl_Position = projectionMatrix * vec4( cameraSpherePos.xyz, 1.0 );\n    ComputePointSizeAndPositionInClipCoordSphere();\n\n    point = ( projectionMatrixInverse * gl_Position ).xyz;\n\n}\n\n\n\n\n\n";

// File:shader/SphereImpostor.frag

NGL.Resources[ 'shader/SphereImpostor.frag' ] = "\n#extension GL_EXT_frag_depth : enable\n\n// not available in WebGL\n// #extension GL_ARB_conservative_depth : enable\n// layout(depth_less) out float gl_FragDepthEXT;\n\nprecision highp float;\nprecision highp int;\n\n// uniform mat4 viewMatrix;\n// uniform vec3 cameraPosition;\n\nuniform float opacity;\nuniform float nearClip;\nuniform mat4 projectionMatrix;\n\nvarying vec3 point;\nvarying vec4 cameraSpherePos;\nvarying float sphereRadius;\n\n#ifdef PICKING\n    uniform float objectId;\n    varying vec3 vPickingColor;\n#else\n    varying vec3 vColor;\n#endif\n\n#include light_params\n\n#include fog_params\n\n\nvec3 cameraPos;\nvec3 cameraNormal;\n\n\n// vec4 poly_color = gl_Color;\n\n//   if(uf_use_border_hinting == 1.0)\n//   {\n//     vec3 wc_eye_dir = normalize(wc_sp_pt);\n//     float n_dot_e   = abs(dot(wc_sp_nrml,wc_eye_dir));\n//     float alpha     = max(uf_border_color_start_cosine - n_dot_e,0.0)/uf_border_color_start_cosine;\n//     poly_color      = mix(gl_Color,uf_border_color,0.75*alpha);\n//   }\n\n//   color += (diff + amb)*poly_color + spec*gl_FrontMaterial.specular;\n\n\n// Calculate depth based on the given camera position.\nfloat calcDepth( in vec3 cameraPos )\n{\n    vec2 clipZW = cameraPos.z * projectionMatrix[2].zw + projectionMatrix[3].zw;\n    return 0.5 + 0.5 * clipZW.x / clipZW.y;\n}\n\n\nfloat calcClip( vec3 cameraPos )\n{\n    return dot( vec4( cameraPos, 1.0 ), vec4( 0.0, 0.0, 1.0, nearClip - 0.5 ) );\n}\n\n\nbool flag2 = false;\n\n\nbool Impostor(out vec3 cameraPos, out vec3 cameraNormal)\n{\n\n    vec3 cameraSpherePos2 = cameraSpherePos.xyz;\n    cameraSpherePos2.z += sphereRadius;\n\n    vec3 rayDirection = normalize( point );\n\n    float B = -2.0 * dot(rayDirection, cameraSpherePos2);\n    float C = dot(cameraSpherePos2, cameraSpherePos2) - (sphereRadius*sphereRadius);\n\n    float det = (B * B) - (4.0 * C);\n    if(det < 0.0){\n        discard;\n        return false;\n    }else{\n        float sqrtDet = sqrt(det);\n        float posT = (-B + sqrtDet)/2.0;\n        float negT = (-B - sqrtDet)/2.0;\n\n        float intersectT = min(posT, negT);\n        cameraPos = rayDirection * intersectT;\n\n        #ifdef NEAR_CLIP\n            if( calcDepth( cameraPos ) <= 0.0 ){\n                cameraPos = rayDirection * max(posT, negT);\n                cameraNormal = vec3( 0.0, 0.0, 0.4 );\n                return false;\n            }else if( calcClip( cameraPos ) > 0.0 ){\n                cameraPos = rayDirection * max(posT, negT);\n                cameraNormal = vec3( 0.0, 0.0, 0.4 );\n                flag2 = true;\n                return false;\n            }else{\n                cameraNormal = normalize(cameraPos - cameraSpherePos2);\n            }\n        #else\n            if( calcDepth( cameraPos ) <= 0.0 ){\n                cameraPos = rayDirection * max(posT, negT);\n                cameraNormal = vec3( 0.0, 0.0, 0.4 );\n                return false;\n            }else{\n                cameraNormal = normalize(cameraPos - cameraSpherePos2);\n            }\n        #endif\n\n        return true;\n    }\n\n    return false; // ensure that each control flow has a return\n\n}\n\n\nvoid main(void)\n{\n\n    bool flag = Impostor( cameraPos, cameraNormal );\n\n    #ifdef NEAR_CLIP\n        if( calcClip( cameraPos ) > 0.0 )\n            discard;\n    #endif\n\n    // FIXME not compatible with custom clipping plane\n    //Set the depth based on the new cameraPos.\n    gl_FragDepthEXT = calcDepth( cameraPos );\n    if( !flag ){\n\n        // clamp to near clipping plane and add a tiny value to\n        // make spheres with a greater radius occlude smaller ones\n        #ifdef NEAR_CLIP\n            if( flag2 ){\n                gl_FragDepthEXT = max( 0.0, calcDepth( vec3( - ( nearClip - 0.5 ) ) ) + ( 0.0000001 / sphereRadius ) );\n            }else if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = 0.0 + ( 0.0000001 / sphereRadius );\n            }\n        #else\n            if( gl_FragDepthEXT >= 0.0 ){\n                gl_FragDepthEXT = 0.0 + ( 0.0000001 / sphereRadius );\n            }\n        #endif\n\n    }\n\n    // bugfix (mac only?)\n    if (gl_FragDepthEXT < 0.0)\n        discard;\n    if (gl_FragDepthEXT > 1.0)\n        discard;\n\n    #ifdef PICKING\n        gl_FragColor = vec4( vPickingColor, objectId );\n        //gl_FragColor.rgb = vec3( 1.0, 0.0, 0.0 );\n    #else\n        vec3 transformedNormal = cameraNormal;\n        vec3 vLightFront = vec3( 0.0, 0.0, 0.0 );\n\n        #include light\n\n        gl_FragColor = vec4( vColor, opacity );\n        gl_FragColor.rgb *= vLightFront;\n\n        // gl_FragColor.a = 0.5;\n        // gl_FragColor.rgb = transformedNormal;\n        // gl_FragColor.rgb = point;\n    #endif\n\n    // #include fog\n\n    #ifdef USE_FOG\n        float depth = gl_FragDepthEXT / gl_FragCoord.w;\n        #ifdef FOG_EXP2\n            const float LOG2 = 1.442695;\n            float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n            fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n        #else\n            float fogFactor = smoothstep( fogNear, fogFar, depth );\n        #endif\n        gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n    #endif\n\n}\n\n\n// void main2(void)\n// {\n//     gl_FragColor = vec4( vColor, 1.0 );\n// }\n\n\n\n";

// File:shader/chunk/fog.glsl

NGL.Resources[ 'shader/chunk/fog.glsl' ] = "#ifdef USE_FOG\n	float depth = gl_FragCoord.z / gl_FragCoord.w;\n	float fogFactor = smoothstep( fogNear, fogFar, depth );\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif";

// File:shader/chunk/fog_params.glsl

NGL.Resources[ 'shader/chunk/fog_params.glsl' ] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	uniform float fogNear;\n	uniform float fogFar;\n#endif";

// File:shader/chunk/light.glsl

NGL.Resources[ 'shader/chunk/light.glsl' ] = "// LIGHT\n// IN: transformedNormal, vLightFront\n// OUT: vLightFront\n\n// Give light vector position perpendicular to the screen\nvec3 lightvec = normalize( vec3( 0.0, 0.0, 1.2 ) );\nvec3 eyepos = vec3( 0.0, 0.0, 1.0 );\n\n// calculate half-angle vector\nvec3 halfvec = normalize( lightvec + eyepos );\n\n// Parameters used to calculate per pixel lighting\n// see http://http.developer.nvidia.com/CgTutorial/cg_tutorial_chapter05.html\nfloat diffuse = dot( transformedNormal,lightvec );\nfloat specular = dot( transformedNormal, halfvec );\nvec4 lighting = lit( diffuse, specular, 512.0 );\n\nvec3 specularcolor = vec3( 1.0, 1.0, 1.0 );\n\nvLightFront = ( vLightFront + lighting.y * vec3( 1.0, 1.0, 1.0 ) + lighting.z * specularcolor ).xyz;";

// File:shader/chunk/light_params.glsl

NGL.Resources[ 'shader/chunk/light_params.glsl' ] = "vec4 lit( float NdotL, float NdotH, float m ){\n    float ambient = 1.0;\n    float diffuse = max( NdotL, 0.0 );\n    float specular = pow( abs( NdotH ), m );\n    if( NdotL < 0.0 || NdotH < 0.0 )\n        specular = 0.0;\n    return vec4( ambient, diffuse, specular, 1.0 );\n}";

// File:fonts/LatoBlack.fnt

NGL.Resources[ 'fonts/LatoBlack.fnt' ] = "info face=\"Lato Black\" size=32 bold=0 italic=0 charset=\"\" unicode=0 stretchH=100 smooth=1 aa=1 padding=4,4,4,4 spacing=-8,-8\ncommon lineHeight=39 base=32 scaleW=512 scaleH=512 pages=1 packed=0\npage id=0 file=\"LatoBlack-sdf.png\"\nchars count=95\nchar id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=32    xadvance=6     page=0  chnl=0\nchar id=41   x=0     y=0     width=17     height=41     xoffset=-3     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=40   x=17     y=0     width=17     height=41     xoffset=-3     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=36   x=34     y=0     width=27     height=40     xoffset=-4     yoffset=0    xadvance=19     page=0  chnl=0\nchar id=124   x=61     y=0     width=14     height=40     xoffset=-2     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=125   x=75     y=0     width=19     height=40     xoffset=-4     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=123   x=94     y=0     width=18     height=40     xoffset=-4     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=93   x=112     y=0     width=18     height=40     xoffset=-4     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=91   x=130     y=0     width=17     height=40     xoffset=-3     yoffset=2    xadvance=10     page=0  chnl=0\nchar id=106   x=147     y=0     width=18     height=38     xoffset=-5     yoffset=4    xadvance=9     page=0  chnl=0\nchar id=81   x=165     y=0     width=36     height=38     xoffset=-4     yoffset=3    xadvance=26     page=0  chnl=0\nchar id=92   x=201     y=0     width=24     height=36     xoffset=-5     yoffset=3    xadvance=13     page=0  chnl=0\nchar id=64   x=225     y=0     width=35     height=36     xoffset=-4     yoffset=5    xadvance=26     page=0  chnl=0\nchar id=47   x=260     y=0     width=24     height=36     xoffset=-5     yoffset=3    xadvance=13     page=0  chnl=0\nchar id=127   x=284     y=0     width=27     height=34     xoffset=-4     yoffset=3    xadvance=18     page=0  chnl=0\nchar id=38   x=311     y=0     width=33     height=34     xoffset=-4     yoffset=3    xadvance=23     page=0  chnl=0\nchar id=35   x=344     y=0     width=28     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=37   x=372     y=0     width=35     height=34     xoffset=-4     yoffset=3    xadvance=26     page=0  chnl=0\nchar id=63   x=407     y=0     width=23     height=34     xoffset=-4     yoffset=3    xadvance=14     page=0  chnl=0\nchar id=33   x=430     y=0     width=15     height=34     xoffset=-1     yoffset=3    xadvance=12     page=0  chnl=0\nchar id=48   x=445     y=0     width=27     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=56   x=472     y=0     width=27     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=55   x=0     y=41     width=26     height=34     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=54   x=26     y=41     width=26     height=34     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=53   x=52     y=41     width=26     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=52   x=78     y=41     width=28     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=51   x=106     y=41     width=26     height=34     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=50   x=132     y=41     width=26     height=34     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=49   x=158     y=41     width=25     height=34     xoffset=-2     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=108   x=183     y=41     width=15     height=34     xoffset=-2     yoffset=3    xadvance=9     page=0  chnl=0\nchar id=107   x=198     y=41     width=27     height=34     xoffset=-3     yoffset=3    xadvance=18     page=0  chnl=0\nchar id=104   x=225     y=41     width=25     height=34     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=100   x=250     y=41     width=26     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=98   x=276     y=41     width=26     height=34     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=90   x=302     y=41     width=28     height=34     xoffset=-4     yoffset=3    xadvance=20     page=0  chnl=0\nchar id=89   x=330     y=41     width=32     height=34     xoffset=-5     yoffset=3    xadvance=22     page=0  chnl=0\nchar id=88   x=362     y=41     width=32     height=34     xoffset=-4     yoffset=3    xadvance=23     page=0  chnl=0\nchar id=87   x=394     y=41     width=44     height=34     xoffset=-4     yoffset=3    xadvance=34     page=0  chnl=0\nchar id=86   x=438     y=41     width=33     height=34     xoffset=-4     yoffset=3    xadvance=24     page=0  chnl=0\nchar id=85   x=471     y=41     width=30     height=34     xoffset=-3     yoffset=3    xadvance=23     page=0  chnl=0\nchar id=84   x=0     y=75     width=28     height=34     xoffset=-4     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=83   x=28     y=75     width=26     height=34     xoffset=-4     yoffset=3    xadvance=17     page=0  chnl=0\nchar id=82   x=54     y=75     width=29     height=34     xoffset=-3     yoffset=3    xadvance=21     page=0  chnl=0\nchar id=80   x=83     y=75     width=28     height=34     xoffset=-3     yoffset=3    xadvance=20     page=0  chnl=0\nchar id=79   x=111     y=75     width=34     height=34     xoffset=-4     yoffset=3    xadvance=26     page=0  chnl=0\nchar id=78   x=145     y=75     width=31     height=34     xoffset=-3     yoffset=3    xadvance=24     page=0  chnl=0\nchar id=77   x=176     y=75     width=37     height=34     xoffset=-3     yoffset=3    xadvance=30     page=0  chnl=0\nchar id=76   x=213     y=75     width=24     height=34     xoffset=-3     yoffset=3    xadvance=17     page=0  chnl=0\nchar id=75   x=237     y=75     width=31     height=34     xoffset=-3     yoffset=3    xadvance=23     page=0  chnl=0\nchar id=74   x=268     y=75     width=21     height=34     xoffset=-4     yoffset=3    xadvance=14     page=0  chnl=0\nchar id=73   x=289     y=75     width=15     height=34     xoffset=-2     yoffset=3    xadvance=10     page=0  chnl=0\nchar id=72   x=304     y=75     width=31     height=34     xoffset=-3     yoffset=3    xadvance=24     page=0  chnl=0\nchar id=71   x=335     y=75     width=31     height=34     xoffset=-4     yoffset=3    xadvance=23     page=0  chnl=0\nchar id=70   x=366     y=75     width=25     height=34     xoffset=-3     yoffset=3    xadvance=18     page=0  chnl=0\nchar id=69   x=391     y=75     width=25     height=34     xoffset=-3     yoffset=3    xadvance=18     page=0  chnl=0\nchar id=68   x=416     y=75     width=32     height=34     xoffset=-3     yoffset=3    xadvance=24     page=0  chnl=0\nchar id=67   x=448     y=75     width=30     height=34     xoffset=-4     yoffset=3    xadvance=21     page=0  chnl=0\nchar id=66   x=478     y=75     width=28     height=34     xoffset=-3     yoffset=3    xadvance=21     page=0  chnl=0\nchar id=65   x=0     y=109     width=33     height=34     xoffset=-4     yoffset=3    xadvance=24     page=0  chnl=0\nchar id=57   x=33     y=109     width=27     height=33     xoffset=-3     yoffset=4    xadvance=19     page=0  chnl=0\nchar id=105   x=60     y=109     width=16     height=33     xoffset=-3     yoffset=4    xadvance=9     page=0  chnl=0\nchar id=102   x=76     y=109     width=21     height=33     xoffset=-4     yoffset=4    xadvance=12     page=0  chnl=0\nchar id=121   x=97     y=109     width=27     height=32     xoffset=-4     yoffset=10    xadvance=18     page=0  chnl=0\nchar id=116   x=124     y=109     width=22     height=32     xoffset=-4     yoffset=5    xadvance=13     page=0  chnl=0\nchar id=113   x=146     y=109     width=26     height=32     xoffset=-4     yoffset=10    xadvance=19     page=0  chnl=0\nchar id=112   x=172     y=109     width=26     height=32     xoffset=-3     yoffset=10    xadvance=19     page=0  chnl=0\nchar id=103   x=198     y=109     width=26     height=32     xoffset=-4     yoffset=10    xadvance=17     page=0  chnl=0\nchar id=59   x=224     y=109     width=16     height=31     xoffset=-3     yoffset=11    xadvance=9     page=0  chnl=0\nchar id=122   x=240     y=109     width=23     height=27     xoffset=-3     yoffset=10    xadvance=15     page=0  chnl=0\nchar id=120   x=263     y=109     width=27     height=27     xoffset=-4     yoffset=10    xadvance=18     page=0  chnl=0\nchar id=119   x=290     y=109     width=35     height=27     xoffset=-4     yoffset=10    xadvance=26     page=0  chnl=0\nchar id=118   x=325     y=109     width=27     height=27     xoffset=-4     yoffset=10    xadvance=18     page=0  chnl=0\nchar id=117   x=352     y=109     width=25     height=27     xoffset=-3     yoffset=10    xadvance=19     page=0  chnl=0\nchar id=115   x=377     y=109     width=23     height=27     xoffset=-4     yoffset=10    xadvance=14     page=0  chnl=0\nchar id=114   x=400     y=109     width=21     height=27     xoffset=-3     yoffset=10    xadvance=13     page=0  chnl=0\nchar id=110   x=421     y=109     width=25     height=27     xoffset=-3     yoffset=10    xadvance=19     page=0  chnl=0\nchar id=109   x=446     y=109     width=34     height=27     xoffset=-3     yoffset=10    xadvance=28     page=0  chnl=0\nchar id=101   x=480     y=109     width=26     height=27     xoffset=-4     yoffset=10    xadvance=17     page=0  chnl=0\nchar id=99   x=0     y=143     width=25     height=27     xoffset=-4     yoffset=10    xadvance=16     page=0  chnl=0\nchar id=97   x=25     y=143     width=24     height=27     xoffset=-3     yoffset=10    xadvance=17     page=0  chnl=0\nchar id=43   x=49     y=143     width=26     height=26     xoffset=-3     yoffset=8    xadvance=19     page=0  chnl=0\nchar id=58   x=75     y=143     width=16     height=26     xoffset=-3     yoffset=11    xadvance=9     page=0  chnl=0\nchar id=111   x=91     y=143     width=27     height=26     xoffset=-4     yoffset=11    xadvance=19     page=0  chnl=0\nchar id=62   x=118     y=143     width=23     height=25     xoffset=-1     yoffset=9    xadvance=19     page=0  chnl=0\nchar id=60   x=141     y=143     width=23     height=25     xoffset=-2     yoffset=9    xadvance=19     page=0  chnl=0\nchar id=42   x=164     y=143     width=21     height=21     xoffset=-4     yoffset=3    xadvance=13     page=0  chnl=0\nchar id=94   x=185     y=143     width=25     height=21     xoffset=-3     yoffset=3    xadvance=19     page=0  chnl=0\nchar id=44   x=210     y=143     width=15     height=20     xoffset=-3     yoffset=22    xadvance=8     page=0  chnl=0\nchar id=61   x=225     y=143     width=25     height=19     xoffset=-3     yoffset=12    xadvance=19     page=0  chnl=0\nchar id=39   x=250     y=143     width=15     height=19     xoffset=-3     yoffset=3    xadvance=8     page=0  chnl=0\nchar id=34   x=265     y=143     width=21     height=19     xoffset=-3     yoffset=3    xadvance=14     page=0  chnl=0\nchar id=126   x=286     y=143     width=26     height=17     xoffset=-3     yoffset=14    xadvance=19     page=0  chnl=0\nchar id=46   x=312     y=143     width=16     height=16     xoffset=-4     yoffset=21    xadvance=8     page=0  chnl=0\nchar id=96   x=328     y=143     width=18     height=15     xoffset=-5     yoffset=3    xadvance=11     page=0  chnl=0\nchar id=95   x=346     y=143     width=22     height=13     xoffset=-4     yoffset=29    xadvance=13     page=0  chnl=0\nchar id=45   x=368     y=143     width=19     height=13     xoffset=-3     yoffset=16    xadvance=12     page=0  chnl=0\n";

// File:fonts/LatoBlack.png

NGL.Resources[ 'fonts/LatoBlack.png' ] = NGL.dataURItoImage("data:image/png;base64,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CCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEKJM+X8Bl4tInGh6U68AAAAASUVORK5CYII=");

// File:img/radial.png

NGL.Resources[ 'img/radial.png' ] = NGL.dataURItoImage("data:image/png;base64,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");

